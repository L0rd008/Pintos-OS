
kernel.o:     file format elf32-i386


Disassembly of section .text:

c0020078 <start>:
c0020078:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
c002007d:	8e c0                	mov    %eax,%es
c002007f:	fc                   	cld    
c0020080:	b4 88                	mov    $0x88,%ah
c0020082:	cd 15                	int    $0x15
c0020084:	66 05 00 04          	add    $0x400,%ax
c0020088:	00 00                	add    %al,(%eax)
c002008a:	66 3d 00 00          	cmp    $0x0,%ax
c002008e:	01 00                	add    %eax,(%eax)
c0020090:	76 06                	jbe    c0020098 <start+0x20>
c0020092:	66 b8 00 00          	mov    $0x0,%ax
c0020096:	01 00                	add    %eax,(%eax)
c0020098:	66 c1 e8 02          	shr    $0x2,%ax
c002009c:	67 66 a3 7e 01       	addr16 mov %ax,0x17e
c00200a1:	00 00                	add    %al,(%eax)
c00200a3:	e4 64                	in     $0x64,%al
c00200a5:	a8 02                	test   $0x2,%al
c00200a7:	75 fa                	jne    c00200a3 <start+0x2b>
c00200a9:	b0 d1                	mov    $0xd1,%al
c00200ab:	e6 64                	out    %al,$0x64
c00200ad:	e4 64                	in     $0x64,%al
c00200af:	a8 02                	test   $0x2,%al
c00200b1:	75 fa                	jne    c00200ad <start+0x35>
c00200b3:	b0 df                	mov    $0xdf,%al
c00200b5:	e6 60                	out    %al,$0x60
c00200b7:	e4 64                	in     $0x64,%al
c00200b9:	a8 02                	test   $0x2,%al
c00200bb:	75 fa                	jne    c00200b7 <start+0x3f>
c00200bd:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
c00200c2:	66 29 c0             	sub    %ax,%ax
c00200c5:	66 29 ff             	sub    %di,%di
c00200c8:	66 b9 00 04          	mov    $0x400,%cx
c00200cc:	00 00                	add    %al,(%eax)
c00200ce:	66 f3 ab             	rep stos %ax,%es:(%edi)
c00200d1:	66 b8 07 00          	mov    $0x7,%ax
c00200d5:	01 00                	add    %eax,(%eax)
c00200d7:	66 b9 11 00          	mov    $0x11,%cx
c00200db:	00 00                	add    %al,(%eax)
c00200dd:	66 29 ff             	sub    %di,%di
c00200e0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200e7:	85 
c00200e8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
c00200eb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
c00200f2:	00 e2                	add    %ah,%dl
c00200f4:	eb b8                	jmp    c00200ae <start+0x36>
c00200f6:	00 10                	add    %dl,(%eax)
c00200f8:	8e c0                	mov    %eax,%es
c00200fa:	66 b8 07 00          	mov    $0x7,%ax
c00200fe:	00 00                	add    %al,(%eax)
c0020100:	66 b9 00 40          	mov    $0x4000,%cx
c0020104:	00 00                	add    %al,(%eax)
c0020106:	66 29 ff             	sub    %di,%di
c0020109:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c0020110:	66 
c0020111:	05 00 10 00 00       	add    $0x1000,%eax
c0020116:	e2 f1                	loop   c0020109 <start+0x91>
c0020118:	66 b8 00 f0          	mov    $0xf000,%ax
c002011c:	00 00                	add    %al,(%eax)
c002011e:	0f 22 d8             	mov    %eax,%cr3
c0020121:	fa                   	cli    
c0020122:	67 66 0f 01 15       	lgdtw  (%di)
c0020127:	78 01                	js     c002012a <start+0xb2>
c0020129:	00 00                	add    %al,(%eax)
c002012b:	0f 20 c0             	mov    %cr0,%eax
c002012e:	66 0d 05 00          	or     $0x5,%ax
c0020132:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
c0020138:	ea 3f 01 02 c0 08 00 	ljmp   $0x8,$0xc002013f
c002013f:	66 b8 10 00          	mov    $0x10,%ax
c0020143:	8e d8                	mov    %eax,%ds
c0020145:	8e c0                	mov    %eax,%es
c0020147:	8e e0                	mov    %eax,%fs
c0020149:	8e e8                	mov    %eax,%gs
c002014b:	8e d0                	mov    %eax,%ss
c002014d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
c0020153:	bd 00 00 00 00       	mov    $0x0,%ebp
c0020158:	e8 77 01 00 00       	call   c00202d4 <pintos_init>
c002015d:	eb fe                	jmp    c002015d <start+0xe5>
	...

c0020160 <gdt>:
	...
c0020168:	ff                   	(bad)  
c0020169:	ff 00                	incl   (%eax)
c002016b:	00 00                	add    %al,(%eax)
c002016d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020174:	00                   	.byte 0x0
c0020175:	92                   	xchg   %eax,%edx
c0020176:	cf                   	iret   
	...

c0020178 <gdtdesc>:
c0020178:	17                   	pop    %ss
c0020179:	00 60 01             	add    %ah,0x1(%eax)
c002017c:	02 c0                	add    %al,%al

c002017e <init_ram_pages>:
c002017e:	00 00                	add    %al,(%eax)
	...

c0020182 <pg_ofs>:
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
c0020182:	55                   	push   %ebp
c0020183:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0020185:	8b 45 08             	mov    0x8(%ebp),%eax
c0020188:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002018d:	5d                   	pop    %ebp
c002018e:	c3                   	ret    

c002018f <is_kernel_vaddr>:
}

/* Returns true if VADDR is a kernel virtual address. */
static inline bool
is_kernel_vaddr (const void *vaddr) 
{
c002018f:	55                   	push   %ebp
c0020190:	89 e5                	mov    %esp,%ebp
  return vaddr >= PHYS_BASE;
c0020192:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c0020199:	0f 97 c0             	seta   %al
}
c002019c:	5d                   	pop    %ebp
c002019d:	c3                   	ret    

c002019e <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c002019e:	55                   	push   %ebp
c002019f:	89 e5                	mov    %esp,%ebp
c00201a1:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c00201a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00201a7:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00201ac:	76 1e                	jbe    c00201cc <ptov+0x2e>
c00201ae:	83 ec 0c             	sub    $0xc,%esp
c00201b1:	68 20 e4 02 c0       	push   $0xc002e420
c00201b6:	68 3b e4 02 c0       	push   $0xc002e43b
c00201bb:	68 c8 e7 02 c0       	push   $0xc002e7c8
c00201c0:	6a 4a                	push   $0x4a
c00201c2:	68 52 e4 02 c0       	push   $0xc002e452
c00201c7:	e8 52 93 00 00       	call   c002951e <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c00201cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00201cf:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c00201d4:	c9                   	leave  
c00201d5:	c3                   	ret    

c00201d6 <vtop>:

/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
c00201d6:	55                   	push   %ebp
c00201d7:	89 e5                	mov    %esp,%ebp
c00201d9:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_kernel_vaddr (vaddr));
c00201dc:	ff 75 08             	push   0x8(%ebp)
c00201df:	e8 ab ff ff ff       	call   c002018f <is_kernel_vaddr>
c00201e4:	83 c4 04             	add    $0x4,%esp
c00201e7:	84 c0                	test   %al,%al
c00201e9:	75 1e                	jne    c0020209 <vtop+0x33>
c00201eb:	83 ec 0c             	sub    $0xc,%esp
c00201ee:	68 68 e4 02 c0       	push   $0xc002e468
c00201f3:	68 3b e4 02 c0       	push   $0xc002e43b
c00201f8:	68 f0 e7 02 c0       	push   $0xc002e7f0
c00201fd:	6a 54                	push   $0x54
c00201ff:	68 52 e4 02 c0       	push   $0xc002e452
c0020204:	e8 15 93 00 00       	call   c002951e <debug_panic>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c0020209:	8b 45 08             	mov    0x8(%ebp),%eax
c002020c:	05 00 00 00 40       	add    $0x40000000,%eax
}
c0020211:	c9                   	leave  
c0020212:	c3                   	ret    

c0020213 <pt_no>:
#define PDSHIFT (PTSHIFT + PTBITS)         /* First page directory bit. */
#define PDBITS  10                         /* Number of page dir bits. */
#define PDMASK  BITMASK(PDSHIFT, PDBITS)   /* Page directory bits (22:31). */

/* Obtains page table index from a virtual address. */
static inline unsigned pt_no (const void *va) {
c0020213:	55                   	push   %ebp
c0020214:	89 e5                	mov    %esp,%ebp
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c0020216:	8b 45 08             	mov    0x8(%ebp),%eax
c0020219:	c1 e8 0c             	shr    $0xc,%eax
c002021c:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c0020221:	5d                   	pop    %ebp
c0020222:	c3                   	ret    

c0020223 <pd_no>:

/* Obtains page directory index from a virtual address. */
static inline uintptr_t pd_no (const void *va) {
c0020223:	55                   	push   %ebp
c0020224:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PDSHIFT;
c0020226:	8b 45 08             	mov    0x8(%ebp),%eax
c0020229:	c1 e8 16             	shr    $0x16,%eax
}
c002022c:	5d                   	pop    %ebp
c002022d:	c3                   	ret    

c002022e <pde_create>:
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt) {
c002022e:	55                   	push   %ebp
c002022f:	89 e5                	mov    %esp,%ebp
c0020231:	83 ec 08             	sub    $0x8,%esp
  ASSERT (pg_ofs (pt) == 0);
c0020234:	ff 75 08             	push   0x8(%ebp)
c0020237:	e8 46 ff ff ff       	call   c0020182 <pg_ofs>
c002023c:	83 c4 04             	add    $0x4,%esp
c002023f:	85 c0                	test   %eax,%eax
c0020241:	74 1e                	je     c0020261 <pde_create+0x33>
c0020243:	83 ec 0c             	sub    $0xc,%esp
c0020246:	68 80 e4 02 c0       	push   $0xc002e480
c002024b:	68 3b e4 02 c0       	push   $0xc002e43b
c0020250:	68 d0 e7 02 c0       	push   $0xc002e7d0
c0020255:	6a 48                	push   $0x48
c0020257:	68 91 e4 02 c0       	push   $0xc002e491
c002025c:	e8 bd 92 00 00       	call   c002951e <debug_panic>
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c0020261:	83 ec 0c             	sub    $0xc,%esp
c0020264:	ff 75 08             	push   0x8(%ebp)
c0020267:	e8 6a ff ff ff       	call   c00201d6 <vtop>
c002026c:	83 c4 10             	add    $0x10,%esp
c002026f:	83 c8 07             	or     $0x7,%eax
}
c0020272:	c9                   	leave  
c0020273:	c3                   	ret    

c0020274 <pte_create_kernel>:

/* Returns a PTE that points to PAGE.
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
c0020274:	55                   	push   %ebp
c0020275:	89 e5                	mov    %esp,%ebp
c0020277:	83 ec 18             	sub    $0x18,%esp
c002027a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002027d:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (pg_ofs (page) == 0);
c0020280:	ff 75 08             	push   0x8(%ebp)
c0020283:	e8 fa fe ff ff       	call   c0020182 <pg_ofs>
c0020288:	83 c4 04             	add    $0x4,%esp
c002028b:	85 c0                	test   %eax,%eax
c002028d:	74 1e                	je     c00202ad <pte_create_kernel+0x39>
c002028f:	83 ec 0c             	sub    $0xc,%esp
c0020292:	68 a5 e4 02 c0       	push   $0xc002e4a5
c0020297:	68 3b e4 02 c0       	push   $0xc002e43b
c002029c:	68 dc e7 02 c0       	push   $0xc002e7dc
c00202a1:	6a 58                	push   $0x58
c00202a3:	68 91 e4 02 c0       	push   $0xc002e491
c00202a8:	e8 71 92 00 00       	call   c002951e <debug_panic>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c00202ad:	83 ec 0c             	sub    $0xc,%esp
c00202b0:	ff 75 08             	push   0x8(%ebp)
c00202b3:	e8 1e ff ff ff       	call   c00201d6 <vtop>
c00202b8:	83 c4 10             	add    $0x10,%esp
c00202bb:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c00202bf:	74 07                	je     c00202c8 <pte_create_kernel+0x54>
c00202c1:	ba 02 00 00 00       	mov    $0x2,%edx
c00202c6:	eb 05                	jmp    c00202cd <pte_create_kernel+0x59>
c00202c8:	ba 00 00 00 00       	mov    $0x0,%edx
c00202cd:	09 d0                	or     %edx,%eax
c00202cf:	83 c8 01             	or     $0x1,%eax
}
c00202d2:	c9                   	leave  
c00202d3:	c3                   	ret    

c00202d4 <pintos_init>:
int pintos_init (void) NO_RETURN;

/* Pintos main entry point. */
int
pintos_init (void)
{
c00202d4:	55                   	push   %ebp
c00202d5:	89 e5                	mov    %esp,%ebp
c00202d7:	83 ec 18             	sub    $0x18,%esp
  char **argv;

  /* Clear BSS. */  
  bss_init ();
c00202da:	e8 ae 00 00 00       	call   c002038d <bss_init>

  /* Break command line into arguments and parse options. */
  argv = read_command_line ();
c00202df:	e8 0a 02 00 00       	call   c00204ee <read_command_line>
c00202e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  argv = parse_options (argv);
c00202e7:	83 ec 0c             	sub    $0xc,%esp
c00202ea:	ff 75 f4             	push   -0xc(%ebp)
c00202ed:	e8 28 03 00 00       	call   c002061a <parse_options>
c00202f2:	83 c4 10             	add    $0x10,%esp
c00202f5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Initialize ourselves as a thread so we can use locks,
     then enable console locking. */
  thread_init ();
c00202f8:	e8 c5 05 00 00       	call   c00208c2 <thread_init>
  console_init ();  
c00202fd:	e8 88 b2 00 00       	call   c002b58a <console_init>

  /* Greet user. */
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
          init_ram_pages * PGSIZE / 1024);
c0020302:	a1 7e 01 02 c0       	mov    0xc002017e,%eax
c0020307:	c1 e0 0c             	shl    $0xc,%eax
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c002030a:	c1 e8 0a             	shr    $0xa,%eax
c002030d:	83 ec 08             	sub    $0x8,%esp
c0020310:	50                   	push   %eax
c0020311:	68 b8 e4 02 c0       	push   $0xc002e4b8
c0020316:	e8 61 6e 00 00       	call   c002717c <printf>
c002031b:	83 c4 10             	add    $0x10,%esp

  /* Initialize memory system. */
  palloc_init (user_page_limit);
c002031e:	a1 00 30 03 c0       	mov    0xc0033000,%eax
c0020323:	83 ec 0c             	sub    $0xc,%esp
c0020326:	50                   	push   %eax
c0020327:	e8 7d 2c 00 00       	call   c0022fa9 <palloc_init>
c002032c:	83 c4 10             	add    $0x10,%esp
  malloc_init ();
c002032f:	e8 7c 30 00 00       	call   c00233b0 <malloc_init>
  paging_init ();
c0020334:	e8 7a 00 00 00       	call   c00203b3 <paging_init>
  tss_init ();
  gdt_init ();
#endif

  /* Initialize interrupt handlers. */
  intr_init ();
c0020339:	e8 73 10 00 00       	call   c00213b1 <intr_init>
  timer_init ();
c002033e:	e8 23 38 00 00       	call   c0023b66 <timer_init>
  kbd_init ();
c0020343:	e8 10 3e 00 00       	call   c0024158 <kbd_init>
  input_init ();
c0020348:	e8 93 60 00 00       	call   c00263e0 <input_init>
  exception_init ();
  syscall_init ();
#endif

  /* Start thread scheduler and enable interrupts. */
  thread_start ();
c002034d:	e8 0f 06 00 00       	call   c0020961 <thread_start>
  serial_init_queue ();
c0020352:	e8 cf 45 00 00       	call   c0024926 <serial_init_queue>
  timer_calibrate ();
c0020357:	e8 3b 38 00 00       	call   c0023b97 <timer_calibrate>
  ide_init ();
  locate_block_devices ();
  filesys_init (format_filesys);
#endif

  printf ("Boot complete.\n");
c002035c:	83 ec 0c             	sub    $0xc,%esp
c002035f:	68 db e4 02 c0       	push   $0xc002e4db
c0020364:	e8 7a b3 00 00       	call   c002b6e3 <puts>
c0020369:	83 c4 10             	add    $0x10,%esp
  
  if (*argv != NULL) {
c002036c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002036f:	8b 00                	mov    (%eax),%eax
c0020371:	85 c0                	test   %eax,%eax
c0020373:	74 0e                	je     c0020383 <pintos_init+0xaf>
    /* Run actions specified on kernel command line. */
    run_actions (argv);
c0020375:	83 ec 0c             	sub    $0xc,%esp
c0020378:	ff 75 f4             	push   -0xc(%ebp)
c002037b:	e8 35 04 00 00       	call   c00207b5 <run_actions>
c0020380:	83 c4 10             	add    $0x10,%esp
  } else {
    // TODO: no command line passed to kernel. Run interactively 
  }

  /* Finish up. */
  shutdown ();
c0020383:	e8 52 68 00 00       	call   c0026bda <shutdown>
  thread_exit ();
c0020388:	e8 6b 09 00 00       	call   c0020cf8 <thread_exit>

c002038d <bss_init>:

   The start and end of the BSS segment is recorded by the
   linker as _start_bss and _end_bss.  See kernel.lds. */
static void
bss_init (void) 
{
c002038d:	55                   	push   %ebp
c002038e:	89 e5                	mov    %esp,%ebp
c0020390:	83 ec 08             	sub    $0x8,%esp
  extern char _start_bss, _end_bss;
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c0020393:	b8 60 54 03 c0       	mov    $0xc0035460,%eax
c0020398:	2d 84 38 03 c0       	sub    $0xc0033884,%eax
c002039d:	83 ec 04             	sub    $0x4,%esp
c00203a0:	50                   	push   %eax
c00203a1:	6a 00                	push   $0x0
c00203a3:	68 84 38 03 c0       	push   $0xc0033884
c00203a8:	e8 9d 85 00 00       	call   c002894a <memset>
c00203ad:	83 c4 10             	add    $0x10,%esp
}
c00203b0:	90                   	nop
c00203b1:	c9                   	leave  
c00203b2:	c3                   	ret    

c00203b3 <paging_init>:
   kernel virtual mapping, and then sets up the CPU to use the
   new page directory.  Points init_page_dir to the page
   directory it creates. */
static void
paging_init (void)
{
c00203b3:	55                   	push   %ebp
c00203b4:	89 e5                	mov    %esp,%ebp
c00203b6:	53                   	push   %ebx
c00203b7:	83 ec 24             	sub    $0x24,%esp
  uint32_t *pd, *pt;
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c00203ba:	83 ec 0c             	sub    $0xc,%esp
c00203bd:	6a 03                	push   $0x3
c00203bf:	e8 5b 2d 00 00       	call   c002311f <palloc_get_page>
c00203c4:	83 c4 10             	add    $0x10,%esp
c00203c7:	a3 a0 38 03 c0       	mov    %eax,0xc00338a0
c00203cc:	a1 a0 38 03 c0       	mov    0xc00338a0,%eax
c00203d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  pt = NULL;
c00203d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for (page = 0; page < init_ram_pages; page++)
c00203db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00203e2:	e9 df 00 00 00       	jmp    c00204c6 <paging_init+0x113>
    {
      uintptr_t paddr = page * PGSIZE;
c00203e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00203ea:	c1 e0 0c             	shl    $0xc,%eax
c00203ed:	89 45 e8             	mov    %eax,-0x18(%ebp)
      char *vaddr = ptov (paddr);
c00203f0:	83 ec 0c             	sub    $0xc,%esp
c00203f3:	ff 75 e8             	push   -0x18(%ebp)
c00203f6:	e8 a3 fd ff ff       	call   c002019e <ptov>
c00203fb:	83 c4 10             	add    $0x10,%esp
c00203fe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      size_t pde_idx = pd_no (vaddr);
c0020401:	83 ec 0c             	sub    $0xc,%esp
c0020404:	ff 75 e4             	push   -0x1c(%ebp)
c0020407:	e8 17 fe ff ff       	call   c0020223 <pd_no>
c002040c:	83 c4 10             	add    $0x10,%esp
c002040f:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t pte_idx = pt_no (vaddr);
c0020412:	83 ec 0c             	sub    $0xc,%esp
c0020415:	ff 75 e4             	push   -0x1c(%ebp)
c0020418:	e8 f6 fd ff ff       	call   c0020213 <pt_no>
c002041d:	83 c4 10             	add    $0x10,%esp
c0020420:	89 45 dc             	mov    %eax,-0x24(%ebp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020423:	81 7d e4 00 00 02 c0 	cmpl   $0xc0020000,-0x1c(%ebp)
c002042a:	72 10                	jb     c002043c <paging_init+0x89>
c002042c:	81 7d e4 00 30 03 c0 	cmpl   $0xc0033000,-0x1c(%ebp)
c0020433:	73 07                	jae    c002043c <paging_init+0x89>
c0020435:	b8 01 00 00 00       	mov    $0x1,%eax
c002043a:	eb 05                	jmp    c0020441 <paging_init+0x8e>
c002043c:	b8 00 00 00 00       	mov    $0x0,%eax
c0020441:	88 45 db             	mov    %al,-0x25(%ebp)
c0020444:	80 65 db 01          	andb   $0x1,-0x25(%ebp)

      if (pd[pde_idx] == 0)
c0020448:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002044b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0020452:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020455:	01 d0                	add    %edx,%eax
c0020457:	8b 00                	mov    (%eax),%eax
c0020459:	85 c0                	test   %eax,%eax
c002045b:	75 30                	jne    c002048d <paging_init+0xda>
        {
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c002045d:	83 ec 0c             	sub    $0xc,%esp
c0020460:	6a 03                	push   $0x3
c0020462:	e8 b8 2c 00 00       	call   c002311f <palloc_get_page>
c0020467:	83 c4 10             	add    $0x10,%esp
c002046a:	89 45 f4             	mov    %eax,-0xc(%ebp)
          pd[pde_idx] = pde_create (pt);
c002046d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020470:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0020477:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002047a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c002047d:	83 ec 0c             	sub    $0xc,%esp
c0020480:	ff 75 f4             	push   -0xc(%ebp)
c0020483:	e8 a6 fd ff ff       	call   c002022e <pde_create>
c0020488:	83 c4 10             	add    $0x10,%esp
c002048b:	89 03                	mov    %eax,(%ebx)
        }

      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c002048d:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
c0020491:	85 c0                	test   %eax,%eax
c0020493:	0f 95 c0             	setne  %al
c0020496:	83 f0 01             	xor    $0x1,%eax
c0020499:	0f b6 c0             	movzbl %al,%eax
c002049c:	83 e0 01             	and    $0x1,%eax
c002049f:	0f b6 c0             	movzbl %al,%eax
c00204a2:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00204a5:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c00204ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00204af:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
c00204b2:	83 ec 08             	sub    $0x8,%esp
c00204b5:	50                   	push   %eax
c00204b6:	ff 75 e4             	push   -0x1c(%ebp)
c00204b9:	e8 b6 fd ff ff       	call   c0020274 <pte_create_kernel>
c00204be:	83 c4 10             	add    $0x10,%esp
c00204c1:	89 03                	mov    %eax,(%ebx)
  for (page = 0; page < init_ram_pages; page++)
c00204c3:	ff 45 f0             	incl   -0x10(%ebp)
c00204c6:	a1 7e 01 02 c0       	mov    0xc002017e,%eax
c00204cb:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00204ce:	0f 82 13 ff ff ff    	jb     c00203e7 <paging_init+0x34>
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
     of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c00204d4:	a1 a0 38 03 c0       	mov    0xc00338a0,%eax
c00204d9:	83 ec 0c             	sub    $0xc,%esp
c00204dc:	50                   	push   %eax
c00204dd:	e8 f4 fc ff ff       	call   c00201d6 <vtop>
c00204e2:	83 c4 10             	add    $0x10,%esp
c00204e5:	0f 22 d8             	mov    %eax,%cr3
}
c00204e8:	90                   	nop
c00204e9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00204ec:	c9                   	leave  
c00204ed:	c3                   	ret    

c00204ee <read_command_line>:

/* Breaks the kernel command line into words and returns them as
   an argv-like array. */
static char **
read_command_line (void) 
{
c00204ee:	55                   	push   %ebp
c00204ef:	89 e5                	mov    %esp,%ebp
c00204f1:	83 ec 18             	sub    $0x18,%esp
  static char *argv[LOADER_ARGS_LEN / 2 + 1];
  char *p, *end;
  int argc;
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c00204f4:	83 ec 0c             	sub    $0xc,%esp
c00204f7:	68 3a 7d 00 00       	push   $0x7d3a
c00204fc:	e8 9d fc ff ff       	call   c002019e <ptov>
c0020501:	83 c4 10             	add    $0x10,%esp
c0020504:	8b 00                	mov    (%eax),%eax
c0020506:	89 45 ec             	mov    %eax,-0x14(%ebp)
  p = ptov (LOADER_ARGS);
c0020509:	83 ec 0c             	sub    $0xc,%esp
c002050c:	68 3e 7d 00 00       	push   $0x7d3e
c0020511:	e8 88 fc ff ff       	call   c002019e <ptov>
c0020516:	83 c4 10             	add    $0x10,%esp
c0020519:	89 45 f4             	mov    %eax,-0xc(%ebp)
  end = p + LOADER_ARGS_LEN;
c002051c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002051f:	83 e8 80             	sub    $0xffffff80,%eax
c0020522:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for (i = 0; i < argc; i++) 
c0020525:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002052c:	eb 4a                	jmp    c0020578 <read_command_line+0x8a>
    {
      if (p >= end)
c002052e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020531:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0020534:	72 19                	jb     c002054f <read_command_line+0x61>
        PANIC ("command line arguments overflow");
c0020536:	68 ec e4 02 c0       	push   $0xc002e4ec
c002053b:	68 f8 e7 02 c0       	push   $0xc002e7f8
c0020540:	68 d3 00 00 00       	push   $0xd3
c0020545:	68 0c e5 02 c0       	push   $0xc002e50c
c002054a:	e8 cf 8f 00 00       	call   c002951e <debug_panic>

      argv[i] = p;
c002054f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020552:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0020555:	89 14 85 c0 38 03 c0 	mov    %edx,-0x3ffcc740(,%eax,4)
      p += strnlen (p, end - p) + 1;
c002055c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002055f:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0020562:	83 ec 08             	sub    $0x8,%esp
c0020565:	50                   	push   %eax
c0020566:	ff 75 f4             	push   -0xc(%ebp)
c0020569:	e8 7e 84 00 00       	call   c00289ec <strnlen>
c002056e:	83 c4 10             	add    $0x10,%esp
c0020571:	40                   	inc    %eax
c0020572:	01 45 f4             	add    %eax,-0xc(%ebp)
  for (i = 0; i < argc; i++) 
c0020575:	ff 45 f0             	incl   -0x10(%ebp)
c0020578:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002057b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002057e:	7c ae                	jl     c002052e <read_command_line+0x40>
    }
  argv[argc] = NULL;
c0020580:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020583:	c7 04 85 c0 38 03 c0 	movl   $0x0,-0x3ffcc740(,%eax,4)
c002058a:	00 00 00 00 

  /* Print kernel command line. */
  printf ("Kernel command line:");
c002058e:	83 ec 0c             	sub    $0xc,%esp
c0020591:	68 21 e5 02 c0       	push   $0xc002e521
c0020596:	e8 e1 6b 00 00       	call   c002717c <printf>
c002059b:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c002059e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00205a5:	eb 57                	jmp    c00205fe <read_command_line+0x110>
    if (strchr (argv[i], ' ') == NULL)
c00205a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205aa:	8b 04 85 c0 38 03 c0 	mov    -0x3ffcc740(,%eax,4),%eax
c00205b1:	83 ec 08             	sub    $0x8,%esp
c00205b4:	6a 20                	push   $0x20
c00205b6:	50                   	push   %eax
c00205b7:	e8 b3 80 00 00       	call   c002866f <strchr>
c00205bc:	83 c4 10             	add    $0x10,%esp
c00205bf:	85 c0                	test   %eax,%eax
c00205c1:	75 1d                	jne    c00205e0 <read_command_line+0xf2>
      printf (" %s", argv[i]);
c00205c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205c6:	8b 04 85 c0 38 03 c0 	mov    -0x3ffcc740(,%eax,4),%eax
c00205cd:	83 ec 08             	sub    $0x8,%esp
c00205d0:	50                   	push   %eax
c00205d1:	68 36 e5 02 c0       	push   $0xc002e536
c00205d6:	e8 a1 6b 00 00       	call   c002717c <printf>
c00205db:	83 c4 10             	add    $0x10,%esp
c00205de:	eb 1b                	jmp    c00205fb <read_command_line+0x10d>
    else
      printf (" '%s'", argv[i]);
c00205e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205e3:	8b 04 85 c0 38 03 c0 	mov    -0x3ffcc740(,%eax,4),%eax
c00205ea:	83 ec 08             	sub    $0x8,%esp
c00205ed:	50                   	push   %eax
c00205ee:	68 3a e5 02 c0       	push   $0xc002e53a
c00205f3:	e8 84 6b 00 00       	call   c002717c <printf>
c00205f8:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c00205fb:	ff 45 f0             	incl   -0x10(%ebp)
c00205fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020601:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0020604:	7c a1                	jl     c00205a7 <read_command_line+0xb9>
  printf ("\n");
c0020606:	83 ec 0c             	sub    $0xc,%esp
c0020609:	6a 0a                	push   $0xa
c002060b:	e8 58 b1 00 00       	call   c002b768 <putchar>
c0020610:	83 c4 10             	add    $0x10,%esp

  return argv;
c0020613:	b8 c0 38 03 c0       	mov    $0xc00338c0,%eax
}
c0020618:	c9                   	leave  
c0020619:	c3                   	ret    

c002061a <parse_options>:

/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
c002061a:	55                   	push   %ebp
c002061b:	89 e5                	mov    %esp,%ebp
c002061d:	83 ec 18             	sub    $0x18,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c0020620:	e9 1c 01 00 00       	jmp    c0020741 <parse_options+0x127>
    {
      char *save_ptr;
      char *name = strtok_r (*argv, "=", &save_ptr);
c0020625:	8b 45 08             	mov    0x8(%ebp),%eax
c0020628:	8b 00                	mov    (%eax),%eax
c002062a:	83 ec 04             	sub    $0x4,%esp
c002062d:	8d 55 ec             	lea    -0x14(%ebp),%edx
c0020630:	52                   	push   %edx
c0020631:	68 40 e5 02 c0       	push   $0xc002e540
c0020636:	50                   	push   %eax
c0020637:	e8 00 82 00 00       	call   c002883c <strtok_r>
c002063c:	83 c4 10             	add    $0x10,%esp
c002063f:	89 45 f4             	mov    %eax,-0xc(%ebp)
      char *value = strtok_r (NULL, "", &save_ptr);
c0020642:	83 ec 04             	sub    $0x4,%esp
c0020645:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0020648:	50                   	push   %eax
c0020649:	68 42 e5 02 c0       	push   $0xc002e542
c002064e:	6a 00                	push   $0x0
c0020650:	e8 e7 81 00 00       	call   c002883c <strtok_r>
c0020655:	83 c4 10             	add    $0x10,%esp
c0020658:	89 45 f0             	mov    %eax,-0x10(%ebp)
      
      if (!strcmp (name, "-h"))
c002065b:	83 ec 08             	sub    $0x8,%esp
c002065e:	68 43 e5 02 c0       	push   $0xc002e543
c0020663:	ff 75 f4             	push   -0xc(%ebp)
c0020666:	e8 02 7f 00 00       	call   c002856d <strcmp>
c002066b:	83 c4 10             	add    $0x10,%esp
c002066e:	85 c0                	test   %eax,%eax
c0020670:	75 0a                	jne    c002067c <parse_options+0x62>
        usage ();
c0020672:	e8 23 02 00 00       	call   c002089a <usage>
c0020677:	e9 c1 00 00 00       	jmp    c002073d <parse_options+0x123>
      else if (!strcmp (name, "-q"))
c002067c:	83 ec 08             	sub    $0x8,%esp
c002067f:	68 46 e5 02 c0       	push   $0xc002e546
c0020684:	ff 75 f4             	push   -0xc(%ebp)
c0020687:	e8 e1 7e 00 00       	call   c002856d <strcmp>
c002068c:	83 c4 10             	add    $0x10,%esp
c002068f:	85 c0                	test   %eax,%eax
c0020691:	75 12                	jne    c00206a5 <parse_options+0x8b>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c0020693:	83 ec 0c             	sub    $0xc,%esp
c0020696:	6a 01                	push   $0x1
c0020698:	e8 61 65 00 00       	call   c0026bfe <shutdown_configure>
c002069d:	83 c4 10             	add    $0x10,%esp
c00206a0:	e9 98 00 00 00       	jmp    c002073d <parse_options+0x123>
      else if (!strcmp (name, "-r"))
c00206a5:	83 ec 08             	sub    $0x8,%esp
c00206a8:	68 49 e5 02 c0       	push   $0xc002e549
c00206ad:	ff 75 f4             	push   -0xc(%ebp)
c00206b0:	e8 b8 7e 00 00       	call   c002856d <strcmp>
c00206b5:	83 c4 10             	add    $0x10,%esp
c00206b8:	85 c0                	test   %eax,%eax
c00206ba:	75 0f                	jne    c00206cb <parse_options+0xb1>
        shutdown_configure (SHUTDOWN_REBOOT);
c00206bc:	83 ec 0c             	sub    $0xc,%esp
c00206bf:	6a 02                	push   $0x2
c00206c1:	e8 38 65 00 00       	call   c0026bfe <shutdown_configure>
c00206c6:	83 c4 10             	add    $0x10,%esp
c00206c9:	eb 72                	jmp    c002073d <parse_options+0x123>
#ifdef VM
      else if (!strcmp (name, "-swap"))
        swap_bdev_name = value;
#endif
#endif
      else if (!strcmp (name, "-rs"))
c00206cb:	83 ec 08             	sub    $0x8,%esp
c00206ce:	68 4c e5 02 c0       	push   $0xc002e54c
c00206d3:	ff 75 f4             	push   -0xc(%ebp)
c00206d6:	e8 92 7e 00 00       	call   c002856d <strcmp>
c00206db:	83 c4 10             	add    $0x10,%esp
c00206de:	85 c0                	test   %eax,%eax
c00206e0:	75 1c                	jne    c00206fe <parse_options+0xe4>
        random_init (atoi (value));
c00206e2:	83 ec 0c             	sub    $0xc,%esp
c00206e5:	ff 75 f0             	push   -0x10(%ebp)
c00206e8:	e8 85 78 00 00       	call   c0027f72 <atoi>
c00206ed:	83 c4 10             	add    $0x10,%esp
c00206f0:	83 ec 0c             	sub    $0xc,%esp
c00206f3:	50                   	push   %eax
c00206f4:	e8 24 68 00 00       	call   c0026f1d <random_init>
c00206f9:	83 c4 10             	add    $0x10,%esp
c00206fc:	eb 3f                	jmp    c002073d <parse_options+0x123>
      else if (!strcmp (name, "-mlfqs"))
c00206fe:	83 ec 08             	sub    $0x8,%esp
c0020701:	68 50 e5 02 c0       	push   $0xc002e550
c0020706:	ff 75 f4             	push   -0xc(%ebp)
c0020709:	e8 5f 7e 00 00       	call   c002856d <strcmp>
c002070e:	83 c4 10             	add    $0x10,%esp
c0020711:	85 c0                	test   %eax,%eax
c0020713:	75 09                	jne    c002071e <parse_options+0x104>
        thread_mlfqs = true;
c0020715:	c6 05 c8 39 03 c0 01 	movb   $0x1,0xc00339c8
c002071c:	eb 1f                	jmp    c002073d <parse_options+0x123>
#ifdef USERPROG
      else if (!strcmp (name, "-ul"))
        user_page_limit = atoi (value);
#endif
      else
        PANIC ("unknown option `%s' (use -h for help)", name);
c002071e:	83 ec 0c             	sub    $0xc,%esp
c0020721:	ff 75 f4             	push   -0xc(%ebp)
c0020724:	68 58 e5 02 c0       	push   $0xc002e558
c0020729:	68 0c e8 02 c0       	push   $0xc002e80c
c002072e:	68 0c 01 00 00       	push   $0x10c
c0020733:	68 0c e5 02 c0       	push   $0xc002e50c
c0020738:	e8 e1 8d 00 00       	call   c002951e <debug_panic>
  for (; *argv != NULL && **argv == '-'; argv++)
c002073d:	83 45 08 04          	addl   $0x4,0x8(%ebp)
c0020741:	8b 45 08             	mov    0x8(%ebp),%eax
c0020744:	8b 00                	mov    (%eax),%eax
c0020746:	85 c0                	test   %eax,%eax
c0020748:	74 0f                	je     c0020759 <parse_options+0x13f>
c002074a:	8b 45 08             	mov    0x8(%ebp),%eax
c002074d:	8b 00                	mov    (%eax),%eax
c002074f:	8a 00                	mov    (%eax),%al
c0020751:	3c 2d                	cmp    $0x2d,%al
c0020753:	0f 84 cc fe ff ff    	je     c0020625 <parse_options+0xb>
     When running under Bochs, this is not enough by itself to
     get a good seed value, because the pintos script sets the
     initial time to a predictable value, not to the local time,
     for reproducibility.  To fix this, give the "-r" option to
     the pintos script to request real-time execution. */
  random_init (rtc_get_time ());
c0020759:	e8 eb 61 00 00       	call   c0026949 <rtc_get_time>
c002075e:	83 ec 0c             	sub    $0xc,%esp
c0020761:	50                   	push   %eax
c0020762:	e8 b6 67 00 00       	call   c0026f1d <random_init>
c0020767:	83 c4 10             	add    $0x10,%esp
  
  return argv;
c002076a:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002076d:	c9                   	leave  
c002076e:	c3                   	ret    

c002076f <run_task>:

/* Runs the task specified in ARGV[1]. */
static void
run_task (char **argv)
{
c002076f:	55                   	push   %ebp
c0020770:	89 e5                	mov    %esp,%ebp
c0020772:	83 ec 18             	sub    $0x18,%esp
  const char *task = argv[1];
c0020775:	8b 45 08             	mov    0x8(%ebp),%eax
c0020778:	8b 40 04             	mov    0x4(%eax),%eax
c002077b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  printf ("Executing '%s':\n", task);
c002077e:	83 ec 08             	sub    $0x8,%esp
c0020781:	ff 75 f4             	push   -0xc(%ebp)
c0020784:	68 7e e5 02 c0       	push   $0xc002e57e
c0020789:	e8 ee 69 00 00       	call   c002717c <printf>
c002078e:	83 c4 10             	add    $0x10,%esp
#ifdef USERPROG
  process_wait (process_execute (task));
#else
  run_test (task);
c0020791:	83 ec 0c             	sub    $0xc,%esp
c0020794:	ff 75 f4             	push   -0xc(%ebp)
c0020797:	e8 9c b0 00 00       	call   c002b838 <run_test>
c002079c:	83 c4 10             	add    $0x10,%esp
#endif
  printf ("Execution of '%s' complete.\n", task);
c002079f:	83 ec 08             	sub    $0x8,%esp
c00207a2:	ff 75 f4             	push   -0xc(%ebp)
c00207a5:	68 8f e5 02 c0       	push   $0xc002e58f
c00207aa:	e8 cd 69 00 00       	call   c002717c <printf>
c00207af:	83 c4 10             	add    $0x10,%esp
}
c00207b2:	90                   	nop
c00207b3:	c9                   	leave  
c00207b4:	c3                   	ret    

c00207b5 <run_actions>:

/* Executes all of the actions specified in ARGV[]
   up to the null pointer sentinel. */
static void
run_actions (char **argv) 
{
c00207b5:	55                   	push   %ebp
c00207b6:	89 e5                	mov    %esp,%ebp
c00207b8:	83 ec 18             	sub    $0x18,%esp
      {"append", 2, fsutil_append},
#endif
      {NULL, 0, NULL},
    };

  while (*argv != NULL)
c00207bb:	e9 c9 00 00 00       	jmp    c0020889 <run_actions+0xd4>
    {
      const struct action *a;
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
c00207c0:	c7 45 f4 20 e8 02 c0 	movl   $0xc002e820,-0xc(%ebp)
        if (a->name == NULL)
c00207c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00207ca:	8b 00                	mov    (%eax),%eax
c00207cc:	85 c0                	test   %eax,%eax
c00207ce:	75 22                	jne    c00207f2 <run_actions+0x3d>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c00207d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00207d3:	8b 00                	mov    (%eax),%eax
c00207d5:	83 ec 0c             	sub    $0xc,%esp
c00207d8:	50                   	push   %eax
c00207d9:	68 ac e5 02 c0       	push   $0xc002e5ac
c00207de:	68 38 e8 02 c0       	push   $0xc002e838
c00207e3:	68 4e 01 00 00       	push   $0x14e
c00207e8:	68 0c e5 02 c0       	push   $0xc002e50c
c00207ed:	e8 2c 8d 00 00       	call   c002951e <debug_panic>
        else if (!strcmp (*argv, a->name))
c00207f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00207f5:	8b 10                	mov    (%eax),%edx
c00207f7:	8b 45 08             	mov    0x8(%ebp),%eax
c00207fa:	8b 00                	mov    (%eax),%eax
c00207fc:	83 ec 08             	sub    $0x8,%esp
c00207ff:	52                   	push   %edx
c0020800:	50                   	push   %eax
c0020801:	e8 67 7d 00 00       	call   c002856d <strcmp>
c0020806:	83 c4 10             	add    $0x10,%esp
c0020809:	85 c0                	test   %eax,%eax
c002080b:	74 06                	je     c0020813 <run_actions+0x5e>
      for (a = actions; ; a++)
c002080d:	83 45 f4 0c          	addl   $0xc,-0xc(%ebp)
        if (a->name == NULL)
c0020811:	eb b4                	jmp    c00207c7 <run_actions+0x12>
          break;
c0020813:	90                   	nop

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c0020814:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c002081b:	eb 44                	jmp    c0020861 <run_actions+0xac>
        if (argv[i] == NULL)
c002081d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020820:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0020827:	8b 45 08             	mov    0x8(%ebp),%eax
c002082a:	01 d0                	add    %edx,%eax
c002082c:	8b 00                	mov    (%eax),%eax
c002082e:	85 c0                	test   %eax,%eax
c0020830:	75 2c                	jne    c002085e <run_actions+0xa9>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c0020832:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020835:	8b 40 04             	mov    0x4(%eax),%eax
c0020838:	8d 50 ff             	lea    -0x1(%eax),%edx
c002083b:	8b 45 08             	mov    0x8(%ebp),%eax
c002083e:	8b 00                	mov    (%eax),%eax
c0020840:	83 ec 08             	sub    $0x8,%esp
c0020843:	52                   	push   %edx
c0020844:	50                   	push   %eax
c0020845:	68 d4 e5 02 c0       	push   $0xc002e5d4
c002084a:	68 38 e8 02 c0       	push   $0xc002e838
c002084f:	68 55 01 00 00       	push   $0x155
c0020854:	68 0c e5 02 c0       	push   $0xc002e50c
c0020859:	e8 c0 8c 00 00       	call   c002951e <debug_panic>
      for (i = 1; i < a->argc; i++)
c002085e:	ff 45 f0             	incl   -0x10(%ebp)
c0020861:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020864:	8b 40 04             	mov    0x4(%eax),%eax
c0020867:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002086a:	7c b1                	jl     c002081d <run_actions+0x68>

      /* Invoke action and advance. */
      a->function (argv);
c002086c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002086f:	8b 40 08             	mov    0x8(%eax),%eax
c0020872:	83 ec 0c             	sub    $0xc,%esp
c0020875:	ff 75 08             	push   0x8(%ebp)
c0020878:	ff d0                	call   *%eax
c002087a:	83 c4 10             	add    $0x10,%esp
      argv += a->argc;
c002087d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020880:	8b 40 04             	mov    0x4(%eax),%eax
c0020883:	c1 e0 02             	shl    $0x2,%eax
c0020886:	01 45 08             	add    %eax,0x8(%ebp)
  while (*argv != NULL)
c0020889:	8b 45 08             	mov    0x8(%ebp),%eax
c002088c:	8b 00                	mov    (%eax),%eax
c002088e:	85 c0                	test   %eax,%eax
c0020890:	0f 85 2a ff ff ff    	jne    c00207c0 <run_actions+0xb>
    }
  
}
c0020896:	90                   	nop
c0020897:	90                   	nop
c0020898:	c9                   	leave  
c0020899:	c3                   	ret    

c002089a <usage>:

/* Prints a kernel command line help message and powers off the
   machine. */
static void
usage (void)
{
c002089a:	55                   	push   %ebp
c002089b:	89 e5                	mov    %esp,%ebp
c002089d:	83 ec 08             	sub    $0x8,%esp
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c00208a0:	83 ec 0c             	sub    $0xc,%esp
c00208a3:	68 f8 e5 02 c0       	push   $0xc002e5f8
c00208a8:	e8 36 ae 00 00       	call   c002b6e3 <puts>
c00208ad:	83 c4 10             	add    $0x10,%esp
          "  -mlfqs             Use multi-level feedback queue scheduler.\n"
#ifdef USERPROG
          "  -ul=COUNT          Limit user memory to COUNT pages.\n"
#endif
          );
  shutdown_power_off ();
c00208b0:	e8 dd 63 00 00       	call   c0026c92 <shutdown_power_off>

c00208b5 <pg_round_down>:
static inline void *pg_round_down (const void *va) {
c00208b5:	55                   	push   %ebp
c00208b6:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c00208b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00208bb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c00208c0:	5d                   	pop    %ebp
c00208c1:	c3                   	ret    

c00208c2 <thread_init>:

   It is not safe to call thread_current() until this function
   finishes. */
void
thread_init (void) 
{
c00208c2:	55                   	push   %ebp
c00208c3:	89 e5                	mov    %esp,%ebp
c00208c5:	53                   	push   %ebx
c00208c6:	83 ec 04             	sub    $0x4,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00208c9:	e8 61 0a 00 00       	call   c002132f <intr_get_level>
c00208ce:	85 c0                	test   %eax,%eax
c00208d0:	74 1e                	je     c00208f0 <thread_init+0x2e>
c00208d2:	83 ec 0c             	sub    $0xc,%esp
c00208d5:	68 44 e8 02 c0       	push   $0xc002e844
c00208da:	68 62 e8 02 c0       	push   $0xc002e862
c00208df:	68 04 ea 02 c0       	push   $0xc002ea04
c00208e4:	6a 5a                	push   $0x5a
c00208e6:	68 79 e8 02 c0       	push   $0xc002e879
c00208eb:	e8 2e 8c 00 00       	call   c002951e <debug_panic>

  lock_init (&tid_lock);
c00208f0:	83 ec 0c             	sub    $0xc,%esp
c00208f3:	68 f4 39 03 c0       	push   $0xc00339f4
c00208f8:	e8 58 21 00 00       	call   c0022a55 <lock_init>
c00208fd:	83 c4 10             	add    $0x10,%esp
  list_init (&ready_list);
c0020900:	83 ec 0c             	sub    $0xc,%esp
c0020903:	68 cc 39 03 c0       	push   $0xc00339cc
c0020908:	e8 88 8e 00 00       	call   c0029795 <list_init>
c002090d:	83 c4 10             	add    $0x10,%esp
  list_init (&all_list);
c0020910:	83 ec 0c             	sub    $0xc,%esp
c0020913:	68 dc 39 03 c0       	push   $0xc00339dc
c0020918:	e8 78 8e 00 00       	call   c0029795 <list_init>
c002091d:	83 c4 10             	add    $0x10,%esp

  /* Set up a thread structure for the running thread. */
  initial_thread = running_thread ();
c0020920:	e8 18 06 00 00       	call   c0020f3d <running_thread>
c0020925:	a3 f0 39 03 c0       	mov    %eax,0xc00339f0
  init_thread (initial_thread, "main", PRI_DEFAULT);
c002092a:	a1 f0 39 03 c0       	mov    0xc00339f0,%eax
c002092f:	83 ec 04             	sub    $0x4,%esp
c0020932:	6a 1f                	push   $0x1f
c0020934:	68 90 e8 02 c0       	push   $0xc002e890
c0020939:	50                   	push   %eax
c002093a:	e8 3d 06 00 00       	call   c0020f7c <init_thread>
c002093f:	83 c4 10             	add    $0x10,%esp
  initial_thread->status = THREAD_RUNNING;
c0020942:	a1 f0 39 03 c0       	mov    0xc00339f0,%eax
c0020947:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  initial_thread->tid = allocate_tid ();
c002094e:	8b 1d f0 39 03 c0    	mov    0xc00339f0,%ebx
c0020954:	e8 51 09 00 00       	call   c00212aa <allocate_tid>
c0020959:	89 03                	mov    %eax,(%ebx)
}
c002095b:	90                   	nop
c002095c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002095f:	c9                   	leave  
c0020960:	c3                   	ret    

c0020961 <thread_start>:

/* Starts preemptive thread scheduling by enabling interrupts.
   Also creates the idle thread. */
void
thread_start (void) 
{
c0020961:	55                   	push   %ebp
c0020962:	89 e5                	mov    %esp,%ebp
c0020964:	83 ec 28             	sub    $0x28,%esp
  /* Create the idle thread. */
  struct semaphore idle_started;
  sema_init (&idle_started, 0);
c0020967:	83 ec 08             	sub    $0x8,%esp
c002096a:	6a 00                	push   $0x0
c002096c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002096f:	50                   	push   %eax
c0020970:	e8 27 1e 00 00       	call   c002279c <sema_init>
c0020975:	83 c4 10             	add    $0x10,%esp
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c0020978:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002097b:	50                   	push   %eax
c002097c:	68 c6 0e 02 c0       	push   $0xc0020ec6
c0020981:	6a 00                	push   $0x0
c0020983:	68 95 e8 02 c0       	push   $0xc002e895
c0020988:	e8 d4 00 00 00       	call   c0020a61 <thread_create>
c002098d:	83 c4 10             	add    $0x10,%esp

  /* Start preemptive thread scheduling. */
  intr_enable ();
c0020990:	e8 ca 09 00 00       	call   c002135f <intr_enable>

  /* Wait for the idle thread to initialize idle_thread. */
  sema_down (&idle_started);
c0020995:	83 ec 0c             	sub    $0xc,%esp
c0020998:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002099b:	50                   	push   %eax
c002099c:	e8 42 1e 00 00       	call   c00227e3 <sema_down>
c00209a1:	83 c4 10             	add    $0x10,%esp
}
c00209a4:	90                   	nop
c00209a5:	c9                   	leave  
c00209a6:	c3                   	ret    

c00209a7 <thread_tick>:

/* Called by the timer interrupt handler at each timer tick.
   Thus, this function runs in an external interrupt context. */
void
thread_tick (void) 
{
c00209a7:	55                   	push   %ebp
c00209a8:	89 e5                	mov    %esp,%ebp
c00209aa:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = thread_current ();
c00209ad:	e8 c6 02 00 00       	call   c0020c78 <thread_current>
c00209b2:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Update statistics. */
  if (t == idle_thread)
c00209b5:	a1 ec 39 03 c0       	mov    0xc00339ec,%eax
c00209ba:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00209bd:	75 1e                	jne    c00209dd <thread_tick+0x36>
    idle_ticks++;
c00209bf:	a1 10 3a 03 c0       	mov    0xc0033a10,%eax
c00209c4:	8b 15 14 3a 03 c0    	mov    0xc0033a14,%edx
c00209ca:	83 c0 01             	add    $0x1,%eax
c00209cd:	83 d2 00             	adc    $0x0,%edx
c00209d0:	a3 10 3a 03 c0       	mov    %eax,0xc0033a10
c00209d5:	89 15 14 3a 03 c0    	mov    %edx,0xc0033a14
c00209db:	eb 1c                	jmp    c00209f9 <thread_tick+0x52>
#ifdef USERPROG
  else if (t->pagedir != NULL)
    user_ticks++;
#endif
  else
    kernel_ticks++;
c00209dd:	a1 18 3a 03 c0       	mov    0xc0033a18,%eax
c00209e2:	8b 15 1c 3a 03 c0    	mov    0xc0033a1c,%edx
c00209e8:	83 c0 01             	add    $0x1,%eax
c00209eb:	83 d2 00             	adc    $0x0,%edx
c00209ee:	a3 18 3a 03 c0       	mov    %eax,0xc0033a18
c00209f3:	89 15 1c 3a 03 c0    	mov    %edx,0xc0033a1c

  /* Enforce preemption. */
  if (++thread_ticks >= TIME_SLICE)
c00209f9:	a1 28 3a 03 c0       	mov    0xc0033a28,%eax
c00209fe:	40                   	inc    %eax
c00209ff:	a3 28 3a 03 c0       	mov    %eax,0xc0033a28
c0020a04:	a1 28 3a 03 c0       	mov    0xc0033a28,%eax
c0020a09:	83 f8 03             	cmp    $0x3,%eax
c0020a0c:	76 05                	jbe    c0020a13 <thread_tick+0x6c>
    intr_yield_on_return ();
c0020a0e:	e8 61 0c 00 00       	call   c0021674 <intr_yield_on_return>
}
c0020a13:	90                   	nop
c0020a14:	c9                   	leave  
c0020a15:	c3                   	ret    

c0020a16 <thread_print_stats>:

/* Prints thread statistics. */
void
thread_print_stats (void) 
{
c0020a16:	55                   	push   %ebp
c0020a17:	89 e5                	mov    %esp,%ebp
c0020a19:	57                   	push   %edi
c0020a1a:	56                   	push   %esi
c0020a1b:	53                   	push   %ebx
c0020a1c:	83 ec 0c             	sub    $0xc,%esp
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020a1f:	8b 35 20 3a 03 c0    	mov    0xc0033a20,%esi
c0020a25:	8b 3d 24 3a 03 c0    	mov    0xc0033a24,%edi
c0020a2b:	8b 0d 18 3a 03 c0    	mov    0xc0033a18,%ecx
c0020a31:	8b 1d 1c 3a 03 c0    	mov    0xc0033a1c,%ebx
c0020a37:	a1 10 3a 03 c0       	mov    0xc0033a10,%eax
c0020a3c:	8b 15 14 3a 03 c0    	mov    0xc0033a14,%edx
c0020a42:	83 ec 04             	sub    $0x4,%esp
c0020a45:	57                   	push   %edi
c0020a46:	56                   	push   %esi
c0020a47:	53                   	push   %ebx
c0020a48:	51                   	push   %ecx
c0020a49:	52                   	push   %edx
c0020a4a:	50                   	push   %eax
c0020a4b:	68 9c e8 02 c0       	push   $0xc002e89c
c0020a50:	e8 27 67 00 00       	call   c002717c <printf>
c0020a55:	83 c4 20             	add    $0x20,%esp
          idle_ticks, kernel_ticks, user_ticks);
}
c0020a58:	90                   	nop
c0020a59:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0020a5c:	5b                   	pop    %ebx
c0020a5d:	5e                   	pop    %esi
c0020a5e:	5f                   	pop    %edi
c0020a5f:	5d                   	pop    %ebp
c0020a60:	c3                   	ret    

c0020a61 <thread_create>:
   PRIORITY, but no actual priority scheduling is implemented.
   Priority scheduling is the goal of Problem 1-3. */
tid_t
thread_create (const char *name, int priority,
               thread_func *function, void *aux) 
{
c0020a61:	55                   	push   %ebp
c0020a62:	89 e5                	mov    %esp,%ebp
c0020a64:	83 ec 28             	sub    $0x28,%esp
  struct kernel_thread_frame *kf;
  struct switch_entry_frame *ef;
  struct switch_threads_frame *sf;
  tid_t tid;

  ASSERT (function != NULL);
c0020a67:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0020a6b:	75 21                	jne    c0020a8e <thread_create+0x2d>
c0020a6d:	83 ec 0c             	sub    $0xc,%esp
c0020a70:	68 d9 e8 02 c0       	push   $0xc002e8d9
c0020a75:	68 62 e8 02 c0       	push   $0xc002e862
c0020a7a:	68 10 ea 02 c0       	push   $0xc002ea10
c0020a7f:	68 af 00 00 00       	push   $0xaf
c0020a84:	68 79 e8 02 c0       	push   $0xc002e879
c0020a89:	e8 90 8a 00 00       	call   c002951e <debug_panic>

  /* Allocate thread. */
  t = palloc_get_page (PAL_ZERO);
c0020a8e:	83 ec 0c             	sub    $0xc,%esp
c0020a91:	6a 02                	push   $0x2
c0020a93:	e8 87 26 00 00       	call   c002311f <palloc_get_page>
c0020a98:	83 c4 10             	add    $0x10,%esp
c0020a9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (t == NULL)
c0020a9e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0020aa2:	75 0a                	jne    c0020aae <thread_create+0x4d>
    return TID_ERROR;
c0020aa4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0020aa9:	e9 a8 00 00 00       	jmp    c0020b56 <thread_create+0xf5>

  /* Initialize thread. */
  init_thread (t, name, priority);
c0020aae:	83 ec 04             	sub    $0x4,%esp
c0020ab1:	ff 75 0c             	push   0xc(%ebp)
c0020ab4:	ff 75 08             	push   0x8(%ebp)
c0020ab7:	ff 75 f4             	push   -0xc(%ebp)
c0020aba:	e8 bd 04 00 00       	call   c0020f7c <init_thread>
c0020abf:	83 c4 10             	add    $0x10,%esp
  tid = t->tid = allocate_tid ();
c0020ac2:	e8 e3 07 00 00       	call   c00212aa <allocate_tid>
c0020ac7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0020aca:	89 02                	mov    %eax,(%edx)
c0020acc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020acf:	8b 00                	mov    (%eax),%eax
c0020ad1:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /* Stack frame for kernel_thread(). */
  kf = alloc_frame (t, sizeof *kf);
c0020ad4:	83 ec 08             	sub    $0x8,%esp
c0020ad7:	6a 0c                	push   $0xc
c0020ad9:	ff 75 f4             	push   -0xc(%ebp)
c0020adc:	e8 a1 05 00 00       	call   c0021082 <alloc_frame>
c0020ae1:	83 c4 10             	add    $0x10,%esp
c0020ae4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  kf->eip = NULL;
c0020ae7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020aea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c0020af0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020af3:	8b 55 10             	mov    0x10(%ebp),%edx
c0020af6:	89 50 04             	mov    %edx,0x4(%eax)
  kf->aux = aux;
c0020af9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020afc:	8b 55 14             	mov    0x14(%ebp),%edx
c0020aff:	89 50 08             	mov    %edx,0x8(%eax)

  /* Stack frame for switch_entry(). */
  ef = alloc_frame (t, sizeof *ef);
c0020b02:	83 ec 08             	sub    $0x8,%esp
c0020b05:	6a 04                	push   $0x4
c0020b07:	ff 75 f4             	push   -0xc(%ebp)
c0020b0a:	e8 73 05 00 00       	call   c0021082 <alloc_frame>
c0020b0f:	83 c4 10             	add    $0x10,%esp
c0020b12:	89 45 e8             	mov    %eax,-0x18(%ebp)
  ef->eip = (void (*) (void)) kernel_thread;
c0020b15:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0020b18:	c7 00 f8 0e 02 c0    	movl   $0xc0020ef8,(%eax)

  /* Stack frame for switch_threads(). */
  sf = alloc_frame (t, sizeof *sf);
c0020b1e:	83 ec 08             	sub    $0x8,%esp
c0020b21:	6a 1c                	push   $0x1c
c0020b23:	ff 75 f4             	push   -0xc(%ebp)
c0020b26:	e8 57 05 00 00       	call   c0021082 <alloc_frame>
c0020b2b:	83 c4 10             	add    $0x10,%esp
c0020b2e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  sf->eip = switch_entry;
c0020b31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020b34:	c7 40 10 03 13 02 c0 	movl   $0xc0021303,0x10(%eax)
  sf->ebp = 0;
c0020b3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020b3e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  /* Add to run queue. */
  thread_unblock (t);
c0020b45:	83 ec 0c             	sub    $0xc,%esp
c0020b48:	ff 75 f4             	push   -0xc(%ebp)
c0020b4b:	e8 79 00 00 00       	call   c0020bc9 <thread_unblock>
c0020b50:	83 c4 10             	add    $0x10,%esp

  return tid;
c0020b53:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0020b56:	c9                   	leave  
c0020b57:	c3                   	ret    

c0020b58 <thread_block>:
   This function must be called with interrupts turned off.  It
   is usually a better idea to use one of the synchronization
   primitives in synch.h. */
void
thread_block (void) 
{
c0020b58:	55                   	push   %ebp
c0020b59:	89 e5                	mov    %esp,%ebp
c0020b5b:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020b5e:	e8 07 0b 00 00       	call   c002166a <intr_context>
c0020b63:	83 f0 01             	xor    $0x1,%eax
c0020b66:	84 c0                	test   %al,%al
c0020b68:	75 21                	jne    c0020b8b <thread_block+0x33>
c0020b6a:	83 ec 0c             	sub    $0xc,%esp
c0020b6d:	68 ea e8 02 c0       	push   $0xc002e8ea
c0020b72:	68 62 e8 02 c0       	push   $0xc002e862
c0020b77:	68 20 ea 02 c0       	push   $0xc002ea20
c0020b7c:	68 d8 00 00 00       	push   $0xd8
c0020b81:	68 79 e8 02 c0       	push   $0xc002e879
c0020b86:	e8 93 89 00 00       	call   c002951e <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0020b8b:	e8 9f 07 00 00       	call   c002132f <intr_get_level>
c0020b90:	85 c0                	test   %eax,%eax
c0020b92:	74 21                	je     c0020bb5 <thread_block+0x5d>
c0020b94:	83 ec 0c             	sub    $0xc,%esp
c0020b97:	68 44 e8 02 c0       	push   $0xc002e844
c0020b9c:	68 62 e8 02 c0       	push   $0xc002e862
c0020ba1:	68 20 ea 02 c0       	push   $0xc002ea20
c0020ba6:	68 d9 00 00 00       	push   $0xd9
c0020bab:	68 79 e8 02 c0       	push   $0xc002e879
c0020bb0:	e8 69 89 00 00       	call   c002951e <debug_panic>

  thread_current ()->status = THREAD_BLOCKED;
c0020bb5:	e8 be 00 00 00       	call   c0020c78 <thread_current>
c0020bba:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  schedule ();
c0020bc1:	e8 12 06 00 00       	call   c00211d8 <schedule>
}
c0020bc6:	90                   	nop
c0020bc7:	c9                   	leave  
c0020bc8:	c3                   	ret    

c0020bc9 <thread_unblock>:
   be important: if the caller had disabled interrupts itself,
   it may expect that it can atomically unblock a thread and
   update other data. */
void
thread_unblock (struct thread *t) 
{
c0020bc9:	55                   	push   %ebp
c0020bca:	89 e5                	mov    %esp,%ebp
c0020bcc:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (is_thread (t));
c0020bcf:	83 ec 0c             	sub    $0xc,%esp
c0020bd2:	ff 75 08             	push   0x8(%ebp)
c0020bd5:	e8 7b 03 00 00       	call   c0020f55 <is_thread>
c0020bda:	83 c4 10             	add    $0x10,%esp
c0020bdd:	84 c0                	test   %al,%al
c0020bdf:	75 21                	jne    c0020c02 <thread_unblock+0x39>
c0020be1:	83 ec 0c             	sub    $0xc,%esp
c0020be4:	68 fb e8 02 c0       	push   $0xc002e8fb
c0020be9:	68 62 e8 02 c0       	push   $0xc002e862
c0020bee:	68 30 ea 02 c0       	push   $0xc002ea30
c0020bf3:	68 ec 00 00 00       	push   $0xec
c0020bf8:	68 79 e8 02 c0       	push   $0xc002e879
c0020bfd:	e8 1c 89 00 00       	call   c002951e <debug_panic>

  old_level = intr_disable ();
c0020c02:	e8 96 07 00 00       	call   c002139d <intr_disable>
c0020c07:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (t->status == THREAD_BLOCKED);
c0020c0a:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c0d:	8b 40 04             	mov    0x4(%eax),%eax
c0020c10:	83 f8 02             	cmp    $0x2,%eax
c0020c13:	74 21                	je     c0020c36 <thread_unblock+0x6d>
c0020c15:	83 ec 0c             	sub    $0xc,%esp
c0020c18:	68 09 e9 02 c0       	push   $0xc002e909
c0020c1d:	68 62 e8 02 c0       	push   $0xc002e862
c0020c22:	68 30 ea 02 c0       	push   $0xc002ea30
c0020c27:	68 ef 00 00 00       	push   $0xef
c0020c2c:	68 79 e8 02 c0       	push   $0xc002e879
c0020c31:	e8 e8 88 00 00       	call   c002951e <debug_panic>
  list_push_back (&ready_list, &t->elem);
c0020c36:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c39:	83 c0 28             	add    $0x28,%eax
c0020c3c:	83 ec 08             	sub    $0x8,%esp
c0020c3f:	50                   	push   %eax
c0020c40:	68 cc 39 03 c0       	push   $0xc00339cc
c0020c45:	e8 2b 8f 00 00       	call   c0029b75 <list_push_back>
c0020c4a:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_READY;
c0020c4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c50:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  intr_set_level (old_level);
c0020c57:	83 ec 0c             	sub    $0xc,%esp
c0020c5a:	ff 75 f4             	push   -0xc(%ebp)
c0020c5d:	e8 e3 06 00 00       	call   c0021345 <intr_set_level>
c0020c62:	83 c4 10             	add    $0x10,%esp
}
c0020c65:	90                   	nop
c0020c66:	c9                   	leave  
c0020c67:	c3                   	ret    

c0020c68 <thread_name>:

/* Returns the name of the running thread. */
const char *
thread_name (void) 
{
c0020c68:	55                   	push   %ebp
c0020c69:	89 e5                	mov    %esp,%ebp
c0020c6b:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->name;
c0020c6e:	e8 05 00 00 00       	call   c0020c78 <thread_current>
c0020c73:	83 c0 08             	add    $0x8,%eax
}
c0020c76:	c9                   	leave  
c0020c77:	c3                   	ret    

c0020c78 <thread_current>:
/* Returns the running thread.
   This is running_thread() plus a couple of sanity checks.
   See the big comment at the top of thread.h for details. */
struct thread *
thread_current (void) 
{
c0020c78:	55                   	push   %ebp
c0020c79:	89 e5                	mov    %esp,%ebp
c0020c7b:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = running_thread ();
c0020c7e:	e8 ba 02 00 00       	call   c0020f3d <running_thread>
c0020c83:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Make sure T is really a thread.
     If either of these assertions fire, then your thread may
     have overflowed its stack.  Each thread has less than 4 kB
     of stack, so a few big automatic arrays or moderate
     recursion can cause stack overflow. */
  ASSERT (is_thread (t));
c0020c86:	83 ec 0c             	sub    $0xc,%esp
c0020c89:	ff 75 f4             	push   -0xc(%ebp)
c0020c8c:	e8 c4 02 00 00       	call   c0020f55 <is_thread>
c0020c91:	83 c4 10             	add    $0x10,%esp
c0020c94:	84 c0                	test   %al,%al
c0020c96:	75 21                	jne    c0020cb9 <thread_current+0x41>
c0020c98:	83 ec 0c             	sub    $0xc,%esp
c0020c9b:	68 fb e8 02 c0       	push   $0xc002e8fb
c0020ca0:	68 62 e8 02 c0       	push   $0xc002e862
c0020ca5:	68 40 ea 02 c0       	push   $0xc002ea40
c0020caa:	68 09 01 00 00       	push   $0x109
c0020caf:	68 79 e8 02 c0       	push   $0xc002e879
c0020cb4:	e8 65 88 00 00       	call   c002951e <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);
c0020cb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020cbc:	8b 40 04             	mov    0x4(%eax),%eax
c0020cbf:	85 c0                	test   %eax,%eax
c0020cc1:	74 21                	je     c0020ce4 <thread_current+0x6c>
c0020cc3:	83 ec 0c             	sub    $0xc,%esp
c0020cc6:	68 25 e9 02 c0       	push   $0xc002e925
c0020ccb:	68 62 e8 02 c0       	push   $0xc002e862
c0020cd0:	68 40 ea 02 c0       	push   $0xc002ea40
c0020cd5:	68 0a 01 00 00       	push   $0x10a
c0020cda:	68 79 e8 02 c0       	push   $0xc002e879
c0020cdf:	e8 3a 88 00 00       	call   c002951e <debug_panic>

  return t;
c0020ce4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0020ce7:	c9                   	leave  
c0020ce8:	c3                   	ret    

c0020ce9 <thread_tid>:

/* Returns the running thread's tid. */
tid_t
thread_tid (void) 
{
c0020ce9:	55                   	push   %ebp
c0020cea:	89 e5                	mov    %esp,%ebp
c0020cec:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->tid;
c0020cef:	e8 84 ff ff ff       	call   c0020c78 <thread_current>
c0020cf4:	8b 00                	mov    (%eax),%eax
}
c0020cf6:	c9                   	leave  
c0020cf7:	c3                   	ret    

c0020cf8 <thread_exit>:

/* Deschedules the current thread and destroys it.  Never
   returns to the caller. */
void
thread_exit (void) 
{
c0020cf8:	55                   	push   %ebp
c0020cf9:	89 e5                	mov    %esp,%ebp
c0020cfb:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020cfe:	e8 67 09 00 00       	call   c002166a <intr_context>
c0020d03:	83 f0 01             	xor    $0x1,%eax
c0020d06:	84 c0                	test   %al,%al
c0020d08:	75 21                	jne    c0020d2b <thread_exit+0x33>
c0020d0a:	83 ec 0c             	sub    $0xc,%esp
c0020d0d:	68 ea e8 02 c0       	push   $0xc002e8ea
c0020d12:	68 62 e8 02 c0       	push   $0xc002e862
c0020d17:	68 50 ea 02 c0       	push   $0xc002ea50
c0020d1c:	68 1b 01 00 00       	push   $0x11b
c0020d21:	68 79 e8 02 c0       	push   $0xc002e879
c0020d26:	e8 f3 87 00 00       	call   c002951e <debug_panic>
#endif

  /* Remove thread from all threads list, set our status to dying,
     and schedule another process.  That process will destroy us
     when it calls thread_schedule_tail(). */
  intr_disable ();
c0020d2b:	e8 6d 06 00 00       	call   c002139d <intr_disable>
  list_remove (&thread_current()->allelem);
c0020d30:	e8 43 ff ff ff       	call   c0020c78 <thread_current>
c0020d35:	83 c0 20             	add    $0x20,%eax
c0020d38:	83 ec 0c             	sub    $0xc,%esp
c0020d3b:	50                   	push   %eax
c0020d3c:	e8 5a 8e 00 00       	call   c0029b9b <list_remove>
c0020d41:	83 c4 10             	add    $0x10,%esp
  thread_current ()->status = THREAD_DYING;
c0020d44:	e8 2f ff ff ff       	call   c0020c78 <thread_current>
c0020d49:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  schedule ();
c0020d50:	e8 83 04 00 00       	call   c00211d8 <schedule>
  NOT_REACHED ();
c0020d55:	68 44 e9 02 c0       	push   $0xc002e944
c0020d5a:	68 50 ea 02 c0       	push   $0xc002ea50
c0020d5f:	68 28 01 00 00       	push   $0x128
c0020d64:	68 79 e8 02 c0       	push   $0xc002e879
c0020d69:	e8 b0 87 00 00       	call   c002951e <debug_panic>

c0020d6e <thread_yield>:

/* Yields the CPU.  The current thread is not put to sleep and
   may be scheduled again immediately at the scheduler's whim. */
void
thread_yield (void) 
{
c0020d6e:	55                   	push   %ebp
c0020d6f:	89 e5                	mov    %esp,%ebp
c0020d71:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = thread_current ();
c0020d74:	e8 ff fe ff ff       	call   c0020c78 <thread_current>
c0020d79:	89 45 f4             	mov    %eax,-0xc(%ebp)
  enum intr_level old_level;
  
  ASSERT (!intr_context ());
c0020d7c:	e8 e9 08 00 00       	call   c002166a <intr_context>
c0020d81:	83 f0 01             	xor    $0x1,%eax
c0020d84:	84 c0                	test   %al,%al
c0020d86:	75 21                	jne    c0020da9 <thread_yield+0x3b>
c0020d88:	83 ec 0c             	sub    $0xc,%esp
c0020d8b:	68 ea e8 02 c0       	push   $0xc002e8ea
c0020d90:	68 62 e8 02 c0       	push   $0xc002e862
c0020d95:	68 5c ea 02 c0       	push   $0xc002ea5c
c0020d9a:	68 33 01 00 00       	push   $0x133
c0020d9f:	68 79 e8 02 c0       	push   $0xc002e879
c0020da4:	e8 75 87 00 00       	call   c002951e <debug_panic>

  old_level = intr_disable ();
c0020da9:	e8 ef 05 00 00       	call   c002139d <intr_disable>
c0020dae:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (cur != idle_thread) 
c0020db1:	a1 ec 39 03 c0       	mov    0xc00339ec,%eax
c0020db6:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0020db9:	74 17                	je     c0020dd2 <thread_yield+0x64>
    list_push_back (&ready_list, &cur->elem);
c0020dbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020dbe:	83 c0 28             	add    $0x28,%eax
c0020dc1:	83 ec 08             	sub    $0x8,%esp
c0020dc4:	50                   	push   %eax
c0020dc5:	68 cc 39 03 c0       	push   $0xc00339cc
c0020dca:	e8 a6 8d 00 00       	call   c0029b75 <list_push_back>
c0020dcf:	83 c4 10             	add    $0x10,%esp
  cur->status = THREAD_READY;
c0020dd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020dd5:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  schedule ();
c0020ddc:	e8 f7 03 00 00       	call   c00211d8 <schedule>
  intr_set_level (old_level);
c0020de1:	83 ec 0c             	sub    $0xc,%esp
c0020de4:	ff 75 f0             	push   -0x10(%ebp)
c0020de7:	e8 59 05 00 00       	call   c0021345 <intr_set_level>
c0020dec:	83 c4 10             	add    $0x10,%esp
}
c0020def:	90                   	nop
c0020df0:	c9                   	leave  
c0020df1:	c3                   	ret    

c0020df2 <thread_foreach>:

/* Invoke function 'func' on all threads, passing along 'aux'.
   This function must be called with interrupts off. */
void
thread_foreach (thread_action_func *func, void *aux)
{
c0020df2:	55                   	push   %ebp
c0020df3:	89 e5                	mov    %esp,%ebp
c0020df5:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);
c0020df8:	e8 32 05 00 00       	call   c002132f <intr_get_level>
c0020dfd:	85 c0                	test   %eax,%eax
c0020dff:	74 21                	je     c0020e22 <thread_foreach+0x30>
c0020e01:	83 ec 0c             	sub    $0xc,%esp
c0020e04:	68 44 e8 02 c0       	push   $0xc002e844
c0020e09:	68 62 e8 02 c0       	push   $0xc002e862
c0020e0e:	68 6c ea 02 c0       	push   $0xc002ea6c
c0020e13:	68 44 01 00 00       	push   $0x144
c0020e18:	68 79 e8 02 c0       	push   $0xc002e879
c0020e1d:	e8 fc 86 00 00       	call   c002951e <debug_panic>

  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020e22:	83 ec 0c             	sub    $0xc,%esp
c0020e25:	68 dc 39 03 c0       	push   $0xc00339dc
c0020e2a:	e8 bb 89 00 00       	call   c00297ea <list_begin>
c0020e2f:	83 c4 10             	add    $0x10,%esp
c0020e32:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0020e35:	eb 2e                	jmp    c0020e65 <thread_foreach+0x73>
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
c0020e37:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020e3a:	83 c0 04             	add    $0x4,%eax
c0020e3d:	83 e8 24             	sub    $0x24,%eax
c0020e40:	89 45 f0             	mov    %eax,-0x10(%ebp)
      func (t, aux);
c0020e43:	83 ec 08             	sub    $0x8,%esp
c0020e46:	ff 75 0c             	push   0xc(%ebp)
c0020e49:	ff 75 f0             	push   -0x10(%ebp)
c0020e4c:	8b 45 08             	mov    0x8(%ebp),%eax
c0020e4f:	ff d0                	call   *%eax
c0020e51:	83 c4 10             	add    $0x10,%esp
       e = list_next (e))
c0020e54:	83 ec 0c             	sub    $0xc,%esp
c0020e57:	ff 75 f4             	push   -0xc(%ebp)
c0020e5a:	e8 bd 89 00 00       	call   c002981c <list_next>
c0020e5f:	83 c4 10             	add    $0x10,%esp
c0020e62:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020e65:	83 ec 0c             	sub    $0xc,%esp
c0020e68:	68 dc 39 03 c0       	push   $0xc00339dc
c0020e6d:	e8 f4 89 00 00       	call   c0029866 <list_end>
c0020e72:	83 c4 10             	add    $0x10,%esp
c0020e75:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0020e78:	75 bd                	jne    c0020e37 <thread_foreach+0x45>
    }
}
c0020e7a:	90                   	nop
c0020e7b:	90                   	nop
c0020e7c:	c9                   	leave  
c0020e7d:	c3                   	ret    

c0020e7e <thread_set_priority>:

/* Sets the current thread's priority to NEW_PRIORITY. */
void
thread_set_priority (int new_priority) 
{
c0020e7e:	55                   	push   %ebp
c0020e7f:	89 e5                	mov    %esp,%ebp
c0020e81:	83 ec 08             	sub    $0x8,%esp
  thread_current ()->priority = new_priority;
c0020e84:	e8 ef fd ff ff       	call   c0020c78 <thread_current>
c0020e89:	8b 55 08             	mov    0x8(%ebp),%edx
c0020e8c:	89 50 1c             	mov    %edx,0x1c(%eax)
}
c0020e8f:	90                   	nop
c0020e90:	c9                   	leave  
c0020e91:	c3                   	ret    

c0020e92 <thread_get_priority>:

/* Returns the current thread's priority. */
int
thread_get_priority (void) 
{
c0020e92:	55                   	push   %ebp
c0020e93:	89 e5                	mov    %esp,%ebp
c0020e95:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->priority;
c0020e98:	e8 db fd ff ff       	call   c0020c78 <thread_current>
c0020e9d:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0020ea0:	c9                   	leave  
c0020ea1:	c3                   	ret    

c0020ea2 <thread_set_nice>:

/* Sets the current thread's nice value to NICE. */
void
thread_set_nice (int nice UNUSED) 
{
c0020ea2:	55                   	push   %ebp
c0020ea3:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
}
c0020ea5:	90                   	nop
c0020ea6:	5d                   	pop    %ebp
c0020ea7:	c3                   	ret    

c0020ea8 <thread_get_nice>:

/* Returns the current thread's nice value. */
int
thread_get_nice (void) 
{
c0020ea8:	55                   	push   %ebp
c0020ea9:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020eab:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020eb0:	5d                   	pop    %ebp
c0020eb1:	c3                   	ret    

c0020eb2 <thread_get_load_avg>:

/* Returns 100 times the system load average. */
int
thread_get_load_avg (void) 
{
c0020eb2:	55                   	push   %ebp
c0020eb3:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020eb5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020eba:	5d                   	pop    %ebp
c0020ebb:	c3                   	ret    

c0020ebc <thread_get_recent_cpu>:

/* Returns 100 times the current thread's recent_cpu value. */
int
thread_get_recent_cpu (void) 
{
c0020ebc:	55                   	push   %ebp
c0020ebd:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020ebf:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020ec4:	5d                   	pop    %ebp
c0020ec5:	c3                   	ret    

c0020ec6 <idle>:
   blocks.  After that, the idle thread never appears in the
   ready list.  It is returned by next_thread_to_run() as a
   special case when the ready list is empty. */
static void
idle (void *idle_started_ UNUSED) 
{
c0020ec6:	55                   	push   %ebp
c0020ec7:	89 e5                	mov    %esp,%ebp
c0020ec9:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *idle_started = idle_started_;
c0020ecc:	8b 45 08             	mov    0x8(%ebp),%eax
c0020ecf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  idle_thread = thread_current ();
c0020ed2:	e8 a1 fd ff ff       	call   c0020c78 <thread_current>
c0020ed7:	a3 ec 39 03 c0       	mov    %eax,0xc00339ec
  sema_up (idle_started);
c0020edc:	83 ec 0c             	sub    $0xc,%esp
c0020edf:	ff 75 f4             	push   -0xc(%ebp)
c0020ee2:	e8 06 1a 00 00       	call   c00228ed <sema_up>
c0020ee7:	83 c4 10             	add    $0x10,%esp

  for (;;) 
    {
      /* Let someone else run. */
      intr_disable ();
c0020eea:	e8 ae 04 00 00       	call   c002139d <intr_disable>
      thread_block ();
c0020eef:	e8 64 fc ff ff       	call   c0020b58 <thread_block>
         one to occur, wasting as much as one clock tick worth of
         time.

         See [IA32-v2a] "HLT", [IA32-v2b] "STI", and [IA32-v3a]
         7.11.1 "HLT Instruction". */
      asm volatile ("sti; hlt" : : : "memory");
c0020ef4:	fb                   	sti    
c0020ef5:	f4                   	hlt    
      intr_disable ();
c0020ef6:	eb f2                	jmp    c0020eea <idle+0x24>

c0020ef8 <kernel_thread>:
}

/* Function used as the basis for a kernel thread. */
static void
kernel_thread (thread_func *function, void *aux) 
{
c0020ef8:	55                   	push   %ebp
c0020ef9:	89 e5                	mov    %esp,%ebp
c0020efb:	83 ec 08             	sub    $0x8,%esp
  ASSERT (function != NULL);
c0020efe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0020f02:	75 21                	jne    c0020f25 <kernel_thread+0x2d>
c0020f04:	83 ec 0c             	sub    $0xc,%esp
c0020f07:	68 d9 e8 02 c0       	push   $0xc002e8d9
c0020f0c:	68 62 e8 02 c0       	push   $0xc002e862
c0020f11:	68 7c ea 02 c0       	push   $0xc002ea7c
c0020f16:	68 a5 01 00 00       	push   $0x1a5
c0020f1b:	68 79 e8 02 c0       	push   $0xc002e879
c0020f20:	e8 f9 85 00 00       	call   c002951e <debug_panic>

  intr_enable ();       /* The scheduler runs with interrupts off. */
c0020f25:	e8 35 04 00 00       	call   c002135f <intr_enable>
  function (aux);       /* Execute the thread function. */
c0020f2a:	83 ec 0c             	sub    $0xc,%esp
c0020f2d:	ff 75 0c             	push   0xc(%ebp)
c0020f30:	8b 45 08             	mov    0x8(%ebp),%eax
c0020f33:	ff d0                	call   *%eax
c0020f35:	83 c4 10             	add    $0x10,%esp
  thread_exit ();       /* If function() returns, kill the thread. */
c0020f38:	e8 bb fd ff ff       	call   c0020cf8 <thread_exit>

c0020f3d <running_thread>:
}

/* Returns the running thread. */
struct thread *
running_thread (void) 
{
c0020f3d:	55                   	push   %ebp
c0020f3e:	89 e5                	mov    %esp,%ebp
c0020f40:	83 ec 10             	sub    $0x10,%esp

  /* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the curent thread. */
  asm ("mov %%esp, %0" : "=g" (esp));
c0020f43:	89 e0                	mov    %esp,%eax
c0020f45:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return pg_round_down (esp);
c0020f48:	ff 75 fc             	push   -0x4(%ebp)
c0020f4b:	e8 65 f9 ff ff       	call   c00208b5 <pg_round_down>
c0020f50:	83 c4 04             	add    $0x4,%esp
}
c0020f53:	c9                   	leave  
c0020f54:	c3                   	ret    

c0020f55 <is_thread>:

/* Returns true if T appears to point to a valid thread. */
static bool
is_thread (struct thread *t)
{
c0020f55:	55                   	push   %ebp
c0020f56:	89 e5                	mov    %esp,%ebp
  return t != NULL && t->magic == THREAD_MAGIC;
c0020f58:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0020f5c:	74 14                	je     c0020f72 <is_thread+0x1d>
c0020f5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0020f61:	8b 40 30             	mov    0x30(%eax),%eax
c0020f64:	3d 4b bf 6a cd       	cmp    $0xcd6abf4b,%eax
c0020f69:	75 07                	jne    c0020f72 <is_thread+0x1d>
c0020f6b:	b8 01 00 00 00       	mov    $0x1,%eax
c0020f70:	eb 05                	jmp    c0020f77 <is_thread+0x22>
c0020f72:	b8 00 00 00 00       	mov    $0x0,%eax
c0020f77:	83 e0 01             	and    $0x1,%eax
}
c0020f7a:	5d                   	pop    %ebp
c0020f7b:	c3                   	ret    

c0020f7c <init_thread>:

/* Does basic initialization of T as a blocked thread named
   NAME. */
static void
init_thread (struct thread *t, const char *name, int priority)
{
c0020f7c:	55                   	push   %ebp
c0020f7d:	89 e5                	mov    %esp,%ebp
c0020f7f:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (t != NULL);
c0020f82:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0020f86:	75 21                	jne    c0020fa9 <init_thread+0x2d>
c0020f88:	83 ec 0c             	sub    $0xc,%esp
c0020f8b:	68 66 e9 02 c0       	push   $0xc002e966
c0020f90:	68 62 e8 02 c0       	push   $0xc002e862
c0020f95:	68 8c ea 02 c0       	push   $0xc002ea8c
c0020f9a:	68 c8 01 00 00       	push   $0x1c8
c0020f9f:	68 79 e8 02 c0       	push   $0xc002e879
c0020fa4:	e8 75 85 00 00       	call   c002951e <debug_panic>
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c0020fa9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0020fad:	78 06                	js     c0020fb5 <init_thread+0x39>
c0020faf:	83 7d 10 3f          	cmpl   $0x3f,0x10(%ebp)
c0020fb3:	7e 21                	jle    c0020fd6 <init_thread+0x5a>
c0020fb5:	83 ec 0c             	sub    $0xc,%esp
c0020fb8:	68 70 e9 02 c0       	push   $0xc002e970
c0020fbd:	68 62 e8 02 c0       	push   $0xc002e862
c0020fc2:	68 8c ea 02 c0       	push   $0xc002ea8c
c0020fc7:	68 c9 01 00 00       	push   $0x1c9
c0020fcc:	68 79 e8 02 c0       	push   $0xc002e879
c0020fd1:	e8 48 85 00 00       	call   c002951e <debug_panic>
  ASSERT (name != NULL);
c0020fd6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0020fda:	75 21                	jne    c0020ffd <init_thread+0x81>
c0020fdc:	83 ec 0c             	sub    $0xc,%esp
c0020fdf:	68 9b e9 02 c0       	push   $0xc002e99b
c0020fe4:	68 62 e8 02 c0       	push   $0xc002e862
c0020fe9:	68 8c ea 02 c0       	push   $0xc002ea8c
c0020fee:	68 ca 01 00 00       	push   $0x1ca
c0020ff3:	68 79 e8 02 c0       	push   $0xc002e879
c0020ff8:	e8 21 85 00 00       	call   c002951e <debug_panic>

  memset (t, 0, sizeof *t);
c0020ffd:	83 ec 04             	sub    $0x4,%esp
c0021000:	6a 34                	push   $0x34
c0021002:	6a 00                	push   $0x0
c0021004:	ff 75 08             	push   0x8(%ebp)
c0021007:	e8 3e 79 00 00       	call   c002894a <memset>
c002100c:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_BLOCKED;
c002100f:	8b 45 08             	mov    0x8(%ebp),%eax
c0021012:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  strlcpy (t->name, name, sizeof t->name);
c0021019:	8b 45 08             	mov    0x8(%ebp),%eax
c002101c:	83 c0 08             	add    $0x8,%eax
c002101f:	83 ec 04             	sub    $0x4,%esp
c0021022:	6a 10                	push   $0x10
c0021024:	ff 75 0c             	push   0xc(%ebp)
c0021027:	50                   	push   %eax
c0021028:	e8 ec 79 00 00       	call   c0028a19 <strlcpy>
c002102d:	83 c4 10             	add    $0x10,%esp
  t->stack = (uint8_t *) t + PGSIZE;
c0021030:	8b 45 08             	mov    0x8(%ebp),%eax
c0021033:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0021039:	8b 45 08             	mov    0x8(%ebp),%eax
c002103c:	89 50 18             	mov    %edx,0x18(%eax)
  t->priority = priority;
c002103f:	8b 45 08             	mov    0x8(%ebp),%eax
c0021042:	8b 55 10             	mov    0x10(%ebp),%edx
c0021045:	89 50 1c             	mov    %edx,0x1c(%eax)
  t->magic = THREAD_MAGIC;
c0021048:	8b 45 08             	mov    0x8(%ebp),%eax
c002104b:	c7 40 30 4b bf 6a cd 	movl   $0xcd6abf4b,0x30(%eax)

  old_level = intr_disable ();
c0021052:	e8 46 03 00 00       	call   c002139d <intr_disable>
c0021057:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_push_back (&all_list, &t->allelem);
c002105a:	8b 45 08             	mov    0x8(%ebp),%eax
c002105d:	83 c0 20             	add    $0x20,%eax
c0021060:	83 ec 08             	sub    $0x8,%esp
c0021063:	50                   	push   %eax
c0021064:	68 dc 39 03 c0       	push   $0xc00339dc
c0021069:	e8 07 8b 00 00       	call   c0029b75 <list_push_back>
c002106e:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0021071:	83 ec 0c             	sub    $0xc,%esp
c0021074:	ff 75 f4             	push   -0xc(%ebp)
c0021077:	e8 c9 02 00 00       	call   c0021345 <intr_set_level>
c002107c:	83 c4 10             	add    $0x10,%esp
}
c002107f:	90                   	nop
c0021080:	c9                   	leave  
c0021081:	c3                   	ret    

c0021082 <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame (struct thread *t, size_t size) 
{
c0021082:	55                   	push   %ebp
c0021083:	89 e5                	mov    %esp,%ebp
c0021085:	83 ec 08             	sub    $0x8,%esp
  /* Stack data is always allocated in word-size units. */
  ASSERT (is_thread (t));
c0021088:	ff 75 08             	push   0x8(%ebp)
c002108b:	e8 c5 fe ff ff       	call   c0020f55 <is_thread>
c0021090:	83 c4 04             	add    $0x4,%esp
c0021093:	84 c0                	test   %al,%al
c0021095:	75 21                	jne    c00210b8 <alloc_frame+0x36>
c0021097:	83 ec 0c             	sub    $0xc,%esp
c002109a:	68 fb e8 02 c0       	push   $0xc002e8fb
c002109f:	68 62 e8 02 c0       	push   $0xc002e862
c00210a4:	68 98 ea 02 c0       	push   $0xc002ea98
c00210a9:	68 de 01 00 00       	push   $0x1de
c00210ae:	68 79 e8 02 c0       	push   $0xc002e879
c00210b3:	e8 66 84 00 00       	call   c002951e <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);
c00210b8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00210bb:	83 e0 03             	and    $0x3,%eax
c00210be:	85 c0                	test   %eax,%eax
c00210c0:	74 21                	je     c00210e3 <alloc_frame+0x61>
c00210c2:	83 ec 0c             	sub    $0xc,%esp
c00210c5:	68 a8 e9 02 c0       	push   $0xc002e9a8
c00210ca:	68 62 e8 02 c0       	push   $0xc002e862
c00210cf:	68 98 ea 02 c0       	push   $0xc002ea98
c00210d4:	68 df 01 00 00       	push   $0x1df
c00210d9:	68 79 e8 02 c0       	push   $0xc002e879
c00210de:	e8 3b 84 00 00       	call   c002951e <debug_panic>

  t->stack -= size;
c00210e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00210e6:	8b 40 18             	mov    0x18(%eax),%eax
c00210e9:	8b 55 0c             	mov    0xc(%ebp),%edx
c00210ec:	f7 da                	neg    %edx
c00210ee:	01 c2                	add    %eax,%edx
c00210f0:	8b 45 08             	mov    0x8(%ebp),%eax
c00210f3:	89 50 18             	mov    %edx,0x18(%eax)
  return t->stack;
c00210f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00210f9:	8b 40 18             	mov    0x18(%eax),%eax
}
c00210fc:	c9                   	leave  
c00210fd:	c3                   	ret    

c00210fe <next_thread_to_run>:
   empty.  (If the running thread can continue running, then it
   will be in the run queue.)  If the run queue is empty, return
   idle_thread. */
static struct thread *
next_thread_to_run (void) 
{
c00210fe:	55                   	push   %ebp
c00210ff:	89 e5                	mov    %esp,%ebp
c0021101:	83 ec 08             	sub    $0x8,%esp
  if (list_empty (&ready_list))
c0021104:	83 ec 0c             	sub    $0xc,%esp
c0021107:	68 cc 39 03 c0       	push   $0xc00339cc
c002110c:	e8 0b 8c 00 00       	call   c0029d1c <list_empty>
c0021111:	83 c4 10             	add    $0x10,%esp
c0021114:	84 c0                	test   %al,%al
c0021116:	74 07                	je     c002111f <next_thread_to_run+0x21>
    return idle_thread;
c0021118:	a1 ec 39 03 c0       	mov    0xc00339ec,%eax
c002111d:	eb 16                	jmp    c0021135 <next_thread_to_run+0x37>
  else
    return list_entry (list_pop_front (&ready_list), struct thread, elem);
c002111f:	83 ec 0c             	sub    $0xc,%esp
c0021122:	68 cc 39 03 c0       	push   $0xc00339cc
c0021127:	e8 c8 8a 00 00       	call   c0029bf4 <list_pop_front>
c002112c:	83 c4 10             	add    $0x10,%esp
c002112f:	83 c0 04             	add    $0x4,%eax
c0021132:	83 e8 2c             	sub    $0x2c,%eax
}
c0021135:	c9                   	leave  
c0021136:	c3                   	ret    

c0021137 <thread_schedule_tail>:

   After this function and its caller returns, the thread switch
   is complete. */
void
thread_schedule_tail (struct thread *prev)
{
c0021137:	55                   	push   %ebp
c0021138:	89 e5                	mov    %esp,%ebp
c002113a:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c002113d:	e8 fb fd ff ff       	call   c0020f3d <running_thread>
c0021142:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (intr_get_level () == INTR_OFF);
c0021145:	e8 e5 01 00 00       	call   c002132f <intr_get_level>
c002114a:	85 c0                	test   %eax,%eax
c002114c:	74 21                	je     c002116f <thread_schedule_tail+0x38>
c002114e:	83 ec 0c             	sub    $0xc,%esp
c0021151:	68 44 e8 02 c0       	push   $0xc002e844
c0021156:	68 62 e8 02 c0       	push   $0xc002e862
c002115b:	68 a4 ea 02 c0       	push   $0xc002eaa4
c0021160:	68 08 02 00 00       	push   $0x208
c0021165:	68 79 e8 02 c0       	push   $0xc002e879
c002116a:	e8 af 83 00 00       	call   c002951e <debug_panic>

  /* Mark us as running. */
  cur->status = THREAD_RUNNING;
c002116f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021172:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

  /* Start new time slice. */
  thread_ticks = 0;
c0021179:	c7 05 28 3a 03 c0 00 	movl   $0x0,0xc0033a28
c0021180:	00 00 00 
  /* If the thread we switched from is dying, destroy its struct
     thread.  This must happen late so that thread_exit() doesn't
     pull out the rug under itself.  (We don't free
     initial_thread because its memory was not obtained via
     palloc().) */
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c0021183:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021187:	74 4c                	je     c00211d5 <thread_schedule_tail+0x9e>
c0021189:	8b 45 08             	mov    0x8(%ebp),%eax
c002118c:	8b 40 04             	mov    0x4(%eax),%eax
c002118f:	83 f8 03             	cmp    $0x3,%eax
c0021192:	75 41                	jne    c00211d5 <thread_schedule_tail+0x9e>
c0021194:	a1 f0 39 03 c0       	mov    0xc00339f0,%eax
c0021199:	39 45 08             	cmp    %eax,0x8(%ebp)
c002119c:	74 37                	je     c00211d5 <thread_schedule_tail+0x9e>
    {
      ASSERT (prev != cur);
c002119e:	8b 45 08             	mov    0x8(%ebp),%eax
c00211a1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00211a4:	75 21                	jne    c00211c7 <thread_schedule_tail+0x90>
c00211a6:	83 ec 0c             	sub    $0xc,%esp
c00211a9:	68 c6 e9 02 c0       	push   $0xc002e9c6
c00211ae:	68 62 e8 02 c0       	push   $0xc002e862
c00211b3:	68 a4 ea 02 c0       	push   $0xc002eaa4
c00211b8:	68 1c 02 00 00       	push   $0x21c
c00211bd:	68 79 e8 02 c0       	push   $0xc002e879
c00211c2:	e8 57 83 00 00       	call   c002951e <debug_panic>
      palloc_free_page (prev);
c00211c7:	83 ec 0c             	sub    $0xc,%esp
c00211ca:	ff 75 08             	push   0x8(%ebp)
c00211cd:	e8 a5 20 00 00       	call   c0023277 <palloc_free_page>
c00211d2:	83 c4 10             	add    $0x10,%esp
    }
}
c00211d5:	90                   	nop
c00211d6:	c9                   	leave  
c00211d7:	c3                   	ret    

c00211d8 <schedule>:

   It's not safe to call printf() until thread_schedule_tail()
   has completed. */
static void
schedule (void) 
{
c00211d8:	55                   	push   %ebp
c00211d9:	89 e5                	mov    %esp,%ebp
c00211db:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c00211de:	e8 5a fd ff ff       	call   c0020f3d <running_thread>
c00211e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct thread *next = next_thread_to_run ();
c00211e6:	e8 13 ff ff ff       	call   c00210fe <next_thread_to_run>
c00211eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
  struct thread *prev = NULL;
c00211ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c00211f5:	e8 35 01 00 00       	call   c002132f <intr_get_level>
c00211fa:	85 c0                	test   %eax,%eax
c00211fc:	74 21                	je     c002121f <schedule+0x47>
c00211fe:	83 ec 0c             	sub    $0xc,%esp
c0021201:	68 44 e8 02 c0       	push   $0xc002e844
c0021206:	68 62 e8 02 c0       	push   $0xc002e862
c002120b:	68 bc ea 02 c0       	push   $0xc002eabc
c0021210:	68 2f 02 00 00       	push   $0x22f
c0021215:	68 79 e8 02 c0       	push   $0xc002e879
c002121a:	e8 ff 82 00 00       	call   c002951e <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c002121f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021222:	8b 40 04             	mov    0x4(%eax),%eax
c0021225:	85 c0                	test   %eax,%eax
c0021227:	75 21                	jne    c002124a <schedule+0x72>
c0021229:	83 ec 0c             	sub    $0xc,%esp
c002122c:	68 d2 e9 02 c0       	push   $0xc002e9d2
c0021231:	68 62 e8 02 c0       	push   $0xc002e862
c0021236:	68 bc ea 02 c0       	push   $0xc002eabc
c002123b:	68 30 02 00 00       	push   $0x230
c0021240:	68 79 e8 02 c0       	push   $0xc002e879
c0021245:	e8 d4 82 00 00       	call   c002951e <debug_panic>
  ASSERT (is_thread (next));
c002124a:	83 ec 0c             	sub    $0xc,%esp
c002124d:	ff 75 ec             	push   -0x14(%ebp)
c0021250:	e8 00 fd ff ff       	call   c0020f55 <is_thread>
c0021255:	83 c4 10             	add    $0x10,%esp
c0021258:	84 c0                	test   %al,%al
c002125a:	75 21                	jne    c002127d <schedule+0xa5>
c002125c:	83 ec 0c             	sub    $0xc,%esp
c002125f:	68 f0 e9 02 c0       	push   $0xc002e9f0
c0021264:	68 62 e8 02 c0       	push   $0xc002e862
c0021269:	68 bc ea 02 c0       	push   $0xc002eabc
c002126e:	68 31 02 00 00       	push   $0x231
c0021273:	68 79 e8 02 c0       	push   $0xc002e879
c0021278:	e8 a1 82 00 00       	call   c002951e <debug_panic>

  if (cur != next)
c002127d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021280:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0021283:	74 14                	je     c0021299 <schedule+0xc1>
    prev = switch_threads (cur, next);
c0021285:	83 ec 08             	sub    $0x8,%esp
c0021288:	ff 75 ec             	push   -0x14(%ebp)
c002128b:	ff 75 f0             	push   -0x10(%ebp)
c002128e:	e8 53 00 00 00       	call   c00212e6 <switch_threads>
c0021293:	83 c4 10             	add    $0x10,%esp
c0021296:	89 45 f4             	mov    %eax,-0xc(%ebp)
  thread_schedule_tail (prev);
c0021299:	83 ec 0c             	sub    $0xc,%esp
c002129c:	ff 75 f4             	push   -0xc(%ebp)
c002129f:	e8 93 fe ff ff       	call   c0021137 <thread_schedule_tail>
c00212a4:	83 c4 10             	add    $0x10,%esp
}
c00212a7:	90                   	nop
c00212a8:	c9                   	leave  
c00212a9:	c3                   	ret    

c00212aa <allocate_tid>:

/* Returns a tid to use for a new thread. */
static tid_t
allocate_tid (void) 
{
c00212aa:	55                   	push   %ebp
c00212ab:	89 e5                	mov    %esp,%ebp
c00212ad:	83 ec 18             	sub    $0x18,%esp
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire (&tid_lock);
c00212b0:	83 ec 0c             	sub    $0xc,%esp
c00212b3:	68 f4 39 03 c0       	push   $0xc00339f4
c00212b8:	e8 e5 17 00 00       	call   c0022aa2 <lock_acquire>
c00212bd:	83 c4 10             	add    $0x10,%esp
  tid = next_tid++;
c00212c0:	a1 08 30 03 c0       	mov    0xc0033008,%eax
c00212c5:	8d 50 01             	lea    0x1(%eax),%edx
c00212c8:	89 15 08 30 03 c0    	mov    %edx,0xc0033008
c00212ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lock_release (&tid_lock);
c00212d1:	83 ec 0c             	sub    $0xc,%esp
c00212d4:	68 f4 39 03 c0       	push   $0xc00339f4
c00212d9:	e8 00 19 00 00       	call   c0022bde <lock_release>
c00212de:	83 c4 10             	add    $0x10,%esp

  return tid;
c00212e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00212e4:	c9                   	leave  
c00212e5:	c3                   	ret    

c00212e6 <switch_threads>:
c00212e6:	53                   	push   %ebx
c00212e7:	55                   	push   %ebp
c00212e8:	56                   	push   %esi
c00212e9:	57                   	push   %edi
c00212ea:	8b 15 04 30 03 c0    	mov    0xc0033004,%edx
c00212f0:	8b 44 24 14          	mov    0x14(%esp),%eax
c00212f4:	89 24 10             	mov    %esp,(%eax,%edx,1)
c00212f7:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c00212fb:	8b 24 11             	mov    (%ecx,%edx,1),%esp
c00212fe:	5f                   	pop    %edi
c00212ff:	5e                   	pop    %esi
c0021300:	5d                   	pop    %ebp
c0021301:	5b                   	pop    %ebx
c0021302:	c3                   	ret    

c0021303 <switch_entry>:
c0021303:	83 c4 08             	add    $0x8,%esp
c0021306:	50                   	push   %eax
c0021307:	e8 2b fe ff ff       	call   c0021137 <thread_schedule_tail>
c002130c:	83 c4 04             	add    $0x4,%esp
c002130f:	c3                   	ret    

c0021310 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0021310:	55                   	push   %ebp
c0021311:	89 e5                	mov    %esp,%ebp
c0021313:	83 ec 08             	sub    $0x8,%esp
c0021316:	8b 45 08             	mov    0x8(%ebp),%eax
c0021319:	8b 55 0c             	mov    0xc(%ebp),%edx
c002131c:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0021320:	88 d0                	mov    %dl,%al
c0021322:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0021325:	8a 45 f8             	mov    -0x8(%ebp),%al
c0021328:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002132b:	ee                   	out    %al,(%dx)
}
c002132c:	90                   	nop
c002132d:	c9                   	leave  
c002132e:	c3                   	ret    

c002132f <intr_get_level>:
static void unexpected_interrupt (const struct intr_frame *);

/* Returns the current interrupt status. */
enum intr_level
intr_get_level (void) 
{
c002132f:	55                   	push   %ebp
c0021330:	89 e5                	mov    %esp,%ebp
c0021332:	83 ec 10             	sub    $0x10,%esp

  /* Push the flags register on the processor stack, then pop the
     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
     Interrupts". */
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c0021335:	9c                   	pushf  
c0021336:	58                   	pop    %eax
c0021337:	89 45 fc             	mov    %eax,-0x4(%ebp)

  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c002133a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002133d:	c1 e8 09             	shr    $0x9,%eax
c0021340:	83 e0 01             	and    $0x1,%eax
}
c0021343:	c9                   	leave  
c0021344:	c3                   	ret    

c0021345 <intr_set_level>:

/* Enables or disables interrupts as specified by LEVEL and
   returns the previous interrupt status. */
enum intr_level
intr_set_level (enum intr_level level) 
{
c0021345:	55                   	push   %ebp
c0021346:	89 e5                	mov    %esp,%ebp
c0021348:	83 ec 08             	sub    $0x8,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c002134b:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c002134f:	75 07                	jne    c0021358 <intr_set_level+0x13>
c0021351:	e8 09 00 00 00       	call   c002135f <intr_enable>
c0021356:	eb 05                	jmp    c002135d <intr_set_level+0x18>
c0021358:	e8 40 00 00 00       	call   c002139d <intr_disable>
}
c002135d:	c9                   	leave  
c002135e:	c3                   	ret    

c002135f <intr_enable>:

/* Enables interrupts and returns the previous interrupt status. */
enum intr_level
intr_enable (void) 
{
c002135f:	55                   	push   %ebp
c0021360:	89 e5                	mov    %esp,%ebp
c0021362:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_get_level ();
c0021365:	e8 c5 ff ff ff       	call   c002132f <intr_get_level>
c002136a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (!intr_context ());
c002136d:	e8 f8 02 00 00       	call   c002166a <intr_context>
c0021372:	83 f0 01             	xor    $0x1,%eax
c0021375:	84 c0                	test   %al,%al
c0021377:	75 1e                	jne    c0021397 <intr_enable+0x38>
c0021379:	83 ec 0c             	sub    $0xc,%esp
c002137c:	68 c8 ea 02 c0       	push   $0xc002eac8
c0021381:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021386:	68 d8 ee 02 c0       	push   $0xc002eed8
c002138b:	6a 5b                	push   $0x5b
c002138d:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021392:	e8 87 81 00 00       	call   c002951e <debug_panic>

  /* Enable interrupts by setting the interrupt flag.

     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("sti");
c0021397:	fb                   	sti    

  return old_level;
c0021398:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002139b:	c9                   	leave  
c002139c:	c3                   	ret    

c002139d <intr_disable>:

/* Disables interrupts and returns the previous interrupt status. */
enum intr_level
intr_disable (void) 
{
c002139d:	55                   	push   %ebp
c002139e:	89 e5                	mov    %esp,%ebp
c00213a0:	83 ec 10             	sub    $0x10,%esp
  enum intr_level old_level = intr_get_level ();
c00213a3:	e8 87 ff ff ff       	call   c002132f <intr_get_level>
c00213a8:	89 45 fc             	mov    %eax,-0x4(%ebp)

  /* Disable interrupts by clearing the interrupt flag.
     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("cli" : : : "memory");
c00213ab:	fa                   	cli    

  return old_level;
c00213ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00213af:	c9                   	leave  
c00213b0:	c3                   	ret    

c00213b1 <intr_init>:

/* Initializes the interrupt system. */
void
intr_init (void)
{
c00213b1:	55                   	push   %ebp
c00213b2:	89 e5                	mov    %esp,%ebp
c00213b4:	83 ec 18             	sub    $0x18,%esp
  uint64_t idtr_operand;
  int i;

  /* Initialize interrupt controller. */
  pic_init ();
c00213b7:	e8 f2 02 00 00       	call   c00216ae <pic_init>

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
c00213bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00213c3:	eb 2c                	jmp    c00213f1 <intr_init+0x40>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c00213c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00213c8:	8b 04 85 0c 30 03 c0 	mov    -0x3ffccff4(,%eax,4),%eax
c00213cf:	83 ec 08             	sub    $0x8,%esp
c00213d2:	6a 00                	push   $0x0
c00213d4:	50                   	push   %eax
c00213d5:	e8 ce 04 00 00       	call   c00218a8 <make_intr_gate>
c00213da:	83 c4 10             	add    $0x10,%esp
c00213dd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00213e0:	89 04 cd 40 3a 03 c0 	mov    %eax,-0x3ffcc5c0(,%ecx,8)
c00213e7:	89 14 cd 44 3a 03 c0 	mov    %edx,-0x3ffcc5bc(,%ecx,8)
  for (i = 0; i < INTR_CNT; i++)
c00213ee:	ff 45 f4             	incl   -0xc(%ebp)
c00213f1:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c00213f8:	7e cb                	jle    c00213c5 <intr_init+0x14>

  /* Load IDT register.
     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
c00213fa:	83 ec 08             	sub    $0x8,%esp
c00213fd:	68 40 3a 03 c0       	push   $0xc0033a40
c0021402:	68 ff 07 00 00       	push   $0x7ff
c0021407:	e8 d2 04 00 00       	call   c00218de <make_idtr_operand>
c002140c:	83 c4 10             	add    $0x10,%esp
c002140f:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0021412:	89 55 ec             	mov    %edx,-0x14(%ebp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021415:	0f 01 5d e8          	lidtl  -0x18(%ebp)

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
c0021419:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0021420:	eb 11                	jmp    c0021433 <intr_init+0x82>
    intr_names[i] = "unknown";
c0021422:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021425:	c7 04 85 40 46 03 c0 	movl   $0xc002eb0a,-0x3ffcb9c0(,%eax,4)
c002142c:	0a eb 02 c0 
  for (i = 0; i < INTR_CNT; i++)
c0021430:	ff 45 f4             	incl   -0xc(%ebp)
c0021433:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c002143a:	7e e6                	jle    c0021422 <intr_init+0x71>
  intr_names[0] = "#DE Divide Error";
c002143c:	c7 05 40 46 03 c0 12 	movl   $0xc002eb12,0xc0034640
c0021443:	eb 02 c0 
  intr_names[1] = "#DB Debug Exception";
c0021446:	c7 05 44 46 03 c0 23 	movl   $0xc002eb23,0xc0034644
c002144d:	eb 02 c0 
  intr_names[2] = "NMI Interrupt";
c0021450:	c7 05 48 46 03 c0 37 	movl   $0xc002eb37,0xc0034648
c0021457:	eb 02 c0 
  intr_names[3] = "#BP Breakpoint Exception";
c002145a:	c7 05 4c 46 03 c0 45 	movl   $0xc002eb45,0xc003464c
c0021461:	eb 02 c0 
  intr_names[4] = "#OF Overflow Exception";
c0021464:	c7 05 50 46 03 c0 5e 	movl   $0xc002eb5e,0xc0034650
c002146b:	eb 02 c0 
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c002146e:	c7 05 54 46 03 c0 78 	movl   $0xc002eb78,0xc0034654
c0021475:	eb 02 c0 
  intr_names[6] = "#UD Invalid Opcode Exception";
c0021478:	c7 05 58 46 03 c0 9b 	movl   $0xc002eb9b,0xc0034658
c002147f:	eb 02 c0 
  intr_names[7] = "#NM Device Not Available Exception";
c0021482:	c7 05 5c 46 03 c0 b8 	movl   $0xc002ebb8,0xc003465c
c0021489:	eb 02 c0 
  intr_names[8] = "#DF Double Fault Exception";
c002148c:	c7 05 60 46 03 c0 db 	movl   $0xc002ebdb,0xc0034660
c0021493:	eb 02 c0 
  intr_names[9] = "Coprocessor Segment Overrun";
c0021496:	c7 05 64 46 03 c0 f6 	movl   $0xc002ebf6,0xc0034664
c002149d:	eb 02 c0 
  intr_names[10] = "#TS Invalid TSS Exception";
c00214a0:	c7 05 68 46 03 c0 12 	movl   $0xc002ec12,0xc0034668
c00214a7:	ec 02 c0 
  intr_names[11] = "#NP Segment Not Present";
c00214aa:	c7 05 6c 46 03 c0 2c 	movl   $0xc002ec2c,0xc003466c
c00214b1:	ec 02 c0 
  intr_names[12] = "#SS Stack Fault Exception";
c00214b4:	c7 05 70 46 03 c0 44 	movl   $0xc002ec44,0xc0034670
c00214bb:	ec 02 c0 
  intr_names[13] = "#GP General Protection Exception";
c00214be:	c7 05 74 46 03 c0 60 	movl   $0xc002ec60,0xc0034674
c00214c5:	ec 02 c0 
  intr_names[14] = "#PF Page-Fault Exception";
c00214c8:	c7 05 78 46 03 c0 81 	movl   $0xc002ec81,0xc0034678
c00214cf:	ec 02 c0 
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c00214d2:	c7 05 80 46 03 c0 9c 	movl   $0xc002ec9c,0xc0034680
c00214d9:	ec 02 c0 
  intr_names[17] = "#AC Alignment Check Exception";
c00214dc:	c7 05 84 46 03 c0 bd 	movl   $0xc002ecbd,0xc0034684
c00214e3:	ec 02 c0 
  intr_names[18] = "#MC Machine-Check Exception";
c00214e6:	c7 05 88 46 03 c0 db 	movl   $0xc002ecdb,0xc0034688
c00214ed:	ec 02 c0 
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c00214f0:	c7 05 8c 46 03 c0 f8 	movl   $0xc002ecf8,0xc003468c
c00214f7:	ec 02 c0 
}
c00214fa:	90                   	nop
c00214fb:	c9                   	leave  
c00214fc:	c3                   	ret    

c00214fd <register_handler>:
   purposes.  The interrupt handler will be invoked with
   interrupt status set to LEVEL. */
static void
register_handler (uint8_t vec_no, int dpl, enum intr_level level,
                  intr_handler_func *handler, const char *name)
{
c00214fd:	55                   	push   %ebp
c00214fe:	89 e5                	mov    %esp,%ebp
c0021500:	53                   	push   %ebx
c0021501:	83 ec 14             	sub    $0x14,%esp
c0021504:	8b 45 08             	mov    0x8(%ebp),%eax
c0021507:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_handlers[vec_no] == NULL);
c002150a:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002150e:	8b 04 85 40 42 03 c0 	mov    -0x3ffcbdc0(,%eax,4),%eax
c0021515:	85 c0                	test   %eax,%eax
c0021517:	74 21                	je     c002153a <register_handler+0x3d>
c0021519:	83 ec 0c             	sub    $0xc,%esp
c002151c:	68 1a ed 02 c0       	push   $0xc002ed1a
c0021521:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021526:	68 e4 ee 02 c0       	push   $0xc002eee4
c002152b:	68 a8 00 00 00       	push   $0xa8
c0021530:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021535:	e8 e4 7f 00 00       	call   c002951e <debug_panic>
  if (level == INTR_ON)
c002153a:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c002153e:	75 2e                	jne    c002156e <register_handler+0x71>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c0021540:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021544:	8b 04 85 0c 30 03 c0 	mov    -0x3ffccff4(,%eax,4),%eax
c002154b:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c002154f:	83 ec 08             	sub    $0x8,%esp
c0021552:	ff 75 0c             	push   0xc(%ebp)
c0021555:	50                   	push   %eax
c0021556:	e8 68 03 00 00       	call   c00218c3 <make_trap_gate>
c002155b:	83 c4 10             	add    $0x10,%esp
c002155e:	89 04 dd 40 3a 03 c0 	mov    %eax,-0x3ffcc5c0(,%ebx,8)
c0021565:	89 14 dd 44 3a 03 c0 	mov    %edx,-0x3ffcc5bc(,%ebx,8)
c002156c:	eb 2c                	jmp    c002159a <register_handler+0x9d>
  else
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c002156e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021572:	8b 04 85 0c 30 03 c0 	mov    -0x3ffccff4(,%eax,4),%eax
c0021579:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c002157d:	83 ec 08             	sub    $0x8,%esp
c0021580:	ff 75 0c             	push   0xc(%ebp)
c0021583:	50                   	push   %eax
c0021584:	e8 1f 03 00 00       	call   c00218a8 <make_intr_gate>
c0021589:	83 c4 10             	add    $0x10,%esp
c002158c:	89 04 dd 40 3a 03 c0 	mov    %eax,-0x3ffcc5c0(,%ebx,8)
c0021593:	89 14 dd 44 3a 03 c0 	mov    %edx,-0x3ffcc5bc(,%ebx,8)
  intr_handlers[vec_no] = handler;
c002159a:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002159e:	8b 55 14             	mov    0x14(%ebp),%edx
c00215a1:	89 14 85 40 42 03 c0 	mov    %edx,-0x3ffcbdc0(,%eax,4)
  intr_names[vec_no] = name;
c00215a8:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00215ac:	8b 55 18             	mov    0x18(%ebp),%edx
c00215af:	89 14 85 40 46 03 c0 	mov    %edx,-0x3ffcb9c0(,%eax,4)
}
c00215b6:	90                   	nop
c00215b7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00215ba:	c9                   	leave  
c00215bb:	c3                   	ret    

c00215bc <intr_register_ext>:
   is named NAME for debugging purposes.  The handler will
   execute with interrupts disabled. */
void
intr_register_ext (uint8_t vec_no, intr_handler_func *handler,
                   const char *name) 
{
c00215bc:	55                   	push   %ebp
c00215bd:	89 e5                	mov    %esp,%ebp
c00215bf:	83 ec 18             	sub    $0x18,%esp
c00215c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00215c5:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c00215c8:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c00215cc:	76 06                	jbe    c00215d4 <intr_register_ext+0x18>
c00215ce:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c00215d2:	76 21                	jbe    c00215f5 <intr_register_ext+0x39>
c00215d4:	83 ec 0c             	sub    $0xc,%esp
c00215d7:	68 38 ed 02 c0       	push   $0xc002ed38
c00215dc:	68 d9 ea 02 c0       	push   $0xc002ead9
c00215e1:	68 f8 ee 02 c0       	push   $0xc002eef8
c00215e6:	68 b8 00 00 00       	push   $0xb8
c00215eb:	68 f0 ea 02 c0       	push   $0xc002eaf0
c00215f0:	e8 29 7f 00 00       	call   c002951e <debug_panic>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c00215f5:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00215f9:	83 ec 0c             	sub    $0xc,%esp
c00215fc:	ff 75 10             	push   0x10(%ebp)
c00215ff:	ff 75 0c             	push   0xc(%ebp)
c0021602:	6a 00                	push   $0x0
c0021604:	6a 00                	push   $0x0
c0021606:	50                   	push   %eax
c0021607:	e8 f1 fe ff ff       	call   c00214fd <register_handler>
c002160c:	83 c4 20             	add    $0x20,%esp
}
c002160f:	90                   	nop
c0021610:	c9                   	leave  
c0021611:	c3                   	ret    

c0021612 <intr_register_int>:
   "Accessing Nonconforming Code Segments" for further
   discussion. */
void
intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,
                   intr_handler_func *handler, const char *name)
{
c0021612:	55                   	push   %ebp
c0021613:	89 e5                	mov    %esp,%ebp
c0021615:	83 ec 18             	sub    $0x18,%esp
c0021618:	8b 45 08             	mov    0x8(%ebp),%eax
c002161b:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c002161e:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c0021622:	76 27                	jbe    c002164b <intr_register_int+0x39>
c0021624:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c0021628:	77 21                	ja     c002164b <intr_register_int+0x39>
c002162a:	83 ec 0c             	sub    $0xc,%esp
c002162d:	68 5c ed 02 c0       	push   $0xc002ed5c
c0021632:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021637:	68 0c ef 02 c0       	push   $0xc002ef0c
c002163c:	68 cd 00 00 00       	push   $0xcd
c0021641:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021646:	e8 d3 7e 00 00       	call   c002951e <debug_panic>
  register_handler (vec_no, dpl, level, handler, name);
c002164b:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002164f:	83 ec 0c             	sub    $0xc,%esp
c0021652:	ff 75 18             	push   0x18(%ebp)
c0021655:	ff 75 14             	push   0x14(%ebp)
c0021658:	ff 75 10             	push   0x10(%ebp)
c002165b:	ff 75 0c             	push   0xc(%ebp)
c002165e:	50                   	push   %eax
c002165f:	e8 99 fe ff ff       	call   c00214fd <register_handler>
c0021664:	83 c4 20             	add    $0x20,%esp
}
c0021667:	90                   	nop
c0021668:	c9                   	leave  
c0021669:	c3                   	ret    

c002166a <intr_context>:

/* Returns true during processing of an external interrupt
   and false at all other times. */
bool
intr_context (void) 
{
c002166a:	55                   	push   %ebp
c002166b:	89 e5                	mov    %esp,%ebp
  return in_external_intr;
c002166d:	a0 40 4e 03 c0       	mov    0xc0034e40,%al
}
c0021672:	5d                   	pop    %ebp
c0021673:	c3                   	ret    

c0021674 <intr_yield_on_return>:
   interrupt handler to yield to a new process just before
   returning from the interrupt.  May not be called at any other
   time. */
void
intr_yield_on_return (void) 
{
c0021674:	55                   	push   %ebp
c0021675:	89 e5                	mov    %esp,%ebp
c0021677:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_context ());
c002167a:	e8 eb ff ff ff       	call   c002166a <intr_context>
c002167f:	84 c0                	test   %al,%al
c0021681:	75 21                	jne    c00216a4 <intr_yield_on_return+0x30>
c0021683:	83 ec 0c             	sub    $0xc,%esp
c0021686:	68 7b ed 02 c0       	push   $0xc002ed7b
c002168b:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021690:	68 20 ef 02 c0       	push   $0xc002ef20
c0021695:	68 e0 00 00 00       	push   $0xe0
c002169a:	68 f0 ea 02 c0       	push   $0xc002eaf0
c002169f:	e8 7a 7e 00 00       	call   c002951e <debug_panic>
  yield_on_return = true;
c00216a4:	c6 05 41 4e 03 c0 01 	movb   $0x1,0xc0034e41
}
c00216ab:	90                   	nop
c00216ac:	c9                   	leave  
c00216ad:	c3                   	ret    

c00216ae <pic_init>:
   traps and exceptions, so we reprogram the PICs so that
   interrupts 0...15 are delivered to interrupt vectors 32...47
   (0x20...0x2f) instead. */
static void
pic_init (void)
{
c00216ae:	55                   	push   %ebp
c00216af:	89 e5                	mov    %esp,%ebp
  /* Mask all interrupts on both PICs. */
  outb (PIC0_DATA, 0xff);
c00216b1:	68 ff 00 00 00       	push   $0xff
c00216b6:	6a 21                	push   $0x21
c00216b8:	e8 53 fc ff ff       	call   c0021310 <outb>
c00216bd:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0xff);
c00216c0:	68 ff 00 00 00       	push   $0xff
c00216c5:	68 a1 00 00 00       	push   $0xa1
c00216ca:	e8 41 fc ff ff       	call   c0021310 <outb>
c00216cf:	83 c4 08             	add    $0x8,%esp

  /* Initialize master. */
  outb (PIC0_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c00216d2:	6a 11                	push   $0x11
c00216d4:	6a 20                	push   $0x20
c00216d6:	e8 35 fc ff ff       	call   c0021310 <outb>
c00216db:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x20); /* ICW2: line IR0...7 -> irq 0x20...0x27. */
c00216de:	6a 20                	push   $0x20
c00216e0:	6a 21                	push   $0x21
c00216e2:	e8 29 fc ff ff       	call   c0021310 <outb>
c00216e7:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x04); /* ICW3: slave PIC on line IR2. */
c00216ea:	6a 04                	push   $0x4
c00216ec:	6a 21                	push   $0x21
c00216ee:	e8 1d fc ff ff       	call   c0021310 <outb>
c00216f3:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c00216f6:	6a 01                	push   $0x1
c00216f8:	6a 21                	push   $0x21
c00216fa:	e8 11 fc ff ff       	call   c0021310 <outb>
c00216ff:	83 c4 08             	add    $0x8,%esp

  /* Initialize slave. */
  outb (PIC1_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c0021702:	6a 11                	push   $0x11
c0021704:	68 a0 00 00 00       	push   $0xa0
c0021709:	e8 02 fc ff ff       	call   c0021310 <outb>
c002170e:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x28); /* ICW2: line IR0...7 -> irq 0x28...0x2f. */
c0021711:	6a 28                	push   $0x28
c0021713:	68 a1 00 00 00       	push   $0xa1
c0021718:	e8 f3 fb ff ff       	call   c0021310 <outb>
c002171d:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x02); /* ICW3: slave ID is 2. */
c0021720:	6a 02                	push   $0x2
c0021722:	68 a1 00 00 00       	push   $0xa1
c0021727:	e8 e4 fb ff ff       	call   c0021310 <outb>
c002172c:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c002172f:	6a 01                	push   $0x1
c0021731:	68 a1 00 00 00       	push   $0xa1
c0021736:	e8 d5 fb ff ff       	call   c0021310 <outb>
c002173b:	83 c4 08             	add    $0x8,%esp

  /* Unmask all interrupts. */
  outb (PIC0_DATA, 0x00);
c002173e:	6a 00                	push   $0x0
c0021740:	6a 21                	push   $0x21
c0021742:	e8 c9 fb ff ff       	call   c0021310 <outb>
c0021747:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x00);
c002174a:	6a 00                	push   $0x0
c002174c:	68 a1 00 00 00       	push   $0xa1
c0021751:	e8 ba fb ff ff       	call   c0021310 <outb>
c0021756:	83 c4 08             	add    $0x8,%esp
}
c0021759:	90                   	nop
c002175a:	c9                   	leave  
c002175b:	c3                   	ret    

c002175c <pic_end_of_interrupt>:
/* Sends an end-of-interrupt signal to the PIC for the given IRQ.
   If we don't acknowledge the IRQ, it will never be delivered to
   us again, so this is important.  */
static void
pic_end_of_interrupt (int irq) 
{
c002175c:	55                   	push   %ebp
c002175d:	89 e5                	mov    %esp,%ebp
c002175f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021762:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c0021766:	7e 06                	jle    c002176e <pic_end_of_interrupt+0x12>
c0021768:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c002176c:	7e 21                	jle    c002178f <pic_end_of_interrupt+0x33>
c002176e:	83 ec 0c             	sub    $0xc,%esp
c0021771:	68 8b ed 02 c0       	push   $0xc002ed8b
c0021776:	68 d9 ea 02 c0       	push   $0xc002ead9
c002177b:	68 38 ef 02 c0       	push   $0xc002ef38
c0021780:	68 0b 01 00 00       	push   $0x10b
c0021785:	68 f0 ea 02 c0       	push   $0xc002eaf0
c002178a:	e8 8f 7d 00 00       	call   c002951e <debug_panic>

  /* Acknowledge master PIC. */
  outb (0x20, 0x20);
c002178f:	83 ec 08             	sub    $0x8,%esp
c0021792:	6a 20                	push   $0x20
c0021794:	6a 20                	push   $0x20
c0021796:	e8 75 fb ff ff       	call   c0021310 <outb>
c002179b:	83 c4 10             	add    $0x10,%esp

  /* Acknowledge slave PIC if this is a slave interrupt. */
  if (irq >= 0x28)
c002179e:	83 7d 08 27          	cmpl   $0x27,0x8(%ebp)
c00217a2:	7e 12                	jle    c00217b6 <pic_end_of_interrupt+0x5a>
    outb (0xa0, 0x20);
c00217a4:	83 ec 08             	sub    $0x8,%esp
c00217a7:	6a 20                	push   $0x20
c00217a9:	68 a0 00 00 00       	push   $0xa0
c00217ae:	e8 5d fb ff ff       	call   c0021310 <outb>
c00217b3:	83 c4 10             	add    $0x10,%esp
}
c00217b6:	90                   	nop
c00217b7:	c9                   	leave  
c00217b8:	c3                   	ret    

c00217b9 <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c00217b9:	55                   	push   %ebp
c00217ba:	89 e5                	mov    %esp,%ebp
c00217bc:	57                   	push   %edi
c00217bd:	56                   	push   %esi
c00217be:	53                   	push   %ebx
c00217bf:	83 ec 2c             	sub    $0x2c,%esp
  uint32_t e0, e1;

  ASSERT (function != NULL);
c00217c2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00217c6:	75 21                	jne    c00217e9 <make_gate+0x30>
c00217c8:	83 ec 0c             	sub    $0xc,%esp
c00217cb:	68 a5 ed 02 c0       	push   $0xc002eda5
c00217d0:	68 d9 ea 02 c0       	push   $0xc002ead9
c00217d5:	68 50 ef 02 c0       	push   $0xc002ef50
c00217da:	68 2a 01 00 00       	push   $0x12a
c00217df:	68 f0 ea 02 c0       	push   $0xc002eaf0
c00217e4:	e8 35 7d 00 00       	call   c002951e <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c00217e9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00217ed:	78 06                	js     c00217f5 <make_gate+0x3c>
c00217ef:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c00217f3:	7e 21                	jle    c0021816 <make_gate+0x5d>
c00217f5:	83 ec 0c             	sub    $0xc,%esp
c00217f8:	68 b6 ed 02 c0       	push   $0xc002edb6
c00217fd:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021802:	68 50 ef 02 c0       	push   $0xc002ef50
c0021807:	68 2b 01 00 00       	push   $0x12b
c002180c:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021811:	e8 08 7d 00 00       	call   c002951e <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c0021816:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002181a:	78 06                	js     c0021822 <make_gate+0x69>
c002181c:	83 7d 10 0f          	cmpl   $0xf,0x10(%ebp)
c0021820:	7e 21                	jle    c0021843 <make_gate+0x8a>
c0021822:	83 ec 0c             	sub    $0xc,%esp
c0021825:	68 cb ed 02 c0       	push   $0xc002edcb
c002182a:	68 d9 ea 02 c0       	push   $0xc002ead9
c002182f:	68 50 ef 02 c0       	push   $0xc002ef50
c0021834:	68 2c 01 00 00       	push   $0x12c
c0021839:	68 f0 ea 02 c0       	push   $0xc002eaf0
c002183e:	e8 db 7c 00 00       	call   c002951e <debug_panic>

  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c0021843:	8b 45 08             	mov    0x8(%ebp),%eax
c0021846:	0f b7 c0             	movzwl %ax,%eax
c0021849:	0d 00 00 08 00       	or     $0x80000,%eax
c002184e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        | (SEL_KCSEG << 16));              /* Target code segment. */

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021851:	8b 45 08             	mov    0x8(%ebp),%eax
c0021854:	25 00 00 ff ff       	and    $0xffff0000,%eax
c0021859:	89 c2                	mov    %eax,%edx
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c002185b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002185e:	c1 e0 0d             	shl    $0xd,%eax
c0021861:	09 c2                	or     %eax,%edx
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c0021863:	8b 45 10             	mov    0x10(%ebp),%eax
c0021866:	c1 e0 08             	shl    $0x8,%eax
c0021869:	09 d0                	or     %edx,%eax
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c002186b:	80 cc 80             	or     $0x80,%ah
c002186e:	89 45 e0             	mov    %eax,-0x20(%ebp)

  return e0 | ((uint64_t) e1 << 32);
c0021871:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c0021874:	bf 00 00 00 00       	mov    $0x0,%edi
c0021879:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002187c:	ba 00 00 00 00       	mov    $0x0,%edx
c0021881:	89 c2                	mov    %eax,%edx
c0021883:	b8 00 00 00 00       	mov    $0x0,%eax
c0021888:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002188b:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c002188e:	89 f0                	mov    %esi,%eax
c0021890:	0b 45 d0             	or     -0x30(%ebp),%eax
c0021893:	89 c1                	mov    %eax,%ecx
c0021895:	89 f8                	mov    %edi,%eax
c0021897:	0b 45 d4             	or     -0x2c(%ebp),%eax
c002189a:	89 c3                	mov    %eax,%ebx
c002189c:	89 c8                	mov    %ecx,%eax
c002189e:	89 da                	mov    %ebx,%edx
}
c00218a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00218a3:	5b                   	pop    %ebx
c00218a4:	5e                   	pop    %esi
c00218a5:	5f                   	pop    %edi
c00218a6:	5d                   	pop    %ebp
c00218a7:	c3                   	ret    

c00218a8 <make_intr_gate>:

/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
c00218a8:	55                   	push   %ebp
c00218a9:	89 e5                	mov    %esp,%ebp
c00218ab:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 14);
c00218ae:	83 ec 04             	sub    $0x4,%esp
c00218b1:	6a 0e                	push   $0xe
c00218b3:	ff 75 0c             	push   0xc(%ebp)
c00218b6:	ff 75 08             	push   0x8(%ebp)
c00218b9:	e8 fb fe ff ff       	call   c00217b9 <make_gate>
c00218be:	83 c4 10             	add    $0x10,%esp
}
c00218c1:	c9                   	leave  
c00218c2:	c3                   	ret    

c00218c3 <make_trap_gate>:

/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
c00218c3:	55                   	push   %ebp
c00218c4:	89 e5                	mov    %esp,%ebp
c00218c6:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 15);
c00218c9:	83 ec 04             	sub    $0x4,%esp
c00218cc:	6a 0f                	push   $0xf
c00218ce:	ff 75 0c             	push   0xc(%ebp)
c00218d1:	ff 75 08             	push   0x8(%ebp)
c00218d4:	e8 e0 fe ff ff       	call   c00217b9 <make_gate>
c00218d9:	83 c4 10             	add    $0x10,%esp
}
c00218dc:	c9                   	leave  
c00218dd:	c3                   	ret    

c00218de <make_idtr_operand>:

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
c00218de:	55                   	push   %ebp
c00218df:	89 e5                	mov    %esp,%ebp
c00218e1:	57                   	push   %edi
c00218e2:	56                   	push   %esi
c00218e3:	53                   	push   %ebx
c00218e4:	83 ec 14             	sub    $0x14,%esp
c00218e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00218ea:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  return limit | ((uint64_t) (uint32_t) base << 16);
c00218ee:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00218f2:	89 c6                	mov    %eax,%esi
c00218f4:	bf 00 00 00 00       	mov    $0x0,%edi
c00218f9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00218fc:	ba 00 00 00 00       	mov    $0x0,%edx
c0021901:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021905:	c1 e0 10             	shl    $0x10,%eax
c0021908:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002190b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c002190e:	89 f0                	mov    %esi,%eax
c0021910:	0b 45 e0             	or     -0x20(%ebp),%eax
c0021913:	89 c1                	mov    %eax,%ecx
c0021915:	89 f8                	mov    %edi,%eax
c0021917:	0b 45 e4             	or     -0x1c(%ebp),%eax
c002191a:	89 c3                	mov    %eax,%ebx
c002191c:	89 c8                	mov    %ecx,%eax
c002191e:	89 da                	mov    %ebx,%edx
}
c0021920:	83 c4 14             	add    $0x14,%esp
c0021923:	5b                   	pop    %ebx
c0021924:	5e                   	pop    %esi
c0021925:	5f                   	pop    %edi
c0021926:	5d                   	pop    %ebp
c0021927:	c3                   	ret    

c0021928 <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c0021928:	55                   	push   %ebp
c0021929:	89 e5                	mov    %esp,%ebp
c002192b:	83 ec 18             	sub    $0x18,%esp

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c002192e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021931:	8b 40 30             	mov    0x30(%eax),%eax
c0021934:	83 f8 1f             	cmp    $0x1f,%eax
c0021937:	76 12                	jbe    c002194b <intr_handler+0x23>
c0021939:	8b 45 08             	mov    0x8(%ebp),%eax
c002193c:	8b 40 30             	mov    0x30(%eax),%eax
c002193f:	83 f8 2f             	cmp    $0x2f,%eax
c0021942:	77 07                	ja     c002194b <intr_handler+0x23>
c0021944:	b8 01 00 00 00       	mov    $0x1,%eax
c0021949:	eb 05                	jmp    c0021950 <intr_handler+0x28>
c002194b:	b8 00 00 00 00       	mov    $0x0,%eax
c0021950:	88 45 f7             	mov    %al,-0x9(%ebp)
c0021953:	80 65 f7 01          	andb   $0x1,-0x9(%ebp)
  if (external) 
c0021957:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c002195b:	74 65                	je     c00219c2 <intr_handler+0x9a>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c002195d:	e8 cd f9 ff ff       	call   c002132f <intr_get_level>
c0021962:	85 c0                	test   %eax,%eax
c0021964:	74 21                	je     c0021987 <intr_handler+0x5f>
c0021966:	83 ec 0c             	sub    $0xc,%esp
c0021969:	68 e3 ed 02 c0       	push   $0xc002ede3
c002196e:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021973:	68 5c ef 02 c0       	push   $0xc002ef5c
c0021978:	68 65 01 00 00       	push   $0x165
c002197d:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021982:	e8 97 7b 00 00       	call   c002951e <debug_panic>
      ASSERT (!intr_context ());
c0021987:	e8 de fc ff ff       	call   c002166a <intr_context>
c002198c:	83 f0 01             	xor    $0x1,%eax
c002198f:	84 c0                	test   %al,%al
c0021991:	75 21                	jne    c00219b4 <intr_handler+0x8c>
c0021993:	83 ec 0c             	sub    $0xc,%esp
c0021996:	68 c8 ea 02 c0       	push   $0xc002eac8
c002199b:	68 d9 ea 02 c0       	push   $0xc002ead9
c00219a0:	68 5c ef 02 c0       	push   $0xc002ef5c
c00219a5:	68 66 01 00 00       	push   $0x166
c00219aa:	68 f0 ea 02 c0       	push   $0xc002eaf0
c00219af:	e8 6a 7b 00 00       	call   c002951e <debug_panic>

      in_external_intr = true;
c00219b4:	c6 05 40 4e 03 c0 01 	movb   $0x1,0xc0034e40
      yield_on_return = false;
c00219bb:	c6 05 41 4e 03 c0 00 	movb   $0x0,0xc0034e41
    }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c00219c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00219c5:	8b 40 30             	mov    0x30(%eax),%eax
c00219c8:	8b 04 85 40 42 03 c0 	mov    -0x3ffcbdc0(,%eax,4),%eax
c00219cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (handler != NULL)
c00219d2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00219d6:	74 10                	je     c00219e8 <intr_handler+0xc0>
    handler (frame);
c00219d8:	83 ec 0c             	sub    $0xc,%esp
c00219db:	ff 75 08             	push   0x8(%ebp)
c00219de:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00219e1:	ff d0                	call   *%eax
c00219e3:	83 c4 10             	add    $0x10,%esp
c00219e6:	eb 24                	jmp    c0021a0c <intr_handler+0xe4>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c00219e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00219eb:	8b 40 30             	mov    0x30(%eax),%eax
c00219ee:	83 f8 27             	cmp    $0x27,%eax
c00219f1:	74 19                	je     c0021a0c <intr_handler+0xe4>
c00219f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00219f6:	8b 40 30             	mov    0x30(%eax),%eax
c00219f9:	83 f8 2f             	cmp    $0x2f,%eax
c00219fc:	74 0e                	je     c0021a0c <intr_handler+0xe4>
      /* There is no handler, but this interrupt can trigger
         spuriously due to a hardware fault or hardware race
         condition.  Ignore it. */
    }
  else
    unexpected_interrupt (frame);
c00219fe:	83 ec 0c             	sub    $0xc,%esp
c0021a01:	ff 75 08             	push   0x8(%ebp)
c0021a04:	e8 87 00 00 00       	call   c0021a90 <unexpected_interrupt>
c0021a09:	83 c4 10             	add    $0x10,%esp

  /* Complete the processing of an external interrupt. */
  if (external) 
c0021a0c:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0021a10:	74 7b                	je     c0021a8d <intr_handler+0x165>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021a12:	e8 18 f9 ff ff       	call   c002132f <intr_get_level>
c0021a17:	85 c0                	test   %eax,%eax
c0021a19:	74 21                	je     c0021a3c <intr_handler+0x114>
c0021a1b:	83 ec 0c             	sub    $0xc,%esp
c0021a1e:	68 e3 ed 02 c0       	push   $0xc002ede3
c0021a23:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021a28:	68 5c ef 02 c0       	push   $0xc002ef5c
c0021a2d:	68 7c 01 00 00       	push   $0x17c
c0021a32:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021a37:	e8 e2 7a 00 00       	call   c002951e <debug_panic>
      ASSERT (intr_context ());
c0021a3c:	e8 29 fc ff ff       	call   c002166a <intr_context>
c0021a41:	84 c0                	test   %al,%al
c0021a43:	75 21                	jne    c0021a66 <intr_handler+0x13e>
c0021a45:	83 ec 0c             	sub    $0xc,%esp
c0021a48:	68 7b ed 02 c0       	push   $0xc002ed7b
c0021a4d:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021a52:	68 5c ef 02 c0       	push   $0xc002ef5c
c0021a57:	68 7d 01 00 00       	push   $0x17d
c0021a5c:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021a61:	e8 b8 7a 00 00       	call   c002951e <debug_panic>

      in_external_intr = false;
c0021a66:	c6 05 40 4e 03 c0 00 	movb   $0x0,0xc0034e40
      pic_end_of_interrupt (frame->vec_no); 
c0021a6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a70:	8b 40 30             	mov    0x30(%eax),%eax
c0021a73:	83 ec 0c             	sub    $0xc,%esp
c0021a76:	50                   	push   %eax
c0021a77:	e8 e0 fc ff ff       	call   c002175c <pic_end_of_interrupt>
c0021a7c:	83 c4 10             	add    $0x10,%esp

      if (yield_on_return) 
c0021a7f:	a0 41 4e 03 c0       	mov    0xc0034e41,%al
c0021a84:	84 c0                	test   %al,%al
c0021a86:	74 05                	je     c0021a8d <intr_handler+0x165>
        thread_yield (); 
c0021a88:	e8 e1 f2 ff ff       	call   c0020d6e <thread_yield>
    }
}
c0021a8d:	90                   	nop
c0021a8e:	c9                   	leave  
c0021a8f:	c3                   	ret    

c0021a90 <unexpected_interrupt>:

/* Handles an unexpected interrupt with interrupt frame F.  An
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
c0021a90:	55                   	push   %ebp
c0021a91:	89 e5                	mov    %esp,%ebp
c0021a93:	83 ec 18             	sub    $0x18,%esp
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c0021a96:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a99:	8b 40 30             	mov    0x30(%eax),%eax
c0021a9c:	8b 14 85 40 4a 03 c0 	mov    -0x3ffcb5c0(,%eax,4),%edx
c0021aa3:	42                   	inc    %edx
c0021aa4:	89 14 85 40 4a 03 c0 	mov    %edx,-0x3ffcb5c0(,%eax,4)
c0021aab:	8b 04 85 40 4a 03 c0 	mov    -0x3ffcb5c0(,%eax,4),%eax
c0021ab2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c0021ab5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021ab8:	48                   	dec    %eax
c0021ab9:	23 45 f4             	and    -0xc(%ebp),%eax
c0021abc:	85 c0                	test   %eax,%eax
c0021abe:	75 25                	jne    c0021ae5 <unexpected_interrupt+0x55>
    printf ("Unexpected interrupt %#04x (%s)\n",
    f->vec_no, intr_names[f->vec_no]);
c0021ac0:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ac3:	8b 40 30             	mov    0x30(%eax),%eax
    printf ("Unexpected interrupt %#04x (%s)\n",
c0021ac6:	8b 14 85 40 46 03 c0 	mov    -0x3ffcb9c0(,%eax,4),%edx
c0021acd:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ad0:	8b 40 30             	mov    0x30(%eax),%eax
c0021ad3:	83 ec 04             	sub    $0x4,%esp
c0021ad6:	52                   	push   %edx
c0021ad7:	50                   	push   %eax
c0021ad8:	68 04 ee 02 c0       	push   $0xc002ee04
c0021add:	e8 9a 56 00 00       	call   c002717c <printf>
c0021ae2:	83 c4 10             	add    $0x10,%esp
}
c0021ae5:	90                   	nop
c0021ae6:	c9                   	leave  
c0021ae7:	c3                   	ret    

c0021ae8 <intr_dump_frame>:

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c0021ae8:	55                   	push   %ebp
c0021ae9:	89 e5                	mov    %esp,%ebp
c0021aeb:	53                   	push   %ebx
c0021aec:	83 ec 14             	sub    $0x14,%esp
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c0021aef:	0f 20 d0             	mov    %cr2,%eax
c0021af2:	89 45 f4             	mov    %eax,-0xc(%ebp)

  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021af5:	8b 45 08             	mov    0x8(%ebp),%eax
c0021af8:	8b 48 3c             	mov    0x3c(%eax),%ecx
          f->vec_no, intr_names[f->vec_no], f->eip);
c0021afb:	8b 45 08             	mov    0x8(%ebp),%eax
c0021afe:	8b 40 30             	mov    0x30(%eax),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021b01:	8b 14 85 40 46 03 c0 	mov    -0x3ffcb9c0(,%eax,4),%edx
c0021b08:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b0b:	8b 40 30             	mov    0x30(%eax),%eax
c0021b0e:	51                   	push   %ecx
c0021b0f:	52                   	push   %edx
c0021b10:	50                   	push   %eax
c0021b11:	68 28 ee 02 c0       	push   $0xc002ee28
c0021b16:	e8 61 56 00 00       	call   c002717c <printf>
c0021b1b:	83 c4 10             	add    $0x10,%esp
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0021b1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b21:	8b 40 34             	mov    0x34(%eax),%eax
c0021b24:	83 ec 04             	sub    $0x4,%esp
c0021b27:	50                   	push   %eax
c0021b28:	ff 75 f4             	push   -0xc(%ebp)
c0021b2b:	68 48 ee 02 c0       	push   $0xc002ee48
c0021b30:	e8 47 56 00 00       	call   c002717c <printf>
c0021b35:	83 c4 10             	add    $0x10,%esp
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0021b38:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b3b:	8b 58 14             	mov    0x14(%eax),%ebx
c0021b3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b41:	8b 48 18             	mov    0x18(%eax),%ecx
c0021b44:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b47:	8b 50 10             	mov    0x10(%eax),%edx
c0021b4a:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b4d:	8b 40 1c             	mov    0x1c(%eax),%eax
c0021b50:	83 ec 0c             	sub    $0xc,%esp
c0021b53:	53                   	push   %ebx
c0021b54:	51                   	push   %ecx
c0021b55:	52                   	push   %edx
c0021b56:	50                   	push   %eax
c0021b57:	68 60 ee 02 c0       	push   $0xc002ee60
c0021b5c:	e8 1b 56 00 00       	call   c002717c <printf>
c0021b61:	83 c4 20             	add    $0x20,%esp
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021b64:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b67:	8b 48 08             	mov    0x8(%eax),%ecx
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
c0021b6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b6d:	8b 40 48             	mov    0x48(%eax),%eax
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021b70:	89 c3                	mov    %eax,%ebx
c0021b72:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b75:	8b 10                	mov    (%eax),%edx
c0021b77:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b7a:	8b 40 04             	mov    0x4(%eax),%eax
c0021b7d:	83 ec 0c             	sub    $0xc,%esp
c0021b80:	51                   	push   %ecx
c0021b81:	53                   	push   %ebx
c0021b82:	52                   	push   %edx
c0021b83:	50                   	push   %eax
c0021b84:	68 88 ee 02 c0       	push   $0xc002ee88
c0021b89:	e8 ee 55 00 00       	call   c002717c <printf>
c0021b8e:	83 c4 20             	add    $0x20,%esp
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
          f->cs, f->ds, f->es, f->ss);
c0021b91:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b94:	8b 40 4c             	mov    0x4c(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021b97:	0f b7 d8             	movzwl %ax,%ebx
          f->cs, f->ds, f->es, f->ss);
c0021b9a:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b9d:	8b 40 28             	mov    0x28(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021ba0:	0f b7 c8             	movzwl %ax,%ecx
          f->cs, f->ds, f->es, f->ss);
c0021ba3:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ba6:	8b 40 2c             	mov    0x2c(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021ba9:	0f b7 d0             	movzwl %ax,%edx
          f->cs, f->ds, f->es, f->ss);
c0021bac:	8b 45 08             	mov    0x8(%ebp),%eax
c0021baf:	8b 40 40             	mov    0x40(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021bb2:	0f b7 c0             	movzwl %ax,%eax
c0021bb5:	83 ec 0c             	sub    $0xc,%esp
c0021bb8:	53                   	push   %ebx
c0021bb9:	51                   	push   %ecx
c0021bba:	52                   	push   %edx
c0021bbb:	50                   	push   %eax
c0021bbc:	68 b0 ee 02 c0       	push   $0xc002eeb0
c0021bc1:	e8 b6 55 00 00       	call   c002717c <printf>
c0021bc6:	83 c4 20             	add    $0x20,%esp
}
c0021bc9:	90                   	nop
c0021bca:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021bcd:	c9                   	leave  
c0021bce:	c3                   	ret    

c0021bcf <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
c0021bcf:	55                   	push   %ebp
c0021bd0:	89 e5                	mov    %esp,%ebp
c0021bd2:	83 ec 04             	sub    $0x4,%esp
c0021bd5:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bd8:	88 45 fc             	mov    %al,-0x4(%ebp)
  return intr_names[vec];
c0021bdb:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0021bdf:	8b 04 85 40 46 03 c0 	mov    -0x3ffcb9c0(,%eax,4),%eax
}
c0021be6:	c9                   	leave  
c0021be7:	c3                   	ret    

c0021be8 <intr_entry>:
c0021be8:	1e                   	push   %ds
c0021be9:	06                   	push   %es
c0021bea:	0f a0                	push   %fs
c0021bec:	0f a8                	push   %gs
c0021bee:	60                   	pusha  
c0021bef:	fc                   	cld    
c0021bf0:	b8 10 00 00 00       	mov    $0x10,%eax
c0021bf5:	8e d8                	mov    %eax,%ds
c0021bf7:	8e c0                	mov    %eax,%es
c0021bf9:	8d 6c 24 38          	lea    0x38(%esp),%ebp
c0021bfd:	54                   	push   %esp
c0021bfe:	e8 25 fd ff ff       	call   c0021928 <intr_handler>
c0021c03:	83 c4 04             	add    $0x4,%esp

c0021c06 <intr_exit>:
c0021c06:	61                   	popa   
c0021c07:	0f a9                	pop    %gs
c0021c09:	0f a1                	pop    %fs
c0021c0b:	07                   	pop    %es
c0021c0c:	1f                   	pop    %ds
c0021c0d:	83 c4 0c             	add    $0xc,%esp
c0021c10:	cf                   	iret   

c0021c11 <intr00_stub>:
c0021c11:	55                   	push   %ebp
c0021c12:	6a 00                	push   $0x0
c0021c14:	6a 00                	push   $0x0
c0021c16:	eb d0                	jmp    c0021be8 <intr_entry>

c0021c18 <intr01_stub>:
c0021c18:	55                   	push   %ebp
c0021c19:	6a 00                	push   $0x0
c0021c1b:	6a 01                	push   $0x1
c0021c1d:	eb c9                	jmp    c0021be8 <intr_entry>

c0021c1f <intr02_stub>:
c0021c1f:	55                   	push   %ebp
c0021c20:	6a 00                	push   $0x0
c0021c22:	6a 02                	push   $0x2
c0021c24:	eb c2                	jmp    c0021be8 <intr_entry>

c0021c26 <intr03_stub>:
c0021c26:	55                   	push   %ebp
c0021c27:	6a 00                	push   $0x0
c0021c29:	6a 03                	push   $0x3
c0021c2b:	eb bb                	jmp    c0021be8 <intr_entry>

c0021c2d <intr04_stub>:
c0021c2d:	55                   	push   %ebp
c0021c2e:	6a 00                	push   $0x0
c0021c30:	6a 04                	push   $0x4
c0021c32:	eb b4                	jmp    c0021be8 <intr_entry>

c0021c34 <intr05_stub>:
c0021c34:	55                   	push   %ebp
c0021c35:	6a 00                	push   $0x0
c0021c37:	6a 05                	push   $0x5
c0021c39:	eb ad                	jmp    c0021be8 <intr_entry>

c0021c3b <intr06_stub>:
c0021c3b:	55                   	push   %ebp
c0021c3c:	6a 00                	push   $0x0
c0021c3e:	6a 06                	push   $0x6
c0021c40:	eb a6                	jmp    c0021be8 <intr_entry>

c0021c42 <intr07_stub>:
c0021c42:	55                   	push   %ebp
c0021c43:	6a 00                	push   $0x0
c0021c45:	6a 07                	push   $0x7
c0021c47:	eb 9f                	jmp    c0021be8 <intr_entry>

c0021c49 <intr08_stub>:
c0021c49:	ff 34 24             	push   (%esp)
c0021c4c:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c50:	6a 08                	push   $0x8
c0021c52:	eb 94                	jmp    c0021be8 <intr_entry>

c0021c54 <intr09_stub>:
c0021c54:	55                   	push   %ebp
c0021c55:	6a 00                	push   $0x0
c0021c57:	6a 09                	push   $0x9
c0021c59:	eb 8d                	jmp    c0021be8 <intr_entry>

c0021c5b <intr0a_stub>:
c0021c5b:	ff 34 24             	push   (%esp)
c0021c5e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c62:	6a 0a                	push   $0xa
c0021c64:	eb 82                	jmp    c0021be8 <intr_entry>

c0021c66 <intr0b_stub>:
c0021c66:	ff 34 24             	push   (%esp)
c0021c69:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c6d:	6a 0b                	push   $0xb
c0021c6f:	e9 74 ff ff ff       	jmp    c0021be8 <intr_entry>

c0021c74 <intr0c_stub>:
c0021c74:	55                   	push   %ebp
c0021c75:	6a 00                	push   $0x0
c0021c77:	6a 0c                	push   $0xc
c0021c79:	e9 6a ff ff ff       	jmp    c0021be8 <intr_entry>

c0021c7e <intr0d_stub>:
c0021c7e:	ff 34 24             	push   (%esp)
c0021c81:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c85:	6a 0d                	push   $0xd
c0021c87:	e9 5c ff ff ff       	jmp    c0021be8 <intr_entry>

c0021c8c <intr0e_stub>:
c0021c8c:	ff 34 24             	push   (%esp)
c0021c8f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c93:	6a 0e                	push   $0xe
c0021c95:	e9 4e ff ff ff       	jmp    c0021be8 <intr_entry>

c0021c9a <intr0f_stub>:
c0021c9a:	55                   	push   %ebp
c0021c9b:	6a 00                	push   $0x0
c0021c9d:	6a 0f                	push   $0xf
c0021c9f:	e9 44 ff ff ff       	jmp    c0021be8 <intr_entry>

c0021ca4 <intr10_stub>:
c0021ca4:	55                   	push   %ebp
c0021ca5:	6a 00                	push   $0x0
c0021ca7:	6a 10                	push   $0x10
c0021ca9:	e9 3a ff ff ff       	jmp    c0021be8 <intr_entry>

c0021cae <intr11_stub>:
c0021cae:	ff 34 24             	push   (%esp)
c0021cb1:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021cb5:	6a 11                	push   $0x11
c0021cb7:	e9 2c ff ff ff       	jmp    c0021be8 <intr_entry>

c0021cbc <intr12_stub>:
c0021cbc:	55                   	push   %ebp
c0021cbd:	6a 00                	push   $0x0
c0021cbf:	6a 12                	push   $0x12
c0021cc1:	e9 22 ff ff ff       	jmp    c0021be8 <intr_entry>

c0021cc6 <intr13_stub>:
c0021cc6:	55                   	push   %ebp
c0021cc7:	6a 00                	push   $0x0
c0021cc9:	6a 13                	push   $0x13
c0021ccb:	e9 18 ff ff ff       	jmp    c0021be8 <intr_entry>

c0021cd0 <intr14_stub>:
c0021cd0:	55                   	push   %ebp
c0021cd1:	6a 00                	push   $0x0
c0021cd3:	6a 14                	push   $0x14
c0021cd5:	e9 0e ff ff ff       	jmp    c0021be8 <intr_entry>

c0021cda <intr15_stub>:
c0021cda:	55                   	push   %ebp
c0021cdb:	6a 00                	push   $0x0
c0021cdd:	6a 15                	push   $0x15
c0021cdf:	e9 04 ff ff ff       	jmp    c0021be8 <intr_entry>

c0021ce4 <intr16_stub>:
c0021ce4:	55                   	push   %ebp
c0021ce5:	6a 00                	push   $0x0
c0021ce7:	6a 16                	push   $0x16
c0021ce9:	e9 fa fe ff ff       	jmp    c0021be8 <intr_entry>

c0021cee <intr17_stub>:
c0021cee:	55                   	push   %ebp
c0021cef:	6a 00                	push   $0x0
c0021cf1:	6a 17                	push   $0x17
c0021cf3:	e9 f0 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021cf8 <intr18_stub>:
c0021cf8:	ff 34 24             	push   (%esp)
c0021cfb:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021cff:	6a 18                	push   $0x18
c0021d01:	e9 e2 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d06 <intr19_stub>:
c0021d06:	55                   	push   %ebp
c0021d07:	6a 00                	push   $0x0
c0021d09:	6a 19                	push   $0x19
c0021d0b:	e9 d8 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d10 <intr1a_stub>:
c0021d10:	ff 34 24             	push   (%esp)
c0021d13:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d17:	6a 1a                	push   $0x1a
c0021d19:	e9 ca fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d1e <intr1b_stub>:
c0021d1e:	ff 34 24             	push   (%esp)
c0021d21:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d25:	6a 1b                	push   $0x1b
c0021d27:	e9 bc fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d2c <intr1c_stub>:
c0021d2c:	55                   	push   %ebp
c0021d2d:	6a 00                	push   $0x0
c0021d2f:	6a 1c                	push   $0x1c
c0021d31:	e9 b2 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d36 <intr1d_stub>:
c0021d36:	ff 34 24             	push   (%esp)
c0021d39:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d3d:	6a 1d                	push   $0x1d
c0021d3f:	e9 a4 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d44 <intr1e_stub>:
c0021d44:	ff 34 24             	push   (%esp)
c0021d47:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d4b:	6a 1e                	push   $0x1e
c0021d4d:	e9 96 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d52 <intr1f_stub>:
c0021d52:	55                   	push   %ebp
c0021d53:	6a 00                	push   $0x0
c0021d55:	6a 1f                	push   $0x1f
c0021d57:	e9 8c fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d5c <intr20_stub>:
c0021d5c:	55                   	push   %ebp
c0021d5d:	6a 00                	push   $0x0
c0021d5f:	6a 20                	push   $0x20
c0021d61:	e9 82 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d66 <intr21_stub>:
c0021d66:	55                   	push   %ebp
c0021d67:	6a 00                	push   $0x0
c0021d69:	6a 21                	push   $0x21
c0021d6b:	e9 78 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d70 <intr22_stub>:
c0021d70:	55                   	push   %ebp
c0021d71:	6a 00                	push   $0x0
c0021d73:	6a 22                	push   $0x22
c0021d75:	e9 6e fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d7a <intr23_stub>:
c0021d7a:	55                   	push   %ebp
c0021d7b:	6a 00                	push   $0x0
c0021d7d:	6a 23                	push   $0x23
c0021d7f:	e9 64 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d84 <intr24_stub>:
c0021d84:	55                   	push   %ebp
c0021d85:	6a 00                	push   $0x0
c0021d87:	6a 24                	push   $0x24
c0021d89:	e9 5a fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d8e <intr25_stub>:
c0021d8e:	55                   	push   %ebp
c0021d8f:	6a 00                	push   $0x0
c0021d91:	6a 25                	push   $0x25
c0021d93:	e9 50 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021d98 <intr26_stub>:
c0021d98:	55                   	push   %ebp
c0021d99:	6a 00                	push   $0x0
c0021d9b:	6a 26                	push   $0x26
c0021d9d:	e9 46 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021da2 <intr27_stub>:
c0021da2:	55                   	push   %ebp
c0021da3:	6a 00                	push   $0x0
c0021da5:	6a 27                	push   $0x27
c0021da7:	e9 3c fe ff ff       	jmp    c0021be8 <intr_entry>

c0021dac <intr28_stub>:
c0021dac:	55                   	push   %ebp
c0021dad:	6a 00                	push   $0x0
c0021daf:	6a 28                	push   $0x28
c0021db1:	e9 32 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021db6 <intr29_stub>:
c0021db6:	55                   	push   %ebp
c0021db7:	6a 00                	push   $0x0
c0021db9:	6a 29                	push   $0x29
c0021dbb:	e9 28 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021dc0 <intr2a_stub>:
c0021dc0:	55                   	push   %ebp
c0021dc1:	6a 00                	push   $0x0
c0021dc3:	6a 2a                	push   $0x2a
c0021dc5:	e9 1e fe ff ff       	jmp    c0021be8 <intr_entry>

c0021dca <intr2b_stub>:
c0021dca:	55                   	push   %ebp
c0021dcb:	6a 00                	push   $0x0
c0021dcd:	6a 2b                	push   $0x2b
c0021dcf:	e9 14 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021dd4 <intr2c_stub>:
c0021dd4:	55                   	push   %ebp
c0021dd5:	6a 00                	push   $0x0
c0021dd7:	6a 2c                	push   $0x2c
c0021dd9:	e9 0a fe ff ff       	jmp    c0021be8 <intr_entry>

c0021dde <intr2d_stub>:
c0021dde:	55                   	push   %ebp
c0021ddf:	6a 00                	push   $0x0
c0021de1:	6a 2d                	push   $0x2d
c0021de3:	e9 00 fe ff ff       	jmp    c0021be8 <intr_entry>

c0021de8 <intr2e_stub>:
c0021de8:	55                   	push   %ebp
c0021de9:	6a 00                	push   $0x0
c0021deb:	6a 2e                	push   $0x2e
c0021ded:	e9 f6 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021df2 <intr2f_stub>:
c0021df2:	55                   	push   %ebp
c0021df3:	6a 00                	push   $0x0
c0021df5:	6a 2f                	push   $0x2f
c0021df7:	e9 ec fd ff ff       	jmp    c0021be8 <intr_entry>

c0021dfc <intr30_stub>:
c0021dfc:	55                   	push   %ebp
c0021dfd:	6a 00                	push   $0x0
c0021dff:	6a 30                	push   $0x30
c0021e01:	e9 e2 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e06 <intr31_stub>:
c0021e06:	55                   	push   %ebp
c0021e07:	6a 00                	push   $0x0
c0021e09:	6a 31                	push   $0x31
c0021e0b:	e9 d8 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e10 <intr32_stub>:
c0021e10:	55                   	push   %ebp
c0021e11:	6a 00                	push   $0x0
c0021e13:	6a 32                	push   $0x32
c0021e15:	e9 ce fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e1a <intr33_stub>:
c0021e1a:	55                   	push   %ebp
c0021e1b:	6a 00                	push   $0x0
c0021e1d:	6a 33                	push   $0x33
c0021e1f:	e9 c4 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e24 <intr34_stub>:
c0021e24:	55                   	push   %ebp
c0021e25:	6a 00                	push   $0x0
c0021e27:	6a 34                	push   $0x34
c0021e29:	e9 ba fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e2e <intr35_stub>:
c0021e2e:	55                   	push   %ebp
c0021e2f:	6a 00                	push   $0x0
c0021e31:	6a 35                	push   $0x35
c0021e33:	e9 b0 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e38 <intr36_stub>:
c0021e38:	55                   	push   %ebp
c0021e39:	6a 00                	push   $0x0
c0021e3b:	6a 36                	push   $0x36
c0021e3d:	e9 a6 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e42 <intr37_stub>:
c0021e42:	55                   	push   %ebp
c0021e43:	6a 00                	push   $0x0
c0021e45:	6a 37                	push   $0x37
c0021e47:	e9 9c fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e4c <intr38_stub>:
c0021e4c:	55                   	push   %ebp
c0021e4d:	6a 00                	push   $0x0
c0021e4f:	6a 38                	push   $0x38
c0021e51:	e9 92 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e56 <intr39_stub>:
c0021e56:	55                   	push   %ebp
c0021e57:	6a 00                	push   $0x0
c0021e59:	6a 39                	push   $0x39
c0021e5b:	e9 88 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e60 <intr3a_stub>:
c0021e60:	55                   	push   %ebp
c0021e61:	6a 00                	push   $0x0
c0021e63:	6a 3a                	push   $0x3a
c0021e65:	e9 7e fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e6a <intr3b_stub>:
c0021e6a:	55                   	push   %ebp
c0021e6b:	6a 00                	push   $0x0
c0021e6d:	6a 3b                	push   $0x3b
c0021e6f:	e9 74 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e74 <intr3c_stub>:
c0021e74:	55                   	push   %ebp
c0021e75:	6a 00                	push   $0x0
c0021e77:	6a 3c                	push   $0x3c
c0021e79:	e9 6a fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e7e <intr3d_stub>:
c0021e7e:	55                   	push   %ebp
c0021e7f:	6a 00                	push   $0x0
c0021e81:	6a 3d                	push   $0x3d
c0021e83:	e9 60 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e88 <intr3e_stub>:
c0021e88:	55                   	push   %ebp
c0021e89:	6a 00                	push   $0x0
c0021e8b:	6a 3e                	push   $0x3e
c0021e8d:	e9 56 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e92 <intr3f_stub>:
c0021e92:	55                   	push   %ebp
c0021e93:	6a 00                	push   $0x0
c0021e95:	6a 3f                	push   $0x3f
c0021e97:	e9 4c fd ff ff       	jmp    c0021be8 <intr_entry>

c0021e9c <intr40_stub>:
c0021e9c:	55                   	push   %ebp
c0021e9d:	6a 00                	push   $0x0
c0021e9f:	6a 40                	push   $0x40
c0021ea1:	e9 42 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021ea6 <intr41_stub>:
c0021ea6:	55                   	push   %ebp
c0021ea7:	6a 00                	push   $0x0
c0021ea9:	6a 41                	push   $0x41
c0021eab:	e9 38 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021eb0 <intr42_stub>:
c0021eb0:	55                   	push   %ebp
c0021eb1:	6a 00                	push   $0x0
c0021eb3:	6a 42                	push   $0x42
c0021eb5:	e9 2e fd ff ff       	jmp    c0021be8 <intr_entry>

c0021eba <intr43_stub>:
c0021eba:	55                   	push   %ebp
c0021ebb:	6a 00                	push   $0x0
c0021ebd:	6a 43                	push   $0x43
c0021ebf:	e9 24 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021ec4 <intr44_stub>:
c0021ec4:	55                   	push   %ebp
c0021ec5:	6a 00                	push   $0x0
c0021ec7:	6a 44                	push   $0x44
c0021ec9:	e9 1a fd ff ff       	jmp    c0021be8 <intr_entry>

c0021ece <intr45_stub>:
c0021ece:	55                   	push   %ebp
c0021ecf:	6a 00                	push   $0x0
c0021ed1:	6a 45                	push   $0x45
c0021ed3:	e9 10 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021ed8 <intr46_stub>:
c0021ed8:	55                   	push   %ebp
c0021ed9:	6a 00                	push   $0x0
c0021edb:	6a 46                	push   $0x46
c0021edd:	e9 06 fd ff ff       	jmp    c0021be8 <intr_entry>

c0021ee2 <intr47_stub>:
c0021ee2:	55                   	push   %ebp
c0021ee3:	6a 00                	push   $0x0
c0021ee5:	6a 47                	push   $0x47
c0021ee7:	e9 fc fc ff ff       	jmp    c0021be8 <intr_entry>

c0021eec <intr48_stub>:
c0021eec:	55                   	push   %ebp
c0021eed:	6a 00                	push   $0x0
c0021eef:	6a 48                	push   $0x48
c0021ef1:	e9 f2 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021ef6 <intr49_stub>:
c0021ef6:	55                   	push   %ebp
c0021ef7:	6a 00                	push   $0x0
c0021ef9:	6a 49                	push   $0x49
c0021efb:	e9 e8 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f00 <intr4a_stub>:
c0021f00:	55                   	push   %ebp
c0021f01:	6a 00                	push   $0x0
c0021f03:	6a 4a                	push   $0x4a
c0021f05:	e9 de fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f0a <intr4b_stub>:
c0021f0a:	55                   	push   %ebp
c0021f0b:	6a 00                	push   $0x0
c0021f0d:	6a 4b                	push   $0x4b
c0021f0f:	e9 d4 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f14 <intr4c_stub>:
c0021f14:	55                   	push   %ebp
c0021f15:	6a 00                	push   $0x0
c0021f17:	6a 4c                	push   $0x4c
c0021f19:	e9 ca fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f1e <intr4d_stub>:
c0021f1e:	55                   	push   %ebp
c0021f1f:	6a 00                	push   $0x0
c0021f21:	6a 4d                	push   $0x4d
c0021f23:	e9 c0 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f28 <intr4e_stub>:
c0021f28:	55                   	push   %ebp
c0021f29:	6a 00                	push   $0x0
c0021f2b:	6a 4e                	push   $0x4e
c0021f2d:	e9 b6 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f32 <intr4f_stub>:
c0021f32:	55                   	push   %ebp
c0021f33:	6a 00                	push   $0x0
c0021f35:	6a 4f                	push   $0x4f
c0021f37:	e9 ac fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f3c <intr50_stub>:
c0021f3c:	55                   	push   %ebp
c0021f3d:	6a 00                	push   $0x0
c0021f3f:	6a 50                	push   $0x50
c0021f41:	e9 a2 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f46 <intr51_stub>:
c0021f46:	55                   	push   %ebp
c0021f47:	6a 00                	push   $0x0
c0021f49:	6a 51                	push   $0x51
c0021f4b:	e9 98 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f50 <intr52_stub>:
c0021f50:	55                   	push   %ebp
c0021f51:	6a 00                	push   $0x0
c0021f53:	6a 52                	push   $0x52
c0021f55:	e9 8e fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f5a <intr53_stub>:
c0021f5a:	55                   	push   %ebp
c0021f5b:	6a 00                	push   $0x0
c0021f5d:	6a 53                	push   $0x53
c0021f5f:	e9 84 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f64 <intr54_stub>:
c0021f64:	55                   	push   %ebp
c0021f65:	6a 00                	push   $0x0
c0021f67:	6a 54                	push   $0x54
c0021f69:	e9 7a fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f6e <intr55_stub>:
c0021f6e:	55                   	push   %ebp
c0021f6f:	6a 00                	push   $0x0
c0021f71:	6a 55                	push   $0x55
c0021f73:	e9 70 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f78 <intr56_stub>:
c0021f78:	55                   	push   %ebp
c0021f79:	6a 00                	push   $0x0
c0021f7b:	6a 56                	push   $0x56
c0021f7d:	e9 66 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f82 <intr57_stub>:
c0021f82:	55                   	push   %ebp
c0021f83:	6a 00                	push   $0x0
c0021f85:	6a 57                	push   $0x57
c0021f87:	e9 5c fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f8c <intr58_stub>:
c0021f8c:	55                   	push   %ebp
c0021f8d:	6a 00                	push   $0x0
c0021f8f:	6a 58                	push   $0x58
c0021f91:	e9 52 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021f96 <intr59_stub>:
c0021f96:	55                   	push   %ebp
c0021f97:	6a 00                	push   $0x0
c0021f99:	6a 59                	push   $0x59
c0021f9b:	e9 48 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021fa0 <intr5a_stub>:
c0021fa0:	55                   	push   %ebp
c0021fa1:	6a 00                	push   $0x0
c0021fa3:	6a 5a                	push   $0x5a
c0021fa5:	e9 3e fc ff ff       	jmp    c0021be8 <intr_entry>

c0021faa <intr5b_stub>:
c0021faa:	55                   	push   %ebp
c0021fab:	6a 00                	push   $0x0
c0021fad:	6a 5b                	push   $0x5b
c0021faf:	e9 34 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021fb4 <intr5c_stub>:
c0021fb4:	55                   	push   %ebp
c0021fb5:	6a 00                	push   $0x0
c0021fb7:	6a 5c                	push   $0x5c
c0021fb9:	e9 2a fc ff ff       	jmp    c0021be8 <intr_entry>

c0021fbe <intr5d_stub>:
c0021fbe:	55                   	push   %ebp
c0021fbf:	6a 00                	push   $0x0
c0021fc1:	6a 5d                	push   $0x5d
c0021fc3:	e9 20 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021fc8 <intr5e_stub>:
c0021fc8:	55                   	push   %ebp
c0021fc9:	6a 00                	push   $0x0
c0021fcb:	6a 5e                	push   $0x5e
c0021fcd:	e9 16 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021fd2 <intr5f_stub>:
c0021fd2:	55                   	push   %ebp
c0021fd3:	6a 00                	push   $0x0
c0021fd5:	6a 5f                	push   $0x5f
c0021fd7:	e9 0c fc ff ff       	jmp    c0021be8 <intr_entry>

c0021fdc <intr60_stub>:
c0021fdc:	55                   	push   %ebp
c0021fdd:	6a 00                	push   $0x0
c0021fdf:	6a 60                	push   $0x60
c0021fe1:	e9 02 fc ff ff       	jmp    c0021be8 <intr_entry>

c0021fe6 <intr61_stub>:
c0021fe6:	55                   	push   %ebp
c0021fe7:	6a 00                	push   $0x0
c0021fe9:	6a 61                	push   $0x61
c0021feb:	e9 f8 fb ff ff       	jmp    c0021be8 <intr_entry>

c0021ff0 <intr62_stub>:
c0021ff0:	55                   	push   %ebp
c0021ff1:	6a 00                	push   $0x0
c0021ff3:	6a 62                	push   $0x62
c0021ff5:	e9 ee fb ff ff       	jmp    c0021be8 <intr_entry>

c0021ffa <intr63_stub>:
c0021ffa:	55                   	push   %ebp
c0021ffb:	6a 00                	push   $0x0
c0021ffd:	6a 63                	push   $0x63
c0021fff:	e9 e4 fb ff ff       	jmp    c0021be8 <intr_entry>

c0022004 <intr64_stub>:
c0022004:	55                   	push   %ebp
c0022005:	6a 00                	push   $0x0
c0022007:	6a 64                	push   $0x64
c0022009:	e9 da fb ff ff       	jmp    c0021be8 <intr_entry>

c002200e <intr65_stub>:
c002200e:	55                   	push   %ebp
c002200f:	6a 00                	push   $0x0
c0022011:	6a 65                	push   $0x65
c0022013:	e9 d0 fb ff ff       	jmp    c0021be8 <intr_entry>

c0022018 <intr66_stub>:
c0022018:	55                   	push   %ebp
c0022019:	6a 00                	push   $0x0
c002201b:	6a 66                	push   $0x66
c002201d:	e9 c6 fb ff ff       	jmp    c0021be8 <intr_entry>

c0022022 <intr67_stub>:
c0022022:	55                   	push   %ebp
c0022023:	6a 00                	push   $0x0
c0022025:	6a 67                	push   $0x67
c0022027:	e9 bc fb ff ff       	jmp    c0021be8 <intr_entry>

c002202c <intr68_stub>:
c002202c:	55                   	push   %ebp
c002202d:	6a 00                	push   $0x0
c002202f:	6a 68                	push   $0x68
c0022031:	e9 b2 fb ff ff       	jmp    c0021be8 <intr_entry>

c0022036 <intr69_stub>:
c0022036:	55                   	push   %ebp
c0022037:	6a 00                	push   $0x0
c0022039:	6a 69                	push   $0x69
c002203b:	e9 a8 fb ff ff       	jmp    c0021be8 <intr_entry>

c0022040 <intr6a_stub>:
c0022040:	55                   	push   %ebp
c0022041:	6a 00                	push   $0x0
c0022043:	6a 6a                	push   $0x6a
c0022045:	e9 9e fb ff ff       	jmp    c0021be8 <intr_entry>

c002204a <intr6b_stub>:
c002204a:	55                   	push   %ebp
c002204b:	6a 00                	push   $0x0
c002204d:	6a 6b                	push   $0x6b
c002204f:	e9 94 fb ff ff       	jmp    c0021be8 <intr_entry>

c0022054 <intr6c_stub>:
c0022054:	55                   	push   %ebp
c0022055:	6a 00                	push   $0x0
c0022057:	6a 6c                	push   $0x6c
c0022059:	e9 8a fb ff ff       	jmp    c0021be8 <intr_entry>

c002205e <intr6d_stub>:
c002205e:	55                   	push   %ebp
c002205f:	6a 00                	push   $0x0
c0022061:	6a 6d                	push   $0x6d
c0022063:	e9 80 fb ff ff       	jmp    c0021be8 <intr_entry>

c0022068 <intr6e_stub>:
c0022068:	55                   	push   %ebp
c0022069:	6a 00                	push   $0x0
c002206b:	6a 6e                	push   $0x6e
c002206d:	e9 76 fb ff ff       	jmp    c0021be8 <intr_entry>

c0022072 <intr6f_stub>:
c0022072:	55                   	push   %ebp
c0022073:	6a 00                	push   $0x0
c0022075:	6a 6f                	push   $0x6f
c0022077:	e9 6c fb ff ff       	jmp    c0021be8 <intr_entry>

c002207c <intr70_stub>:
c002207c:	55                   	push   %ebp
c002207d:	6a 00                	push   $0x0
c002207f:	6a 70                	push   $0x70
c0022081:	e9 62 fb ff ff       	jmp    c0021be8 <intr_entry>

c0022086 <intr71_stub>:
c0022086:	55                   	push   %ebp
c0022087:	6a 00                	push   $0x0
c0022089:	6a 71                	push   $0x71
c002208b:	e9 58 fb ff ff       	jmp    c0021be8 <intr_entry>

c0022090 <intr72_stub>:
c0022090:	55                   	push   %ebp
c0022091:	6a 00                	push   $0x0
c0022093:	6a 72                	push   $0x72
c0022095:	e9 4e fb ff ff       	jmp    c0021be8 <intr_entry>

c002209a <intr73_stub>:
c002209a:	55                   	push   %ebp
c002209b:	6a 00                	push   $0x0
c002209d:	6a 73                	push   $0x73
c002209f:	e9 44 fb ff ff       	jmp    c0021be8 <intr_entry>

c00220a4 <intr74_stub>:
c00220a4:	55                   	push   %ebp
c00220a5:	6a 00                	push   $0x0
c00220a7:	6a 74                	push   $0x74
c00220a9:	e9 3a fb ff ff       	jmp    c0021be8 <intr_entry>

c00220ae <intr75_stub>:
c00220ae:	55                   	push   %ebp
c00220af:	6a 00                	push   $0x0
c00220b1:	6a 75                	push   $0x75
c00220b3:	e9 30 fb ff ff       	jmp    c0021be8 <intr_entry>

c00220b8 <intr76_stub>:
c00220b8:	55                   	push   %ebp
c00220b9:	6a 00                	push   $0x0
c00220bb:	6a 76                	push   $0x76
c00220bd:	e9 26 fb ff ff       	jmp    c0021be8 <intr_entry>

c00220c2 <intr77_stub>:
c00220c2:	55                   	push   %ebp
c00220c3:	6a 00                	push   $0x0
c00220c5:	6a 77                	push   $0x77
c00220c7:	e9 1c fb ff ff       	jmp    c0021be8 <intr_entry>

c00220cc <intr78_stub>:
c00220cc:	55                   	push   %ebp
c00220cd:	6a 00                	push   $0x0
c00220cf:	6a 78                	push   $0x78
c00220d1:	e9 12 fb ff ff       	jmp    c0021be8 <intr_entry>

c00220d6 <intr79_stub>:
c00220d6:	55                   	push   %ebp
c00220d7:	6a 00                	push   $0x0
c00220d9:	6a 79                	push   $0x79
c00220db:	e9 08 fb ff ff       	jmp    c0021be8 <intr_entry>

c00220e0 <intr7a_stub>:
c00220e0:	55                   	push   %ebp
c00220e1:	6a 00                	push   $0x0
c00220e3:	6a 7a                	push   $0x7a
c00220e5:	e9 fe fa ff ff       	jmp    c0021be8 <intr_entry>

c00220ea <intr7b_stub>:
c00220ea:	55                   	push   %ebp
c00220eb:	6a 00                	push   $0x0
c00220ed:	6a 7b                	push   $0x7b
c00220ef:	e9 f4 fa ff ff       	jmp    c0021be8 <intr_entry>

c00220f4 <intr7c_stub>:
c00220f4:	55                   	push   %ebp
c00220f5:	6a 00                	push   $0x0
c00220f7:	6a 7c                	push   $0x7c
c00220f9:	e9 ea fa ff ff       	jmp    c0021be8 <intr_entry>

c00220fe <intr7d_stub>:
c00220fe:	55                   	push   %ebp
c00220ff:	6a 00                	push   $0x0
c0022101:	6a 7d                	push   $0x7d
c0022103:	e9 e0 fa ff ff       	jmp    c0021be8 <intr_entry>

c0022108 <intr7e_stub>:
c0022108:	55                   	push   %ebp
c0022109:	6a 00                	push   $0x0
c002210b:	6a 7e                	push   $0x7e
c002210d:	e9 d6 fa ff ff       	jmp    c0021be8 <intr_entry>

c0022112 <intr7f_stub>:
c0022112:	55                   	push   %ebp
c0022113:	6a 00                	push   $0x0
c0022115:	6a 7f                	push   $0x7f
c0022117:	e9 cc fa ff ff       	jmp    c0021be8 <intr_entry>

c002211c <intr80_stub>:
c002211c:	55                   	push   %ebp
c002211d:	6a 00                	push   $0x0
c002211f:	68 80 00 00 00       	push   $0x80
c0022124:	e9 bf fa ff ff       	jmp    c0021be8 <intr_entry>

c0022129 <intr81_stub>:
c0022129:	55                   	push   %ebp
c002212a:	6a 00                	push   $0x0
c002212c:	68 81 00 00 00       	push   $0x81
c0022131:	e9 b2 fa ff ff       	jmp    c0021be8 <intr_entry>

c0022136 <intr82_stub>:
c0022136:	55                   	push   %ebp
c0022137:	6a 00                	push   $0x0
c0022139:	68 82 00 00 00       	push   $0x82
c002213e:	e9 a5 fa ff ff       	jmp    c0021be8 <intr_entry>

c0022143 <intr83_stub>:
c0022143:	55                   	push   %ebp
c0022144:	6a 00                	push   $0x0
c0022146:	68 83 00 00 00       	push   $0x83
c002214b:	e9 98 fa ff ff       	jmp    c0021be8 <intr_entry>

c0022150 <intr84_stub>:
c0022150:	55                   	push   %ebp
c0022151:	6a 00                	push   $0x0
c0022153:	68 84 00 00 00       	push   $0x84
c0022158:	e9 8b fa ff ff       	jmp    c0021be8 <intr_entry>

c002215d <intr85_stub>:
c002215d:	55                   	push   %ebp
c002215e:	6a 00                	push   $0x0
c0022160:	68 85 00 00 00       	push   $0x85
c0022165:	e9 7e fa ff ff       	jmp    c0021be8 <intr_entry>

c002216a <intr86_stub>:
c002216a:	55                   	push   %ebp
c002216b:	6a 00                	push   $0x0
c002216d:	68 86 00 00 00       	push   $0x86
c0022172:	e9 71 fa ff ff       	jmp    c0021be8 <intr_entry>

c0022177 <intr87_stub>:
c0022177:	55                   	push   %ebp
c0022178:	6a 00                	push   $0x0
c002217a:	68 87 00 00 00       	push   $0x87
c002217f:	e9 64 fa ff ff       	jmp    c0021be8 <intr_entry>

c0022184 <intr88_stub>:
c0022184:	55                   	push   %ebp
c0022185:	6a 00                	push   $0x0
c0022187:	68 88 00 00 00       	push   $0x88
c002218c:	e9 57 fa ff ff       	jmp    c0021be8 <intr_entry>

c0022191 <intr89_stub>:
c0022191:	55                   	push   %ebp
c0022192:	6a 00                	push   $0x0
c0022194:	68 89 00 00 00       	push   $0x89
c0022199:	e9 4a fa ff ff       	jmp    c0021be8 <intr_entry>

c002219e <intr8a_stub>:
c002219e:	55                   	push   %ebp
c002219f:	6a 00                	push   $0x0
c00221a1:	68 8a 00 00 00       	push   $0x8a
c00221a6:	e9 3d fa ff ff       	jmp    c0021be8 <intr_entry>

c00221ab <intr8b_stub>:
c00221ab:	55                   	push   %ebp
c00221ac:	6a 00                	push   $0x0
c00221ae:	68 8b 00 00 00       	push   $0x8b
c00221b3:	e9 30 fa ff ff       	jmp    c0021be8 <intr_entry>

c00221b8 <intr8c_stub>:
c00221b8:	55                   	push   %ebp
c00221b9:	6a 00                	push   $0x0
c00221bb:	68 8c 00 00 00       	push   $0x8c
c00221c0:	e9 23 fa ff ff       	jmp    c0021be8 <intr_entry>

c00221c5 <intr8d_stub>:
c00221c5:	55                   	push   %ebp
c00221c6:	6a 00                	push   $0x0
c00221c8:	68 8d 00 00 00       	push   $0x8d
c00221cd:	e9 16 fa ff ff       	jmp    c0021be8 <intr_entry>

c00221d2 <intr8e_stub>:
c00221d2:	55                   	push   %ebp
c00221d3:	6a 00                	push   $0x0
c00221d5:	68 8e 00 00 00       	push   $0x8e
c00221da:	e9 09 fa ff ff       	jmp    c0021be8 <intr_entry>

c00221df <intr8f_stub>:
c00221df:	55                   	push   %ebp
c00221e0:	6a 00                	push   $0x0
c00221e2:	68 8f 00 00 00       	push   $0x8f
c00221e7:	e9 fc f9 ff ff       	jmp    c0021be8 <intr_entry>

c00221ec <intr90_stub>:
c00221ec:	55                   	push   %ebp
c00221ed:	6a 00                	push   $0x0
c00221ef:	68 90 00 00 00       	push   $0x90
c00221f4:	e9 ef f9 ff ff       	jmp    c0021be8 <intr_entry>

c00221f9 <intr91_stub>:
c00221f9:	55                   	push   %ebp
c00221fa:	6a 00                	push   $0x0
c00221fc:	68 91 00 00 00       	push   $0x91
c0022201:	e9 e2 f9 ff ff       	jmp    c0021be8 <intr_entry>

c0022206 <intr92_stub>:
c0022206:	55                   	push   %ebp
c0022207:	6a 00                	push   $0x0
c0022209:	68 92 00 00 00       	push   $0x92
c002220e:	e9 d5 f9 ff ff       	jmp    c0021be8 <intr_entry>

c0022213 <intr93_stub>:
c0022213:	55                   	push   %ebp
c0022214:	6a 00                	push   $0x0
c0022216:	68 93 00 00 00       	push   $0x93
c002221b:	e9 c8 f9 ff ff       	jmp    c0021be8 <intr_entry>

c0022220 <intr94_stub>:
c0022220:	55                   	push   %ebp
c0022221:	6a 00                	push   $0x0
c0022223:	68 94 00 00 00       	push   $0x94
c0022228:	e9 bb f9 ff ff       	jmp    c0021be8 <intr_entry>

c002222d <intr95_stub>:
c002222d:	55                   	push   %ebp
c002222e:	6a 00                	push   $0x0
c0022230:	68 95 00 00 00       	push   $0x95
c0022235:	e9 ae f9 ff ff       	jmp    c0021be8 <intr_entry>

c002223a <intr96_stub>:
c002223a:	55                   	push   %ebp
c002223b:	6a 00                	push   $0x0
c002223d:	68 96 00 00 00       	push   $0x96
c0022242:	e9 a1 f9 ff ff       	jmp    c0021be8 <intr_entry>

c0022247 <intr97_stub>:
c0022247:	55                   	push   %ebp
c0022248:	6a 00                	push   $0x0
c002224a:	68 97 00 00 00       	push   $0x97
c002224f:	e9 94 f9 ff ff       	jmp    c0021be8 <intr_entry>

c0022254 <intr98_stub>:
c0022254:	55                   	push   %ebp
c0022255:	6a 00                	push   $0x0
c0022257:	68 98 00 00 00       	push   $0x98
c002225c:	e9 87 f9 ff ff       	jmp    c0021be8 <intr_entry>

c0022261 <intr99_stub>:
c0022261:	55                   	push   %ebp
c0022262:	6a 00                	push   $0x0
c0022264:	68 99 00 00 00       	push   $0x99
c0022269:	e9 7a f9 ff ff       	jmp    c0021be8 <intr_entry>

c002226e <intr9a_stub>:
c002226e:	55                   	push   %ebp
c002226f:	6a 00                	push   $0x0
c0022271:	68 9a 00 00 00       	push   $0x9a
c0022276:	e9 6d f9 ff ff       	jmp    c0021be8 <intr_entry>

c002227b <intr9b_stub>:
c002227b:	55                   	push   %ebp
c002227c:	6a 00                	push   $0x0
c002227e:	68 9b 00 00 00       	push   $0x9b
c0022283:	e9 60 f9 ff ff       	jmp    c0021be8 <intr_entry>

c0022288 <intr9c_stub>:
c0022288:	55                   	push   %ebp
c0022289:	6a 00                	push   $0x0
c002228b:	68 9c 00 00 00       	push   $0x9c
c0022290:	e9 53 f9 ff ff       	jmp    c0021be8 <intr_entry>

c0022295 <intr9d_stub>:
c0022295:	55                   	push   %ebp
c0022296:	6a 00                	push   $0x0
c0022298:	68 9d 00 00 00       	push   $0x9d
c002229d:	e9 46 f9 ff ff       	jmp    c0021be8 <intr_entry>

c00222a2 <intr9e_stub>:
c00222a2:	55                   	push   %ebp
c00222a3:	6a 00                	push   $0x0
c00222a5:	68 9e 00 00 00       	push   $0x9e
c00222aa:	e9 39 f9 ff ff       	jmp    c0021be8 <intr_entry>

c00222af <intr9f_stub>:
c00222af:	55                   	push   %ebp
c00222b0:	6a 00                	push   $0x0
c00222b2:	68 9f 00 00 00       	push   $0x9f
c00222b7:	e9 2c f9 ff ff       	jmp    c0021be8 <intr_entry>

c00222bc <intra0_stub>:
c00222bc:	55                   	push   %ebp
c00222bd:	6a 00                	push   $0x0
c00222bf:	68 a0 00 00 00       	push   $0xa0
c00222c4:	e9 1f f9 ff ff       	jmp    c0021be8 <intr_entry>

c00222c9 <intra1_stub>:
c00222c9:	55                   	push   %ebp
c00222ca:	6a 00                	push   $0x0
c00222cc:	68 a1 00 00 00       	push   $0xa1
c00222d1:	e9 12 f9 ff ff       	jmp    c0021be8 <intr_entry>

c00222d6 <intra2_stub>:
c00222d6:	55                   	push   %ebp
c00222d7:	6a 00                	push   $0x0
c00222d9:	68 a2 00 00 00       	push   $0xa2
c00222de:	e9 05 f9 ff ff       	jmp    c0021be8 <intr_entry>

c00222e3 <intra3_stub>:
c00222e3:	55                   	push   %ebp
c00222e4:	6a 00                	push   $0x0
c00222e6:	68 a3 00 00 00       	push   $0xa3
c00222eb:	e9 f8 f8 ff ff       	jmp    c0021be8 <intr_entry>

c00222f0 <intra4_stub>:
c00222f0:	55                   	push   %ebp
c00222f1:	6a 00                	push   $0x0
c00222f3:	68 a4 00 00 00       	push   $0xa4
c00222f8:	e9 eb f8 ff ff       	jmp    c0021be8 <intr_entry>

c00222fd <intra5_stub>:
c00222fd:	55                   	push   %ebp
c00222fe:	6a 00                	push   $0x0
c0022300:	68 a5 00 00 00       	push   $0xa5
c0022305:	e9 de f8 ff ff       	jmp    c0021be8 <intr_entry>

c002230a <intra6_stub>:
c002230a:	55                   	push   %ebp
c002230b:	6a 00                	push   $0x0
c002230d:	68 a6 00 00 00       	push   $0xa6
c0022312:	e9 d1 f8 ff ff       	jmp    c0021be8 <intr_entry>

c0022317 <intra7_stub>:
c0022317:	55                   	push   %ebp
c0022318:	6a 00                	push   $0x0
c002231a:	68 a7 00 00 00       	push   $0xa7
c002231f:	e9 c4 f8 ff ff       	jmp    c0021be8 <intr_entry>

c0022324 <intra8_stub>:
c0022324:	55                   	push   %ebp
c0022325:	6a 00                	push   $0x0
c0022327:	68 a8 00 00 00       	push   $0xa8
c002232c:	e9 b7 f8 ff ff       	jmp    c0021be8 <intr_entry>

c0022331 <intra9_stub>:
c0022331:	55                   	push   %ebp
c0022332:	6a 00                	push   $0x0
c0022334:	68 a9 00 00 00       	push   $0xa9
c0022339:	e9 aa f8 ff ff       	jmp    c0021be8 <intr_entry>

c002233e <intraa_stub>:
c002233e:	55                   	push   %ebp
c002233f:	6a 00                	push   $0x0
c0022341:	68 aa 00 00 00       	push   $0xaa
c0022346:	e9 9d f8 ff ff       	jmp    c0021be8 <intr_entry>

c002234b <intrab_stub>:
c002234b:	55                   	push   %ebp
c002234c:	6a 00                	push   $0x0
c002234e:	68 ab 00 00 00       	push   $0xab
c0022353:	e9 90 f8 ff ff       	jmp    c0021be8 <intr_entry>

c0022358 <intrac_stub>:
c0022358:	55                   	push   %ebp
c0022359:	6a 00                	push   $0x0
c002235b:	68 ac 00 00 00       	push   $0xac
c0022360:	e9 83 f8 ff ff       	jmp    c0021be8 <intr_entry>

c0022365 <intrad_stub>:
c0022365:	55                   	push   %ebp
c0022366:	6a 00                	push   $0x0
c0022368:	68 ad 00 00 00       	push   $0xad
c002236d:	e9 76 f8 ff ff       	jmp    c0021be8 <intr_entry>

c0022372 <intrae_stub>:
c0022372:	55                   	push   %ebp
c0022373:	6a 00                	push   $0x0
c0022375:	68 ae 00 00 00       	push   $0xae
c002237a:	e9 69 f8 ff ff       	jmp    c0021be8 <intr_entry>

c002237f <intraf_stub>:
c002237f:	55                   	push   %ebp
c0022380:	6a 00                	push   $0x0
c0022382:	68 af 00 00 00       	push   $0xaf
c0022387:	e9 5c f8 ff ff       	jmp    c0021be8 <intr_entry>

c002238c <intrb0_stub>:
c002238c:	55                   	push   %ebp
c002238d:	6a 00                	push   $0x0
c002238f:	68 b0 00 00 00       	push   $0xb0
c0022394:	e9 4f f8 ff ff       	jmp    c0021be8 <intr_entry>

c0022399 <intrb1_stub>:
c0022399:	55                   	push   %ebp
c002239a:	6a 00                	push   $0x0
c002239c:	68 b1 00 00 00       	push   $0xb1
c00223a1:	e9 42 f8 ff ff       	jmp    c0021be8 <intr_entry>

c00223a6 <intrb2_stub>:
c00223a6:	55                   	push   %ebp
c00223a7:	6a 00                	push   $0x0
c00223a9:	68 b2 00 00 00       	push   $0xb2
c00223ae:	e9 35 f8 ff ff       	jmp    c0021be8 <intr_entry>

c00223b3 <intrb3_stub>:
c00223b3:	55                   	push   %ebp
c00223b4:	6a 00                	push   $0x0
c00223b6:	68 b3 00 00 00       	push   $0xb3
c00223bb:	e9 28 f8 ff ff       	jmp    c0021be8 <intr_entry>

c00223c0 <intrb4_stub>:
c00223c0:	55                   	push   %ebp
c00223c1:	6a 00                	push   $0x0
c00223c3:	68 b4 00 00 00       	push   $0xb4
c00223c8:	e9 1b f8 ff ff       	jmp    c0021be8 <intr_entry>

c00223cd <intrb5_stub>:
c00223cd:	55                   	push   %ebp
c00223ce:	6a 00                	push   $0x0
c00223d0:	68 b5 00 00 00       	push   $0xb5
c00223d5:	e9 0e f8 ff ff       	jmp    c0021be8 <intr_entry>

c00223da <intrb6_stub>:
c00223da:	55                   	push   %ebp
c00223db:	6a 00                	push   $0x0
c00223dd:	68 b6 00 00 00       	push   $0xb6
c00223e2:	e9 01 f8 ff ff       	jmp    c0021be8 <intr_entry>

c00223e7 <intrb7_stub>:
c00223e7:	55                   	push   %ebp
c00223e8:	6a 00                	push   $0x0
c00223ea:	68 b7 00 00 00       	push   $0xb7
c00223ef:	e9 f4 f7 ff ff       	jmp    c0021be8 <intr_entry>

c00223f4 <intrb8_stub>:
c00223f4:	55                   	push   %ebp
c00223f5:	6a 00                	push   $0x0
c00223f7:	68 b8 00 00 00       	push   $0xb8
c00223fc:	e9 e7 f7 ff ff       	jmp    c0021be8 <intr_entry>

c0022401 <intrb9_stub>:
c0022401:	55                   	push   %ebp
c0022402:	6a 00                	push   $0x0
c0022404:	68 b9 00 00 00       	push   $0xb9
c0022409:	e9 da f7 ff ff       	jmp    c0021be8 <intr_entry>

c002240e <intrba_stub>:
c002240e:	55                   	push   %ebp
c002240f:	6a 00                	push   $0x0
c0022411:	68 ba 00 00 00       	push   $0xba
c0022416:	e9 cd f7 ff ff       	jmp    c0021be8 <intr_entry>

c002241b <intrbb_stub>:
c002241b:	55                   	push   %ebp
c002241c:	6a 00                	push   $0x0
c002241e:	68 bb 00 00 00       	push   $0xbb
c0022423:	e9 c0 f7 ff ff       	jmp    c0021be8 <intr_entry>

c0022428 <intrbc_stub>:
c0022428:	55                   	push   %ebp
c0022429:	6a 00                	push   $0x0
c002242b:	68 bc 00 00 00       	push   $0xbc
c0022430:	e9 b3 f7 ff ff       	jmp    c0021be8 <intr_entry>

c0022435 <intrbd_stub>:
c0022435:	55                   	push   %ebp
c0022436:	6a 00                	push   $0x0
c0022438:	68 bd 00 00 00       	push   $0xbd
c002243d:	e9 a6 f7 ff ff       	jmp    c0021be8 <intr_entry>

c0022442 <intrbe_stub>:
c0022442:	55                   	push   %ebp
c0022443:	6a 00                	push   $0x0
c0022445:	68 be 00 00 00       	push   $0xbe
c002244a:	e9 99 f7 ff ff       	jmp    c0021be8 <intr_entry>

c002244f <intrbf_stub>:
c002244f:	55                   	push   %ebp
c0022450:	6a 00                	push   $0x0
c0022452:	68 bf 00 00 00       	push   $0xbf
c0022457:	e9 8c f7 ff ff       	jmp    c0021be8 <intr_entry>

c002245c <intrc0_stub>:
c002245c:	55                   	push   %ebp
c002245d:	6a 00                	push   $0x0
c002245f:	68 c0 00 00 00       	push   $0xc0
c0022464:	e9 7f f7 ff ff       	jmp    c0021be8 <intr_entry>

c0022469 <intrc1_stub>:
c0022469:	55                   	push   %ebp
c002246a:	6a 00                	push   $0x0
c002246c:	68 c1 00 00 00       	push   $0xc1
c0022471:	e9 72 f7 ff ff       	jmp    c0021be8 <intr_entry>

c0022476 <intrc2_stub>:
c0022476:	55                   	push   %ebp
c0022477:	6a 00                	push   $0x0
c0022479:	68 c2 00 00 00       	push   $0xc2
c002247e:	e9 65 f7 ff ff       	jmp    c0021be8 <intr_entry>

c0022483 <intrc3_stub>:
c0022483:	55                   	push   %ebp
c0022484:	6a 00                	push   $0x0
c0022486:	68 c3 00 00 00       	push   $0xc3
c002248b:	e9 58 f7 ff ff       	jmp    c0021be8 <intr_entry>

c0022490 <intrc4_stub>:
c0022490:	55                   	push   %ebp
c0022491:	6a 00                	push   $0x0
c0022493:	68 c4 00 00 00       	push   $0xc4
c0022498:	e9 4b f7 ff ff       	jmp    c0021be8 <intr_entry>

c002249d <intrc5_stub>:
c002249d:	55                   	push   %ebp
c002249e:	6a 00                	push   $0x0
c00224a0:	68 c5 00 00 00       	push   $0xc5
c00224a5:	e9 3e f7 ff ff       	jmp    c0021be8 <intr_entry>

c00224aa <intrc6_stub>:
c00224aa:	55                   	push   %ebp
c00224ab:	6a 00                	push   $0x0
c00224ad:	68 c6 00 00 00       	push   $0xc6
c00224b2:	e9 31 f7 ff ff       	jmp    c0021be8 <intr_entry>

c00224b7 <intrc7_stub>:
c00224b7:	55                   	push   %ebp
c00224b8:	6a 00                	push   $0x0
c00224ba:	68 c7 00 00 00       	push   $0xc7
c00224bf:	e9 24 f7 ff ff       	jmp    c0021be8 <intr_entry>

c00224c4 <intrc8_stub>:
c00224c4:	55                   	push   %ebp
c00224c5:	6a 00                	push   $0x0
c00224c7:	68 c8 00 00 00       	push   $0xc8
c00224cc:	e9 17 f7 ff ff       	jmp    c0021be8 <intr_entry>

c00224d1 <intrc9_stub>:
c00224d1:	55                   	push   %ebp
c00224d2:	6a 00                	push   $0x0
c00224d4:	68 c9 00 00 00       	push   $0xc9
c00224d9:	e9 0a f7 ff ff       	jmp    c0021be8 <intr_entry>

c00224de <intrca_stub>:
c00224de:	55                   	push   %ebp
c00224df:	6a 00                	push   $0x0
c00224e1:	68 ca 00 00 00       	push   $0xca
c00224e6:	e9 fd f6 ff ff       	jmp    c0021be8 <intr_entry>

c00224eb <intrcb_stub>:
c00224eb:	55                   	push   %ebp
c00224ec:	6a 00                	push   $0x0
c00224ee:	68 cb 00 00 00       	push   $0xcb
c00224f3:	e9 f0 f6 ff ff       	jmp    c0021be8 <intr_entry>

c00224f8 <intrcc_stub>:
c00224f8:	55                   	push   %ebp
c00224f9:	6a 00                	push   $0x0
c00224fb:	68 cc 00 00 00       	push   $0xcc
c0022500:	e9 e3 f6 ff ff       	jmp    c0021be8 <intr_entry>

c0022505 <intrcd_stub>:
c0022505:	55                   	push   %ebp
c0022506:	6a 00                	push   $0x0
c0022508:	68 cd 00 00 00       	push   $0xcd
c002250d:	e9 d6 f6 ff ff       	jmp    c0021be8 <intr_entry>

c0022512 <intrce_stub>:
c0022512:	55                   	push   %ebp
c0022513:	6a 00                	push   $0x0
c0022515:	68 ce 00 00 00       	push   $0xce
c002251a:	e9 c9 f6 ff ff       	jmp    c0021be8 <intr_entry>

c002251f <intrcf_stub>:
c002251f:	55                   	push   %ebp
c0022520:	6a 00                	push   $0x0
c0022522:	68 cf 00 00 00       	push   $0xcf
c0022527:	e9 bc f6 ff ff       	jmp    c0021be8 <intr_entry>

c002252c <intrd0_stub>:
c002252c:	55                   	push   %ebp
c002252d:	6a 00                	push   $0x0
c002252f:	68 d0 00 00 00       	push   $0xd0
c0022534:	e9 af f6 ff ff       	jmp    c0021be8 <intr_entry>

c0022539 <intrd1_stub>:
c0022539:	55                   	push   %ebp
c002253a:	6a 00                	push   $0x0
c002253c:	68 d1 00 00 00       	push   $0xd1
c0022541:	e9 a2 f6 ff ff       	jmp    c0021be8 <intr_entry>

c0022546 <intrd2_stub>:
c0022546:	55                   	push   %ebp
c0022547:	6a 00                	push   $0x0
c0022549:	68 d2 00 00 00       	push   $0xd2
c002254e:	e9 95 f6 ff ff       	jmp    c0021be8 <intr_entry>

c0022553 <intrd3_stub>:
c0022553:	55                   	push   %ebp
c0022554:	6a 00                	push   $0x0
c0022556:	68 d3 00 00 00       	push   $0xd3
c002255b:	e9 88 f6 ff ff       	jmp    c0021be8 <intr_entry>

c0022560 <intrd4_stub>:
c0022560:	55                   	push   %ebp
c0022561:	6a 00                	push   $0x0
c0022563:	68 d4 00 00 00       	push   $0xd4
c0022568:	e9 7b f6 ff ff       	jmp    c0021be8 <intr_entry>

c002256d <intrd5_stub>:
c002256d:	55                   	push   %ebp
c002256e:	6a 00                	push   $0x0
c0022570:	68 d5 00 00 00       	push   $0xd5
c0022575:	e9 6e f6 ff ff       	jmp    c0021be8 <intr_entry>

c002257a <intrd6_stub>:
c002257a:	55                   	push   %ebp
c002257b:	6a 00                	push   $0x0
c002257d:	68 d6 00 00 00       	push   $0xd6
c0022582:	e9 61 f6 ff ff       	jmp    c0021be8 <intr_entry>

c0022587 <intrd7_stub>:
c0022587:	55                   	push   %ebp
c0022588:	6a 00                	push   $0x0
c002258a:	68 d7 00 00 00       	push   $0xd7
c002258f:	e9 54 f6 ff ff       	jmp    c0021be8 <intr_entry>

c0022594 <intrd8_stub>:
c0022594:	55                   	push   %ebp
c0022595:	6a 00                	push   $0x0
c0022597:	68 d8 00 00 00       	push   $0xd8
c002259c:	e9 47 f6 ff ff       	jmp    c0021be8 <intr_entry>

c00225a1 <intrd9_stub>:
c00225a1:	55                   	push   %ebp
c00225a2:	6a 00                	push   $0x0
c00225a4:	68 d9 00 00 00       	push   $0xd9
c00225a9:	e9 3a f6 ff ff       	jmp    c0021be8 <intr_entry>

c00225ae <intrda_stub>:
c00225ae:	55                   	push   %ebp
c00225af:	6a 00                	push   $0x0
c00225b1:	68 da 00 00 00       	push   $0xda
c00225b6:	e9 2d f6 ff ff       	jmp    c0021be8 <intr_entry>

c00225bb <intrdb_stub>:
c00225bb:	55                   	push   %ebp
c00225bc:	6a 00                	push   $0x0
c00225be:	68 db 00 00 00       	push   $0xdb
c00225c3:	e9 20 f6 ff ff       	jmp    c0021be8 <intr_entry>

c00225c8 <intrdc_stub>:
c00225c8:	55                   	push   %ebp
c00225c9:	6a 00                	push   $0x0
c00225cb:	68 dc 00 00 00       	push   $0xdc
c00225d0:	e9 13 f6 ff ff       	jmp    c0021be8 <intr_entry>

c00225d5 <intrdd_stub>:
c00225d5:	55                   	push   %ebp
c00225d6:	6a 00                	push   $0x0
c00225d8:	68 dd 00 00 00       	push   $0xdd
c00225dd:	e9 06 f6 ff ff       	jmp    c0021be8 <intr_entry>

c00225e2 <intrde_stub>:
c00225e2:	55                   	push   %ebp
c00225e3:	6a 00                	push   $0x0
c00225e5:	68 de 00 00 00       	push   $0xde
c00225ea:	e9 f9 f5 ff ff       	jmp    c0021be8 <intr_entry>

c00225ef <intrdf_stub>:
c00225ef:	55                   	push   %ebp
c00225f0:	6a 00                	push   $0x0
c00225f2:	68 df 00 00 00       	push   $0xdf
c00225f7:	e9 ec f5 ff ff       	jmp    c0021be8 <intr_entry>

c00225fc <intre0_stub>:
c00225fc:	55                   	push   %ebp
c00225fd:	6a 00                	push   $0x0
c00225ff:	68 e0 00 00 00       	push   $0xe0
c0022604:	e9 df f5 ff ff       	jmp    c0021be8 <intr_entry>

c0022609 <intre1_stub>:
c0022609:	55                   	push   %ebp
c002260a:	6a 00                	push   $0x0
c002260c:	68 e1 00 00 00       	push   $0xe1
c0022611:	e9 d2 f5 ff ff       	jmp    c0021be8 <intr_entry>

c0022616 <intre2_stub>:
c0022616:	55                   	push   %ebp
c0022617:	6a 00                	push   $0x0
c0022619:	68 e2 00 00 00       	push   $0xe2
c002261e:	e9 c5 f5 ff ff       	jmp    c0021be8 <intr_entry>

c0022623 <intre3_stub>:
c0022623:	55                   	push   %ebp
c0022624:	6a 00                	push   $0x0
c0022626:	68 e3 00 00 00       	push   $0xe3
c002262b:	e9 b8 f5 ff ff       	jmp    c0021be8 <intr_entry>

c0022630 <intre4_stub>:
c0022630:	55                   	push   %ebp
c0022631:	6a 00                	push   $0x0
c0022633:	68 e4 00 00 00       	push   $0xe4
c0022638:	e9 ab f5 ff ff       	jmp    c0021be8 <intr_entry>

c002263d <intre5_stub>:
c002263d:	55                   	push   %ebp
c002263e:	6a 00                	push   $0x0
c0022640:	68 e5 00 00 00       	push   $0xe5
c0022645:	e9 9e f5 ff ff       	jmp    c0021be8 <intr_entry>

c002264a <intre6_stub>:
c002264a:	55                   	push   %ebp
c002264b:	6a 00                	push   $0x0
c002264d:	68 e6 00 00 00       	push   $0xe6
c0022652:	e9 91 f5 ff ff       	jmp    c0021be8 <intr_entry>

c0022657 <intre7_stub>:
c0022657:	55                   	push   %ebp
c0022658:	6a 00                	push   $0x0
c002265a:	68 e7 00 00 00       	push   $0xe7
c002265f:	e9 84 f5 ff ff       	jmp    c0021be8 <intr_entry>

c0022664 <intre8_stub>:
c0022664:	55                   	push   %ebp
c0022665:	6a 00                	push   $0x0
c0022667:	68 e8 00 00 00       	push   $0xe8
c002266c:	e9 77 f5 ff ff       	jmp    c0021be8 <intr_entry>

c0022671 <intre9_stub>:
c0022671:	55                   	push   %ebp
c0022672:	6a 00                	push   $0x0
c0022674:	68 e9 00 00 00       	push   $0xe9
c0022679:	e9 6a f5 ff ff       	jmp    c0021be8 <intr_entry>

c002267e <intrea_stub>:
c002267e:	55                   	push   %ebp
c002267f:	6a 00                	push   $0x0
c0022681:	68 ea 00 00 00       	push   $0xea
c0022686:	e9 5d f5 ff ff       	jmp    c0021be8 <intr_entry>

c002268b <intreb_stub>:
c002268b:	55                   	push   %ebp
c002268c:	6a 00                	push   $0x0
c002268e:	68 eb 00 00 00       	push   $0xeb
c0022693:	e9 50 f5 ff ff       	jmp    c0021be8 <intr_entry>

c0022698 <intrec_stub>:
c0022698:	55                   	push   %ebp
c0022699:	6a 00                	push   $0x0
c002269b:	68 ec 00 00 00       	push   $0xec
c00226a0:	e9 43 f5 ff ff       	jmp    c0021be8 <intr_entry>

c00226a5 <intred_stub>:
c00226a5:	55                   	push   %ebp
c00226a6:	6a 00                	push   $0x0
c00226a8:	68 ed 00 00 00       	push   $0xed
c00226ad:	e9 36 f5 ff ff       	jmp    c0021be8 <intr_entry>

c00226b2 <intree_stub>:
c00226b2:	55                   	push   %ebp
c00226b3:	6a 00                	push   $0x0
c00226b5:	68 ee 00 00 00       	push   $0xee
c00226ba:	e9 29 f5 ff ff       	jmp    c0021be8 <intr_entry>

c00226bf <intref_stub>:
c00226bf:	55                   	push   %ebp
c00226c0:	6a 00                	push   $0x0
c00226c2:	68 ef 00 00 00       	push   $0xef
c00226c7:	e9 1c f5 ff ff       	jmp    c0021be8 <intr_entry>

c00226cc <intrf0_stub>:
c00226cc:	55                   	push   %ebp
c00226cd:	6a 00                	push   $0x0
c00226cf:	68 f0 00 00 00       	push   $0xf0
c00226d4:	e9 0f f5 ff ff       	jmp    c0021be8 <intr_entry>

c00226d9 <intrf1_stub>:
c00226d9:	55                   	push   %ebp
c00226da:	6a 00                	push   $0x0
c00226dc:	68 f1 00 00 00       	push   $0xf1
c00226e1:	e9 02 f5 ff ff       	jmp    c0021be8 <intr_entry>

c00226e6 <intrf2_stub>:
c00226e6:	55                   	push   %ebp
c00226e7:	6a 00                	push   $0x0
c00226e9:	68 f2 00 00 00       	push   $0xf2
c00226ee:	e9 f5 f4 ff ff       	jmp    c0021be8 <intr_entry>

c00226f3 <intrf3_stub>:
c00226f3:	55                   	push   %ebp
c00226f4:	6a 00                	push   $0x0
c00226f6:	68 f3 00 00 00       	push   $0xf3
c00226fb:	e9 e8 f4 ff ff       	jmp    c0021be8 <intr_entry>

c0022700 <intrf4_stub>:
c0022700:	55                   	push   %ebp
c0022701:	6a 00                	push   $0x0
c0022703:	68 f4 00 00 00       	push   $0xf4
c0022708:	e9 db f4 ff ff       	jmp    c0021be8 <intr_entry>

c002270d <intrf5_stub>:
c002270d:	55                   	push   %ebp
c002270e:	6a 00                	push   $0x0
c0022710:	68 f5 00 00 00       	push   $0xf5
c0022715:	e9 ce f4 ff ff       	jmp    c0021be8 <intr_entry>

c002271a <intrf6_stub>:
c002271a:	55                   	push   %ebp
c002271b:	6a 00                	push   $0x0
c002271d:	68 f6 00 00 00       	push   $0xf6
c0022722:	e9 c1 f4 ff ff       	jmp    c0021be8 <intr_entry>

c0022727 <intrf7_stub>:
c0022727:	55                   	push   %ebp
c0022728:	6a 00                	push   $0x0
c002272a:	68 f7 00 00 00       	push   $0xf7
c002272f:	e9 b4 f4 ff ff       	jmp    c0021be8 <intr_entry>

c0022734 <intrf8_stub>:
c0022734:	55                   	push   %ebp
c0022735:	6a 00                	push   $0x0
c0022737:	68 f8 00 00 00       	push   $0xf8
c002273c:	e9 a7 f4 ff ff       	jmp    c0021be8 <intr_entry>

c0022741 <intrf9_stub>:
c0022741:	55                   	push   %ebp
c0022742:	6a 00                	push   $0x0
c0022744:	68 f9 00 00 00       	push   $0xf9
c0022749:	e9 9a f4 ff ff       	jmp    c0021be8 <intr_entry>

c002274e <intrfa_stub>:
c002274e:	55                   	push   %ebp
c002274f:	6a 00                	push   $0x0
c0022751:	68 fa 00 00 00       	push   $0xfa
c0022756:	e9 8d f4 ff ff       	jmp    c0021be8 <intr_entry>

c002275b <intrfb_stub>:
c002275b:	55                   	push   %ebp
c002275c:	6a 00                	push   $0x0
c002275e:	68 fb 00 00 00       	push   $0xfb
c0022763:	e9 80 f4 ff ff       	jmp    c0021be8 <intr_entry>

c0022768 <intrfc_stub>:
c0022768:	55                   	push   %ebp
c0022769:	6a 00                	push   $0x0
c002276b:	68 fc 00 00 00       	push   $0xfc
c0022770:	e9 73 f4 ff ff       	jmp    c0021be8 <intr_entry>

c0022775 <intrfd_stub>:
c0022775:	55                   	push   %ebp
c0022776:	6a 00                	push   $0x0
c0022778:	68 fd 00 00 00       	push   $0xfd
c002277d:	e9 66 f4 ff ff       	jmp    c0021be8 <intr_entry>

c0022782 <intrfe_stub>:
c0022782:	55                   	push   %ebp
c0022783:	6a 00                	push   $0x0
c0022785:	68 fe 00 00 00       	push   $0xfe
c002278a:	e9 59 f4 ff ff       	jmp    c0021be8 <intr_entry>

c002278f <intrff_stub>:
c002278f:	55                   	push   %ebp
c0022790:	6a 00                	push   $0x0
c0022792:	68 ff 00 00 00       	push   $0xff
c0022797:	e9 4c f4 ff ff       	jmp    c0021be8 <intr_entry>

c002279c <sema_init>:

   - up or "V": increment the value (and wake up one waiting
     thread, if any). */
void
sema_init (struct semaphore *sema, unsigned value) 
{
c002279c:	55                   	push   %ebp
c002279d:	89 e5                	mov    %esp,%ebp
c002279f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (sema != NULL);
c00227a2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00227a6:	75 1e                	jne    c00227c6 <sema_init+0x2a>
c00227a8:	83 ec 0c             	sub    $0xc,%esp
c00227ab:	68 6c ef 02 c0       	push   $0xc002ef6c
c00227b0:	68 79 ef 02 c0       	push   $0xc002ef79
c00227b5:	68 40 f0 02 c0       	push   $0xc002f040
c00227ba:	6a 2f                	push   $0x2f
c00227bc:	68 90 ef 02 c0       	push   $0xc002ef90
c00227c1:	e8 58 6d 00 00       	call   c002951e <debug_panic>

  sema->value = value;
c00227c6:	8b 45 08             	mov    0x8(%ebp),%eax
c00227c9:	8b 55 0c             	mov    0xc(%ebp),%edx
c00227cc:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c00227ce:	8b 45 08             	mov    0x8(%ebp),%eax
c00227d1:	83 c0 04             	add    $0x4,%eax
c00227d4:	83 ec 0c             	sub    $0xc,%esp
c00227d7:	50                   	push   %eax
c00227d8:	e8 b8 6f 00 00       	call   c0029795 <list_init>
c00227dd:	83 c4 10             	add    $0x10,%esp
}
c00227e0:	90                   	nop
c00227e1:	c9                   	leave  
c00227e2:	c3                   	ret    

c00227e3 <sema_down>:
   interrupt handler.  This function may be called with
   interrupts disabled, but if it sleeps then the next scheduled
   thread will probably turn interrupts back on. */
void
sema_down (struct semaphore *sema) 
{
c00227e3:	55                   	push   %ebp
c00227e4:	89 e5                	mov    %esp,%ebp
c00227e6:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c00227e9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00227ed:	75 1e                	jne    c002280d <sema_down+0x2a>
c00227ef:	83 ec 0c             	sub    $0xc,%esp
c00227f2:	68 6c ef 02 c0       	push   $0xc002ef6c
c00227f7:	68 79 ef 02 c0       	push   $0xc002ef79
c00227fc:	68 4c f0 02 c0       	push   $0xc002f04c
c0022801:	6a 41                	push   $0x41
c0022803:	68 90 ef 02 c0       	push   $0xc002ef90
c0022808:	e8 11 6d 00 00       	call   c002951e <debug_panic>
  ASSERT (!intr_context ());
c002280d:	e8 58 ee ff ff       	call   c002166a <intr_context>
c0022812:	83 f0 01             	xor    $0x1,%eax
c0022815:	84 c0                	test   %al,%al
c0022817:	75 1e                	jne    c0022837 <sema_down+0x54>
c0022819:	83 ec 0c             	sub    $0xc,%esp
c002281c:	68 a6 ef 02 c0       	push   $0xc002efa6
c0022821:	68 79 ef 02 c0       	push   $0xc002ef79
c0022826:	68 4c f0 02 c0       	push   $0xc002f04c
c002282b:	6a 42                	push   $0x42
c002282d:	68 90 ef 02 c0       	push   $0xc002ef90
c0022832:	e8 e7 6c 00 00       	call   c002951e <debug_panic>

  old_level = intr_disable ();
c0022837:	e8 61 eb ff ff       	call   c002139d <intr_disable>
c002283c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (sema->value == 0) 
c002283f:	eb 20                	jmp    c0022861 <sema_down+0x7e>
    {
      list_push_back (&sema->waiters, &thread_current ()->elem);
c0022841:	e8 32 e4 ff ff       	call   c0020c78 <thread_current>
c0022846:	8d 50 28             	lea    0x28(%eax),%edx
c0022849:	8b 45 08             	mov    0x8(%ebp),%eax
c002284c:	83 c0 04             	add    $0x4,%eax
c002284f:	83 ec 08             	sub    $0x8,%esp
c0022852:	52                   	push   %edx
c0022853:	50                   	push   %eax
c0022854:	e8 1c 73 00 00       	call   c0029b75 <list_push_back>
c0022859:	83 c4 10             	add    $0x10,%esp
      thread_block ();
c002285c:	e8 f7 e2 ff ff       	call   c0020b58 <thread_block>
  while (sema->value == 0) 
c0022861:	8b 45 08             	mov    0x8(%ebp),%eax
c0022864:	8b 00                	mov    (%eax),%eax
c0022866:	85 c0                	test   %eax,%eax
c0022868:	74 d7                	je     c0022841 <sema_down+0x5e>
    }
  sema->value--;
c002286a:	8b 45 08             	mov    0x8(%ebp),%eax
c002286d:	8b 00                	mov    (%eax),%eax
c002286f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0022872:	8b 45 08             	mov    0x8(%ebp),%eax
c0022875:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c0022877:	83 ec 0c             	sub    $0xc,%esp
c002287a:	ff 75 f4             	push   -0xc(%ebp)
c002287d:	e8 c3 ea ff ff       	call   c0021345 <intr_set_level>
c0022882:	83 c4 10             	add    $0x10,%esp
}
c0022885:	90                   	nop
c0022886:	c9                   	leave  
c0022887:	c3                   	ret    

c0022888 <sema_try_down>:
   decremented, false otherwise.

   This function may be called from an interrupt handler. */
bool
sema_try_down (struct semaphore *sema) 
{
c0022888:	55                   	push   %ebp
c0022889:	89 e5                	mov    %esp,%ebp
c002288b:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  bool success;

  ASSERT (sema != NULL);
c002288e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022892:	75 1e                	jne    c00228b2 <sema_try_down+0x2a>
c0022894:	83 ec 0c             	sub    $0xc,%esp
c0022897:	68 6c ef 02 c0       	push   $0xc002ef6c
c002289c:	68 79 ef 02 c0       	push   $0xc002ef79
c00228a1:	68 58 f0 02 c0       	push   $0xc002f058
c00228a6:	6a 59                	push   $0x59
c00228a8:	68 90 ef 02 c0       	push   $0xc002ef90
c00228ad:	e8 6c 6c 00 00       	call   c002951e <debug_panic>

  old_level = intr_disable ();
c00228b2:	e8 e6 ea ff ff       	call   c002139d <intr_disable>
c00228b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (sema->value > 0) 
c00228ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00228bd:	8b 00                	mov    (%eax),%eax
c00228bf:	85 c0                	test   %eax,%eax
c00228c1:	74 13                	je     c00228d6 <sema_try_down+0x4e>
    {
      sema->value--;
c00228c3:	8b 45 08             	mov    0x8(%ebp),%eax
c00228c6:	8b 00                	mov    (%eax),%eax
c00228c8:	8d 50 ff             	lea    -0x1(%eax),%edx
c00228cb:	8b 45 08             	mov    0x8(%ebp),%eax
c00228ce:	89 10                	mov    %edx,(%eax)
      success = true; 
c00228d0:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
c00228d4:	eb 04                	jmp    c00228da <sema_try_down+0x52>
    }
  else
    success = false;
c00228d6:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  intr_set_level (old_level);
c00228da:	83 ec 0c             	sub    $0xc,%esp
c00228dd:	ff 75 f0             	push   -0x10(%ebp)
c00228e0:	e8 60 ea ff ff       	call   c0021345 <intr_set_level>
c00228e5:	83 c4 10             	add    $0x10,%esp

  return success;
c00228e8:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c00228eb:	c9                   	leave  
c00228ec:	c3                   	ret    

c00228ed <sema_up>:
   and wakes up one thread of those waiting for SEMA, if any.

   This function may be called from an interrupt handler. */
void
sema_up (struct semaphore *sema) 
{
c00228ed:	55                   	push   %ebp
c00228ee:	89 e5                	mov    %esp,%ebp
c00228f0:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c00228f3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00228f7:	75 1e                	jne    c0022917 <sema_up+0x2a>
c00228f9:	83 ec 0c             	sub    $0xc,%esp
c00228fc:	68 6c ef 02 c0       	push   $0xc002ef6c
c0022901:	68 79 ef 02 c0       	push   $0xc002ef79
c0022906:	68 68 f0 02 c0       	push   $0xc002f068
c002290b:	6a 71                	push   $0x71
c002290d:	68 90 ef 02 c0       	push   $0xc002ef90
c0022912:	e8 07 6c 00 00       	call   c002951e <debug_panic>

  old_level = intr_disable ();
c0022917:	e8 81 ea ff ff       	call   c002139d <intr_disable>
c002291c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (!list_empty (&sema->waiters)) 
c002291f:	8b 45 08             	mov    0x8(%ebp),%eax
c0022922:	83 c0 04             	add    $0x4,%eax
c0022925:	83 ec 0c             	sub    $0xc,%esp
c0022928:	50                   	push   %eax
c0022929:	e8 ee 73 00 00       	call   c0029d1c <list_empty>
c002292e:	83 c4 10             	add    $0x10,%esp
c0022931:	83 f0 01             	xor    $0x1,%eax
c0022934:	84 c0                	test   %al,%al
c0022936:	74 24                	je     c002295c <sema_up+0x6f>
    thread_unblock (list_entry (list_pop_front (&sema->waiters),
c0022938:	8b 45 08             	mov    0x8(%ebp),%eax
c002293b:	83 c0 04             	add    $0x4,%eax
c002293e:	83 ec 0c             	sub    $0xc,%esp
c0022941:	50                   	push   %eax
c0022942:	e8 ad 72 00 00       	call   c0029bf4 <list_pop_front>
c0022947:	83 c4 10             	add    $0x10,%esp
c002294a:	83 c0 04             	add    $0x4,%eax
c002294d:	83 e8 2c             	sub    $0x2c,%eax
c0022950:	83 ec 0c             	sub    $0xc,%esp
c0022953:	50                   	push   %eax
c0022954:	e8 70 e2 ff ff       	call   c0020bc9 <thread_unblock>
c0022959:	83 c4 10             	add    $0x10,%esp
                                struct thread, elem));
  sema->value++;
c002295c:	8b 45 08             	mov    0x8(%ebp),%eax
c002295f:	8b 00                	mov    (%eax),%eax
c0022961:	8d 50 01             	lea    0x1(%eax),%edx
c0022964:	8b 45 08             	mov    0x8(%ebp),%eax
c0022967:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c0022969:	83 ec 0c             	sub    $0xc,%esp
c002296c:	ff 75 f4             	push   -0xc(%ebp)
c002296f:	e8 d1 e9 ff ff       	call   c0021345 <intr_set_level>
c0022974:	83 c4 10             	add    $0x10,%esp
}
c0022977:	90                   	nop
c0022978:	c9                   	leave  
c0022979:	c3                   	ret    

c002297a <sema_self_test>:
/* Self-test for semaphores that makes control "ping-pong"
   between a pair of threads.  Insert calls to printf() to see
   what's going on. */
void
sema_self_test (void) 
{
c002297a:	55                   	push   %ebp
c002297b:	89 e5                	mov    %esp,%ebp
c002297d:	83 ec 38             	sub    $0x38,%esp
  struct semaphore sema[2];
  int i;

  printf ("Testing semaphores...");
c0022980:	83 ec 0c             	sub    $0xc,%esp
c0022983:	68 b7 ef 02 c0       	push   $0xc002efb7
c0022988:	e8 ef 47 00 00       	call   c002717c <printf>
c002298d:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[0], 0);
c0022990:	83 ec 08             	sub    $0x8,%esp
c0022993:	6a 00                	push   $0x0
c0022995:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022998:	50                   	push   %eax
c0022999:	e8 fe fd ff ff       	call   c002279c <sema_init>
c002299e:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[1], 0);
c00229a1:	83 ec 08             	sub    $0x8,%esp
c00229a4:	6a 00                	push   $0x0
c00229a6:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00229a9:	83 c0 14             	add    $0x14,%eax
c00229ac:	50                   	push   %eax
c00229ad:	e8 ea fd ff ff       	call   c002279c <sema_init>
c00229b2:	83 c4 10             	add    $0x10,%esp
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c00229b5:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00229b8:	50                   	push   %eax
c00229b9:	68 13 2a 02 c0       	push   $0xc0022a13
c00229be:	6a 1f                	push   $0x1f
c00229c0:	68 cd ef 02 c0       	push   $0xc002efcd
c00229c5:	e8 97 e0 ff ff       	call   c0020a61 <thread_create>
c00229ca:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c00229cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00229d4:	eb 24                	jmp    c00229fa <sema_self_test+0x80>
    {
      sema_up (&sema[0]);
c00229d6:	83 ec 0c             	sub    $0xc,%esp
c00229d9:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00229dc:	50                   	push   %eax
c00229dd:	e8 0b ff ff ff       	call   c00228ed <sema_up>
c00229e2:	83 c4 10             	add    $0x10,%esp
      sema_down (&sema[1]);
c00229e5:	83 ec 0c             	sub    $0xc,%esp
c00229e8:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00229eb:	83 c0 14             	add    $0x14,%eax
c00229ee:	50                   	push   %eax
c00229ef:	e8 ef fd ff ff       	call   c00227e3 <sema_down>
c00229f4:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c00229f7:	ff 45 f4             	incl   -0xc(%ebp)
c00229fa:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c00229fe:	7e d6                	jle    c00229d6 <sema_self_test+0x5c>
    }
  printf ("done.\n");
c0022a00:	83 ec 0c             	sub    $0xc,%esp
c0022a03:	68 d7 ef 02 c0       	push   $0xc002efd7
c0022a08:	e8 d6 8c 00 00       	call   c002b6e3 <puts>
c0022a0d:	83 c4 10             	add    $0x10,%esp
}
c0022a10:	90                   	nop
c0022a11:	c9                   	leave  
c0022a12:	c3                   	ret    

c0022a13 <sema_test_helper>:

/* Thread function used by sema_self_test(). */
static void
sema_test_helper (void *sema_) 
{
c0022a13:	55                   	push   %ebp
c0022a14:	89 e5                	mov    %esp,%ebp
c0022a16:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *sema = sema_;
c0022a19:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  for (i = 0; i < 10; i++) 
c0022a1f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0022a26:	eb 23                	jmp    c0022a4b <sema_test_helper+0x38>
    {
      sema_down (&sema[0]);
c0022a28:	83 ec 0c             	sub    $0xc,%esp
c0022a2b:	ff 75 f0             	push   -0x10(%ebp)
c0022a2e:	e8 b0 fd ff ff       	call   c00227e3 <sema_down>
c0022a33:	83 c4 10             	add    $0x10,%esp
      sema_up (&sema[1]);
c0022a36:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0022a39:	83 c0 14             	add    $0x14,%eax
c0022a3c:	83 ec 0c             	sub    $0xc,%esp
c0022a3f:	50                   	push   %eax
c0022a40:	e8 a8 fe ff ff       	call   c00228ed <sema_up>
c0022a45:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0022a48:	ff 45 f4             	incl   -0xc(%ebp)
c0022a4b:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0022a4f:	7e d7                	jle    c0022a28 <sema_test_helper+0x15>
    }
}
c0022a51:	90                   	nop
c0022a52:	90                   	nop
c0022a53:	c9                   	leave  
c0022a54:	c3                   	ret    

c0022a55 <lock_init>:
   acquire and release it.  When these restrictions prove
   onerous, it's a good sign that a semaphore should be used,
   instead of a lock. */
void
lock_init (struct lock *lock)
{
c0022a55:	55                   	push   %ebp
c0022a56:	89 e5                	mov    %esp,%ebp
c0022a58:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022a5b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022a5f:	75 21                	jne    c0022a82 <lock_init+0x2d>
c0022a61:	83 ec 0c             	sub    $0xc,%esp
c0022a64:	68 dd ef 02 c0       	push   $0xc002efdd
c0022a69:	68 79 ef 02 c0       	push   $0xc002ef79
c0022a6e:	68 70 f0 02 c0       	push   $0xc002f070
c0022a73:	68 b2 00 00 00       	push   $0xb2
c0022a78:	68 90 ef 02 c0       	push   $0xc002ef90
c0022a7d:	e8 9c 6a 00 00       	call   c002951e <debug_panic>

  lock->holder = NULL;
c0022a82:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a85:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_init (&lock->semaphore, 1);
c0022a8b:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a8e:	83 c0 04             	add    $0x4,%eax
c0022a91:	83 ec 08             	sub    $0x8,%esp
c0022a94:	6a 01                	push   $0x1
c0022a96:	50                   	push   %eax
c0022a97:	e8 00 fd ff ff       	call   c002279c <sema_init>
c0022a9c:	83 c4 10             	add    $0x10,%esp
}
c0022a9f:	90                   	nop
c0022aa0:	c9                   	leave  
c0022aa1:	c3                   	ret    

c0022aa2 <lock_acquire>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
lock_acquire (struct lock *lock)
{
c0022aa2:	55                   	push   %ebp
c0022aa3:	89 e5                	mov    %esp,%ebp
c0022aa5:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022aa8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022aac:	75 21                	jne    c0022acf <lock_acquire+0x2d>
c0022aae:	83 ec 0c             	sub    $0xc,%esp
c0022ab1:	68 dd ef 02 c0       	push   $0xc002efdd
c0022ab6:	68 79 ef 02 c0       	push   $0xc002ef79
c0022abb:	68 7c f0 02 c0       	push   $0xc002f07c
c0022ac0:	68 c3 00 00 00       	push   $0xc3
c0022ac5:	68 90 ef 02 c0       	push   $0xc002ef90
c0022aca:	e8 4f 6a 00 00       	call   c002951e <debug_panic>
  ASSERT (!intr_context ());
c0022acf:	e8 96 eb ff ff       	call   c002166a <intr_context>
c0022ad4:	83 f0 01             	xor    $0x1,%eax
c0022ad7:	84 c0                	test   %al,%al
c0022ad9:	75 21                	jne    c0022afc <lock_acquire+0x5a>
c0022adb:	83 ec 0c             	sub    $0xc,%esp
c0022ade:	68 a6 ef 02 c0       	push   $0xc002efa6
c0022ae3:	68 79 ef 02 c0       	push   $0xc002ef79
c0022ae8:	68 7c f0 02 c0       	push   $0xc002f07c
c0022aed:	68 c4 00 00 00       	push   $0xc4
c0022af2:	68 90 ef 02 c0       	push   $0xc002ef90
c0022af7:	e8 22 6a 00 00       	call   c002951e <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022afc:	83 ec 0c             	sub    $0xc,%esp
c0022aff:	ff 75 08             	push   0x8(%ebp)
c0022b02:	e8 55 01 00 00       	call   c0022c5c <lock_held_by_current_thread>
c0022b07:	83 c4 10             	add    $0x10,%esp
c0022b0a:	83 f0 01             	xor    $0x1,%eax
c0022b0d:	84 c0                	test   %al,%al
c0022b0f:	75 21                	jne    c0022b32 <lock_acquire+0x90>
c0022b11:	83 ec 0c             	sub    $0xc,%esp
c0022b14:	68 ec ef 02 c0       	push   $0xc002efec
c0022b19:	68 79 ef 02 c0       	push   $0xc002ef79
c0022b1e:	68 7c f0 02 c0       	push   $0xc002f07c
c0022b23:	68 c5 00 00 00       	push   $0xc5
c0022b28:	68 90 ef 02 c0       	push   $0xc002ef90
c0022b2d:	e8 ec 69 00 00       	call   c002951e <debug_panic>

  sema_down (&lock->semaphore);
c0022b32:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b35:	83 c0 04             	add    $0x4,%eax
c0022b38:	83 ec 0c             	sub    $0xc,%esp
c0022b3b:	50                   	push   %eax
c0022b3c:	e8 a2 fc ff ff       	call   c00227e3 <sema_down>
c0022b41:	83 c4 10             	add    $0x10,%esp
  lock->holder = thread_current ();
c0022b44:	e8 2f e1 ff ff       	call   c0020c78 <thread_current>
c0022b49:	8b 55 08             	mov    0x8(%ebp),%edx
c0022b4c:	89 02                	mov    %eax,(%edx)
}
c0022b4e:	90                   	nop
c0022b4f:	c9                   	leave  
c0022b50:	c3                   	ret    

c0022b51 <lock_try_acquire>:

   This function will not sleep, so it may be called within an
   interrupt handler. */
bool
lock_try_acquire (struct lock *lock)
{
c0022b51:	55                   	push   %ebp
c0022b52:	89 e5                	mov    %esp,%ebp
c0022b54:	83 ec 18             	sub    $0x18,%esp
  bool success;

  ASSERT (lock != NULL);
c0022b57:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022b5b:	75 21                	jne    c0022b7e <lock_try_acquire+0x2d>
c0022b5d:	83 ec 0c             	sub    $0xc,%esp
c0022b60:	68 dd ef 02 c0       	push   $0xc002efdd
c0022b65:	68 79 ef 02 c0       	push   $0xc002ef79
c0022b6a:	68 8c f0 02 c0       	push   $0xc002f08c
c0022b6f:	68 d6 00 00 00       	push   $0xd6
c0022b74:	68 90 ef 02 c0       	push   $0xc002ef90
c0022b79:	e8 a0 69 00 00       	call   c002951e <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022b7e:	83 ec 0c             	sub    $0xc,%esp
c0022b81:	ff 75 08             	push   0x8(%ebp)
c0022b84:	e8 d3 00 00 00       	call   c0022c5c <lock_held_by_current_thread>
c0022b89:	83 c4 10             	add    $0x10,%esp
c0022b8c:	83 f0 01             	xor    $0x1,%eax
c0022b8f:	84 c0                	test   %al,%al
c0022b91:	75 21                	jne    c0022bb4 <lock_try_acquire+0x63>
c0022b93:	83 ec 0c             	sub    $0xc,%esp
c0022b96:	68 ec ef 02 c0       	push   $0xc002efec
c0022b9b:	68 79 ef 02 c0       	push   $0xc002ef79
c0022ba0:	68 8c f0 02 c0       	push   $0xc002f08c
c0022ba5:	68 d7 00 00 00       	push   $0xd7
c0022baa:	68 90 ef 02 c0       	push   $0xc002ef90
c0022baf:	e8 6a 69 00 00       	call   c002951e <debug_panic>

  success = sema_try_down (&lock->semaphore);
c0022bb4:	8b 45 08             	mov    0x8(%ebp),%eax
c0022bb7:	83 c0 04             	add    $0x4,%eax
c0022bba:	83 ec 0c             	sub    $0xc,%esp
c0022bbd:	50                   	push   %eax
c0022bbe:	e8 c5 fc ff ff       	call   c0022888 <sema_try_down>
c0022bc3:	83 c4 10             	add    $0x10,%esp
c0022bc6:	88 45 f7             	mov    %al,-0x9(%ebp)
  if (success)
c0022bc9:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0022bcd:	74 0a                	je     c0022bd9 <lock_try_acquire+0x88>
    lock->holder = thread_current ();
c0022bcf:	e8 a4 e0 ff ff       	call   c0020c78 <thread_current>
c0022bd4:	8b 55 08             	mov    0x8(%ebp),%edx
c0022bd7:	89 02                	mov    %eax,(%edx)
  return success;
c0022bd9:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c0022bdc:	c9                   	leave  
c0022bdd:	c3                   	ret    

c0022bde <lock_release>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to release a lock within an interrupt
   handler. */
void
lock_release (struct lock *lock) 
{
c0022bde:	55                   	push   %ebp
c0022bdf:	89 e5                	mov    %esp,%ebp
c0022be1:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022be4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022be8:	75 21                	jne    c0022c0b <lock_release+0x2d>
c0022bea:	83 ec 0c             	sub    $0xc,%esp
c0022bed:	68 dd ef 02 c0       	push   $0xc002efdd
c0022bf2:	68 79 ef 02 c0       	push   $0xc002ef79
c0022bf7:	68 a0 f0 02 c0       	push   $0xc002f0a0
c0022bfc:	68 e7 00 00 00       	push   $0xe7
c0022c01:	68 90 ef 02 c0       	push   $0xc002ef90
c0022c06:	e8 13 69 00 00       	call   c002951e <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022c0b:	83 ec 0c             	sub    $0xc,%esp
c0022c0e:	ff 75 08             	push   0x8(%ebp)
c0022c11:	e8 46 00 00 00       	call   c0022c5c <lock_held_by_current_thread>
c0022c16:	83 c4 10             	add    $0x10,%esp
c0022c19:	84 c0                	test   %al,%al
c0022c1b:	75 21                	jne    c0022c3e <lock_release+0x60>
c0022c1d:	83 ec 0c             	sub    $0xc,%esp
c0022c20:	68 10 f0 02 c0       	push   $0xc002f010
c0022c25:	68 79 ef 02 c0       	push   $0xc002ef79
c0022c2a:	68 a0 f0 02 c0       	push   $0xc002f0a0
c0022c2f:	68 e8 00 00 00       	push   $0xe8
c0022c34:	68 90 ef 02 c0       	push   $0xc002ef90
c0022c39:	e8 e0 68 00 00       	call   c002951e <debug_panic>

  lock->holder = NULL;
c0022c3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0022c41:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_up (&lock->semaphore);
c0022c47:	8b 45 08             	mov    0x8(%ebp),%eax
c0022c4a:	83 c0 04             	add    $0x4,%eax
c0022c4d:	83 ec 0c             	sub    $0xc,%esp
c0022c50:	50                   	push   %eax
c0022c51:	e8 97 fc ff ff       	call   c00228ed <sema_up>
c0022c56:	83 c4 10             	add    $0x10,%esp
}
c0022c59:	90                   	nop
c0022c5a:	c9                   	leave  
c0022c5b:	c3                   	ret    

c0022c5c <lock_held_by_current_thread>:
/* Returns true if the current thread holds LOCK, false
   otherwise.  (Note that testing whether some other thread holds
   a lock would be racy.) */
bool
lock_held_by_current_thread (const struct lock *lock) 
{
c0022c5c:	55                   	push   %ebp
c0022c5d:	89 e5                	mov    %esp,%ebp
c0022c5f:	53                   	push   %ebx
c0022c60:	83 ec 04             	sub    $0x4,%esp
  ASSERT (lock != NULL);
c0022c63:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022c67:	75 21                	jne    c0022c8a <lock_held_by_current_thread+0x2e>
c0022c69:	83 ec 0c             	sub    $0xc,%esp
c0022c6c:	68 dd ef 02 c0       	push   $0xc002efdd
c0022c71:	68 79 ef 02 c0       	push   $0xc002ef79
c0022c76:	68 b0 f0 02 c0       	push   $0xc002f0b0
c0022c7b:	68 f4 00 00 00       	push   $0xf4
c0022c80:	68 90 ef 02 c0       	push   $0xc002ef90
c0022c85:	e8 94 68 00 00       	call   c002951e <debug_panic>

  return lock->holder == thread_current ();
c0022c8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0022c8d:	8b 18                	mov    (%eax),%ebx
c0022c8f:	e8 e4 df ff ff       	call   c0020c78 <thread_current>
c0022c94:	39 c3                	cmp    %eax,%ebx
c0022c96:	0f 94 c0             	sete   %al
}
c0022c99:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0022c9c:	c9                   	leave  
c0022c9d:	c3                   	ret    

c0022c9e <cond_init>:
/* Initializes condition variable COND.  A condition variable
   allows one piece of code to signal a condition and cooperating
   code to receive the signal and act upon it. */
void
cond_init (struct condition *cond)
{
c0022c9e:	55                   	push   %ebp
c0022c9f:	89 e5                	mov    %esp,%ebp
c0022ca1:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0022ca4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022ca8:	75 21                	jne    c0022ccb <cond_init+0x2d>
c0022caa:	83 ec 0c             	sub    $0xc,%esp
c0022cad:	68 33 f0 02 c0       	push   $0xc002f033
c0022cb2:	68 79 ef 02 c0       	push   $0xc002ef79
c0022cb7:	68 cc f0 02 c0       	push   $0xc002f0cc
c0022cbc:	68 06 01 00 00       	push   $0x106
c0022cc1:	68 90 ef 02 c0       	push   $0xc002ef90
c0022cc6:	e8 53 68 00 00       	call   c002951e <debug_panic>

  list_init (&cond->waiters);
c0022ccb:	8b 45 08             	mov    0x8(%ebp),%eax
c0022cce:	83 ec 0c             	sub    $0xc,%esp
c0022cd1:	50                   	push   %eax
c0022cd2:	e8 be 6a 00 00       	call   c0029795 <list_init>
c0022cd7:	83 c4 10             	add    $0x10,%esp
}
c0022cda:	90                   	nop
c0022cdb:	c9                   	leave  
c0022cdc:	c3                   	ret    

c0022cdd <cond_wait>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
cond_wait (struct condition *cond, struct lock *lock) 
{
c0022cdd:	55                   	push   %ebp
c0022cde:	89 e5                	mov    %esp,%ebp
c0022ce0:	83 ec 28             	sub    $0x28,%esp
  struct semaphore_elem waiter;

  ASSERT (cond != NULL);
c0022ce3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022ce7:	75 21                	jne    c0022d0a <cond_wait+0x2d>
c0022ce9:	83 ec 0c             	sub    $0xc,%esp
c0022cec:	68 33 f0 02 c0       	push   $0xc002f033
c0022cf1:	68 79 ef 02 c0       	push   $0xc002ef79
c0022cf6:	68 d8 f0 02 c0       	push   $0xc002f0d8
c0022cfb:	68 24 01 00 00       	push   $0x124
c0022d00:	68 90 ef 02 c0       	push   $0xc002ef90
c0022d05:	e8 14 68 00 00       	call   c002951e <debug_panic>
  ASSERT (lock != NULL);
c0022d0a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0022d0e:	75 21                	jne    c0022d31 <cond_wait+0x54>
c0022d10:	83 ec 0c             	sub    $0xc,%esp
c0022d13:	68 dd ef 02 c0       	push   $0xc002efdd
c0022d18:	68 79 ef 02 c0       	push   $0xc002ef79
c0022d1d:	68 d8 f0 02 c0       	push   $0xc002f0d8
c0022d22:	68 25 01 00 00       	push   $0x125
c0022d27:	68 90 ef 02 c0       	push   $0xc002ef90
c0022d2c:	e8 ed 67 00 00       	call   c002951e <debug_panic>
  ASSERT (!intr_context ());
c0022d31:	e8 34 e9 ff ff       	call   c002166a <intr_context>
c0022d36:	83 f0 01             	xor    $0x1,%eax
c0022d39:	84 c0                	test   %al,%al
c0022d3b:	75 21                	jne    c0022d5e <cond_wait+0x81>
c0022d3d:	83 ec 0c             	sub    $0xc,%esp
c0022d40:	68 a6 ef 02 c0       	push   $0xc002efa6
c0022d45:	68 79 ef 02 c0       	push   $0xc002ef79
c0022d4a:	68 d8 f0 02 c0       	push   $0xc002f0d8
c0022d4f:	68 26 01 00 00       	push   $0x126
c0022d54:	68 90 ef 02 c0       	push   $0xc002ef90
c0022d59:	e8 c0 67 00 00       	call   c002951e <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022d5e:	83 ec 0c             	sub    $0xc,%esp
c0022d61:	ff 75 0c             	push   0xc(%ebp)
c0022d64:	e8 f3 fe ff ff       	call   c0022c5c <lock_held_by_current_thread>
c0022d69:	83 c4 10             	add    $0x10,%esp
c0022d6c:	84 c0                	test   %al,%al
c0022d6e:	75 21                	jne    c0022d91 <cond_wait+0xb4>
c0022d70:	83 ec 0c             	sub    $0xc,%esp
c0022d73:	68 10 f0 02 c0       	push   $0xc002f010
c0022d78:	68 79 ef 02 c0       	push   $0xc002ef79
c0022d7d:	68 d8 f0 02 c0       	push   $0xc002f0d8
c0022d82:	68 27 01 00 00       	push   $0x127
c0022d87:	68 90 ef 02 c0       	push   $0xc002ef90
c0022d8c:	e8 8d 67 00 00       	call   c002951e <debug_panic>
  
  sema_init (&waiter.semaphore, 0);
c0022d91:	83 ec 08             	sub    $0x8,%esp
c0022d94:	6a 00                	push   $0x0
c0022d96:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0022d99:	83 c0 08             	add    $0x8,%eax
c0022d9c:	50                   	push   %eax
c0022d9d:	e8 fa f9 ff ff       	call   c002279c <sema_init>
c0022da2:	83 c4 10             	add    $0x10,%esp
  list_push_back (&cond->waiters, &waiter.elem);
c0022da5:	8b 45 08             	mov    0x8(%ebp),%eax
c0022da8:	83 ec 08             	sub    $0x8,%esp
c0022dab:	8d 55 dc             	lea    -0x24(%ebp),%edx
c0022dae:	52                   	push   %edx
c0022daf:	50                   	push   %eax
c0022db0:	e8 c0 6d 00 00       	call   c0029b75 <list_push_back>
c0022db5:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c0022db8:	83 ec 0c             	sub    $0xc,%esp
c0022dbb:	ff 75 0c             	push   0xc(%ebp)
c0022dbe:	e8 1b fe ff ff       	call   c0022bde <lock_release>
c0022dc3:	83 c4 10             	add    $0x10,%esp
  sema_down (&waiter.semaphore);
c0022dc6:	83 ec 0c             	sub    $0xc,%esp
c0022dc9:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0022dcc:	83 c0 08             	add    $0x8,%eax
c0022dcf:	50                   	push   %eax
c0022dd0:	e8 0e fa ff ff       	call   c00227e3 <sema_down>
c0022dd5:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c0022dd8:	83 ec 0c             	sub    $0xc,%esp
c0022ddb:	ff 75 0c             	push   0xc(%ebp)
c0022dde:	e8 bf fc ff ff       	call   c0022aa2 <lock_acquire>
c0022de3:	83 c4 10             	add    $0x10,%esp
}
c0022de6:	90                   	nop
c0022de7:	c9                   	leave  
c0022de8:	c3                   	ret    

c0022de9 <cond_signal>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal (struct condition *cond, struct lock *lock UNUSED) 
{
c0022de9:	55                   	push   %ebp
c0022dea:	89 e5                	mov    %esp,%ebp
c0022dec:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0022def:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022df3:	75 21                	jne    c0022e16 <cond_signal+0x2d>
c0022df5:	83 ec 0c             	sub    $0xc,%esp
c0022df8:	68 33 f0 02 c0       	push   $0xc002f033
c0022dfd:	68 79 ef 02 c0       	push   $0xc002ef79
c0022e02:	68 e4 f0 02 c0       	push   $0xc002f0e4
c0022e07:	68 3a 01 00 00       	push   $0x13a
c0022e0c:	68 90 ef 02 c0       	push   $0xc002ef90
c0022e11:	e8 08 67 00 00       	call   c002951e <debug_panic>
  ASSERT (lock != NULL);
c0022e16:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0022e1a:	75 21                	jne    c0022e3d <cond_signal+0x54>
c0022e1c:	83 ec 0c             	sub    $0xc,%esp
c0022e1f:	68 dd ef 02 c0       	push   $0xc002efdd
c0022e24:	68 79 ef 02 c0       	push   $0xc002ef79
c0022e29:	68 e4 f0 02 c0       	push   $0xc002f0e4
c0022e2e:	68 3b 01 00 00       	push   $0x13b
c0022e33:	68 90 ef 02 c0       	push   $0xc002ef90
c0022e38:	e8 e1 66 00 00       	call   c002951e <debug_panic>
  ASSERT (!intr_context ());
c0022e3d:	e8 28 e8 ff ff       	call   c002166a <intr_context>
c0022e42:	83 f0 01             	xor    $0x1,%eax
c0022e45:	84 c0                	test   %al,%al
c0022e47:	75 21                	jne    c0022e6a <cond_signal+0x81>
c0022e49:	83 ec 0c             	sub    $0xc,%esp
c0022e4c:	68 a6 ef 02 c0       	push   $0xc002efa6
c0022e51:	68 79 ef 02 c0       	push   $0xc002ef79
c0022e56:	68 e4 f0 02 c0       	push   $0xc002f0e4
c0022e5b:	68 3c 01 00 00       	push   $0x13c
c0022e60:	68 90 ef 02 c0       	push   $0xc002ef90
c0022e65:	e8 b4 66 00 00       	call   c002951e <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022e6a:	83 ec 0c             	sub    $0xc,%esp
c0022e6d:	ff 75 0c             	push   0xc(%ebp)
c0022e70:	e8 e7 fd ff ff       	call   c0022c5c <lock_held_by_current_thread>
c0022e75:	83 c4 10             	add    $0x10,%esp
c0022e78:	84 c0                	test   %al,%al
c0022e7a:	75 21                	jne    c0022e9d <cond_signal+0xb4>
c0022e7c:	83 ec 0c             	sub    $0xc,%esp
c0022e7f:	68 10 f0 02 c0       	push   $0xc002f010
c0022e84:	68 79 ef 02 c0       	push   $0xc002ef79
c0022e89:	68 e4 f0 02 c0       	push   $0xc002f0e4
c0022e8e:	68 3d 01 00 00       	push   $0x13d
c0022e93:	68 90 ef 02 c0       	push   $0xc002ef90
c0022e98:	e8 81 66 00 00       	call   c002951e <debug_panic>

  if (!list_empty (&cond->waiters)) 
c0022e9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ea0:	83 ec 0c             	sub    $0xc,%esp
c0022ea3:	50                   	push   %eax
c0022ea4:	e8 73 6e 00 00       	call   c0029d1c <list_empty>
c0022ea9:	83 c4 10             	add    $0x10,%esp
c0022eac:	83 f0 01             	xor    $0x1,%eax
c0022eaf:	84 c0                	test   %al,%al
c0022eb1:	74 24                	je     c0022ed7 <cond_signal+0xee>
    sema_up (&list_entry (list_pop_front (&cond->waiters),
c0022eb3:	8b 45 08             	mov    0x8(%ebp),%eax
c0022eb6:	83 ec 0c             	sub    $0xc,%esp
c0022eb9:	50                   	push   %eax
c0022eba:	e8 35 6d 00 00       	call   c0029bf4 <list_pop_front>
c0022ebf:	83 c4 10             	add    $0x10,%esp
c0022ec2:	83 c0 04             	add    $0x4,%eax
c0022ec5:	83 e8 04             	sub    $0x4,%eax
c0022ec8:	83 c0 08             	add    $0x8,%eax
c0022ecb:	83 ec 0c             	sub    $0xc,%esp
c0022ece:	50                   	push   %eax
c0022ecf:	e8 19 fa ff ff       	call   c00228ed <sema_up>
c0022ed4:	83 c4 10             	add    $0x10,%esp
                          struct semaphore_elem, elem)->semaphore);
}
c0022ed7:	90                   	nop
c0022ed8:	c9                   	leave  
c0022ed9:	c3                   	ret    

c0022eda <cond_broadcast>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast (struct condition *cond, struct lock *lock) 
{
c0022eda:	55                   	push   %ebp
c0022edb:	89 e5                	mov    %esp,%ebp
c0022edd:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0022ee0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022ee4:	75 21                	jne    c0022f07 <cond_broadcast+0x2d>
c0022ee6:	83 ec 0c             	sub    $0xc,%esp
c0022ee9:	68 33 f0 02 c0       	push   $0xc002f033
c0022eee:	68 79 ef 02 c0       	push   $0xc002ef79
c0022ef3:	68 f0 f0 02 c0       	push   $0xc002f0f0
c0022ef8:	68 4d 01 00 00       	push   $0x14d
c0022efd:	68 90 ef 02 c0       	push   $0xc002ef90
c0022f02:	e8 17 66 00 00       	call   c002951e <debug_panic>
  ASSERT (lock != NULL);
c0022f07:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0022f0b:	75 32                	jne    c0022f3f <cond_broadcast+0x65>
c0022f0d:	83 ec 0c             	sub    $0xc,%esp
c0022f10:	68 dd ef 02 c0       	push   $0xc002efdd
c0022f15:	68 79 ef 02 c0       	push   $0xc002ef79
c0022f1a:	68 f0 f0 02 c0       	push   $0xc002f0f0
c0022f1f:	68 4e 01 00 00       	push   $0x14e
c0022f24:	68 90 ef 02 c0       	push   $0xc002ef90
c0022f29:	e8 f0 65 00 00       	call   c002951e <debug_panic>

  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
c0022f2e:	83 ec 08             	sub    $0x8,%esp
c0022f31:	ff 75 0c             	push   0xc(%ebp)
c0022f34:	ff 75 08             	push   0x8(%ebp)
c0022f37:	e8 ad fe ff ff       	call   c0022de9 <cond_signal>
c0022f3c:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&cond->waiters))
c0022f3f:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f42:	83 ec 0c             	sub    $0xc,%esp
c0022f45:	50                   	push   %eax
c0022f46:	e8 d1 6d 00 00       	call   c0029d1c <list_empty>
c0022f4b:	83 c4 10             	add    $0x10,%esp
c0022f4e:	83 f0 01             	xor    $0x1,%eax
c0022f51:	84 c0                	test   %al,%al
c0022f53:	75 d9                	jne    c0022f2e <cond_broadcast+0x54>
}
c0022f55:	90                   	nop
c0022f56:	90                   	nop
c0022f57:	c9                   	leave  
c0022f58:	c3                   	ret    

c0022f59 <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c0022f59:	55                   	push   %ebp
c0022f5a:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0022f5c:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f5f:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c0022f64:	5d                   	pop    %ebp
c0022f65:	c3                   	ret    

c0022f66 <pg_no>:
static inline uintptr_t pg_no (const void *va) {
c0022f66:	55                   	push   %ebp
c0022f67:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PGBITS;
c0022f69:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f6c:	c1 e8 0c             	shr    $0xc,%eax
}
c0022f6f:	5d                   	pop    %ebp
c0022f70:	c3                   	ret    

c0022f71 <ptov>:
{
c0022f71:	55                   	push   %ebp
c0022f72:	89 e5                	mov    %esp,%ebp
c0022f74:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c0022f77:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f7a:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0022f7f:	76 1e                	jbe    c0022f9f <ptov+0x2e>
c0022f81:	83 ec 0c             	sub    $0xc,%esp
c0022f84:	68 00 f1 02 c0       	push   $0xc002f100
c0022f89:	68 1b f1 02 c0       	push   $0xc002f11b
c0022f8e:	68 38 f2 02 c0       	push   $0xc002f238
c0022f93:	6a 4a                	push   $0x4a
c0022f95:	68 32 f1 02 c0       	push   $0xc002f132
c0022f9a:	e8 7f 65 00 00       	call   c002951e <debug_panic>
  return (void *) (paddr + PHYS_BASE);
c0022f9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0022fa2:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c0022fa7:	c9                   	leave  
c0022fa8:	c3                   	ret    

c0022fa9 <palloc_init>:

/* Initializes the page allocator.  At most USER_PAGE_LIMIT
   pages are put into the user pool. */
void
palloc_init (size_t user_page_limit)
{
c0022fa9:	55                   	push   %ebp
c0022faa:	89 e5                	mov    %esp,%ebp
c0022fac:	83 ec 28             	sub    $0x28,%esp
  /* Free memory starts at 1 MB and runs to the end of RAM. */
  uint8_t *free_start = ptov (1024 * 1024);
c0022faf:	83 ec 0c             	sub    $0xc,%esp
c0022fb2:	68 00 00 10 00       	push   $0x100000
c0022fb7:	e8 b5 ff ff ff       	call   c0022f71 <ptov>
c0022fbc:	83 c4 10             	add    $0x10,%esp
c0022fbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c0022fc2:	a1 7e 01 02 c0       	mov    0xc002017e,%eax
c0022fc7:	c1 e0 0c             	shl    $0xc,%eax
c0022fca:	83 ec 0c             	sub    $0xc,%esp
c0022fcd:	50                   	push   %eax
c0022fce:	e8 9e ff ff ff       	call   c0022f71 <ptov>
c0022fd3:	83 c4 10             	add    $0x10,%esp
c0022fd6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  size_t free_pages = (free_end - free_start) / PGSIZE;
c0022fd9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0022fdc:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0022fdf:	85 c0                	test   %eax,%eax
c0022fe1:	79 05                	jns    c0022fe8 <palloc_init+0x3f>
c0022fe3:	05 ff 0f 00 00       	add    $0xfff,%eax
c0022fe8:	c1 f8 0c             	sar    $0xc,%eax
c0022feb:	89 45 e8             	mov    %eax,-0x18(%ebp)
  size_t user_pages = free_pages / 2;
c0022fee:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0022ff1:	d1 e8                	shr    %eax
c0022ff3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t kernel_pages;
  if (user_pages > user_page_limit)
c0022ff6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0022ff9:	3b 45 08             	cmp    0x8(%ebp),%eax
c0022ffc:	76 06                	jbe    c0023004 <palloc_init+0x5b>
    user_pages = user_page_limit;
c0022ffe:	8b 45 08             	mov    0x8(%ebp),%eax
c0023001:	89 45 f4             	mov    %eax,-0xc(%ebp)
  kernel_pages = free_pages - user_pages;
c0023004:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023007:	2b 45 f4             	sub    -0xc(%ebp),%eax
c002300a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Give half of memory to kernel, half to user. */
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c002300d:	68 48 f1 02 c0       	push   $0xc002f148
c0023012:	ff 75 e4             	push   -0x1c(%ebp)
c0023015:	ff 75 f0             	push   -0x10(%ebp)
c0023018:	68 60 4e 03 c0       	push   $0xc0034e60
c002301d:	e8 6e 02 00 00       	call   c0023290 <init_pool>
c0023022:	83 c4 10             	add    $0x10,%esp
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c0023025:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023028:	c1 e0 0c             	shl    $0xc,%eax
c002302b:	89 c2                	mov    %eax,%edx
c002302d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023030:	01 d0                	add    %edx,%eax
c0023032:	68 54 f1 02 c0       	push   $0xc002f154
c0023037:	ff 75 f4             	push   -0xc(%ebp)
c002303a:	50                   	push   %eax
c002303b:	68 80 4e 03 c0       	push   $0xc0034e80
c0023040:	e8 4b 02 00 00       	call   c0023290 <init_pool>
c0023045:	83 c4 10             	add    $0x10,%esp
             user_pages, "user pool");
}
c0023048:	90                   	nop
c0023049:	c9                   	leave  
c002304a:	c3                   	ret    

c002304b <palloc_get_multiple>:
   then the pages are filled with zeros.  If too few pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
{
c002304b:	55                   	push   %ebp
c002304c:	89 e5                	mov    %esp,%ebp
c002304e:	83 ec 18             	sub    $0x18,%esp
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c0023051:	8b 45 08             	mov    0x8(%ebp),%eax
c0023054:	83 e0 04             	and    $0x4,%eax
c0023057:	85 c0                	test   %eax,%eax
c0023059:	74 07                	je     c0023062 <palloc_get_multiple+0x17>
c002305b:	b8 80 4e 03 c0       	mov    $0xc0034e80,%eax
c0023060:	eb 05                	jmp    c0023067 <palloc_get_multiple+0x1c>
c0023062:	b8 60 4e 03 c0       	mov    $0xc0034e60,%eax
c0023067:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void *pages;
  size_t page_idx;

  if (page_cnt == 0)
c002306a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002306e:	75 0a                	jne    c002307a <palloc_get_multiple+0x2f>
    return NULL;
c0023070:	b8 00 00 00 00       	mov    $0x0,%eax
c0023075:	e9 a3 00 00 00       	jmp    c002311d <palloc_get_multiple+0xd2>

  lock_acquire (&pool->lock);
c002307a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002307d:	83 ec 0c             	sub    $0xc,%esp
c0023080:	50                   	push   %eax
c0023081:	e8 1c fa ff ff       	call   c0022aa2 <lock_acquire>
c0023086:	83 c4 10             	add    $0x10,%esp
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c0023089:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002308c:	8b 40 18             	mov    0x18(%eax),%eax
c002308f:	6a 00                	push   $0x0
c0023091:	ff 75 0c             	push   0xc(%ebp)
c0023094:	6a 00                	push   $0x0
c0023096:	50                   	push   %eax
c0023097:	e8 ae 7b 00 00       	call   c002ac4a <bitmap_scan_and_flip>
c002309c:	83 c4 10             	add    $0x10,%esp
c002309f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  lock_release (&pool->lock);
c00230a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00230a5:	83 ec 0c             	sub    $0xc,%esp
c00230a8:	50                   	push   %eax
c00230a9:	e8 30 fb ff ff       	call   c0022bde <lock_release>
c00230ae:	83 c4 10             	add    $0x10,%esp

  if (page_idx != BITMAP_ERROR)
c00230b1:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00230b5:	74 13                	je     c00230ca <palloc_get_multiple+0x7f>
    pages = pool->base + PGSIZE * page_idx;
c00230b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00230ba:	8b 40 1c             	mov    0x1c(%eax),%eax
c00230bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00230c0:	c1 e2 0c             	shl    $0xc,%edx
c00230c3:	01 d0                	add    %edx,%eax
c00230c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00230c8:	eb 07                	jmp    c00230d1 <palloc_get_multiple+0x86>
  else
    pages = NULL;
c00230ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  if (pages != NULL) 
c00230d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00230d5:	74 23                	je     c00230fa <palloc_get_multiple+0xaf>
    {
      if (flags & PAL_ZERO)
c00230d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00230da:	83 e0 02             	and    $0x2,%eax
c00230dd:	85 c0                	test   %eax,%eax
c00230df:	74 39                	je     c002311a <palloc_get_multiple+0xcf>
        memset (pages, 0, PGSIZE * page_cnt);
c00230e1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00230e4:	c1 e0 0c             	shl    $0xc,%eax
c00230e7:	83 ec 04             	sub    $0x4,%esp
c00230ea:	50                   	push   %eax
c00230eb:	6a 00                	push   $0x0
c00230ed:	ff 75 f4             	push   -0xc(%ebp)
c00230f0:	e8 55 58 00 00       	call   c002894a <memset>
c00230f5:	83 c4 10             	add    $0x10,%esp
c00230f8:	eb 20                	jmp    c002311a <palloc_get_multiple+0xcf>
    }
  else 
    {
      if (flags & PAL_ASSERT)
c00230fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00230fd:	83 e0 01             	and    $0x1,%eax
c0023100:	85 c0                	test   %eax,%eax
c0023102:	74 16                	je     c002311a <palloc_get_multiple+0xcf>
        PANIC ("palloc_get: out of pages");
c0023104:	68 5e f1 02 c0       	push   $0xc002f15e
c0023109:	68 40 f2 02 c0       	push   $0xc002f240
c002310e:	6a 61                	push   $0x61
c0023110:	68 77 f1 02 c0       	push   $0xc002f177
c0023115:	e8 04 64 00 00       	call   c002951e <debug_panic>
    }

  return pages;
c002311a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002311d:	c9                   	leave  
c002311e:	c3                   	ret    

c002311f <palloc_get_page>:
   then the page is filled with zeros.  If no pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_page (enum palloc_flags flags) 
{
c002311f:	55                   	push   %ebp
c0023120:	89 e5                	mov    %esp,%ebp
c0023122:	83 ec 08             	sub    $0x8,%esp
  return palloc_get_multiple (flags, 1);
c0023125:	83 ec 08             	sub    $0x8,%esp
c0023128:	6a 01                	push   $0x1
c002312a:	ff 75 08             	push   0x8(%ebp)
c002312d:	e8 19 ff ff ff       	call   c002304b <palloc_get_multiple>
c0023132:	83 c4 10             	add    $0x10,%esp
}
c0023135:	c9                   	leave  
c0023136:	c3                   	ret    

c0023137 <palloc_free_multiple>:

/* Frees the PAGE_CNT pages starting at PAGES. */
void
palloc_free_multiple (void *pages, size_t page_cnt) 
{
c0023137:	55                   	push   %ebp
c0023138:	89 e5                	mov    %esp,%ebp
c002313a:	53                   	push   %ebx
c002313b:	83 ec 14             	sub    $0x14,%esp
  struct pool *pool;
  size_t page_idx;

  ASSERT (pg_ofs (pages) == 0);
c002313e:	ff 75 08             	push   0x8(%ebp)
c0023141:	e8 13 fe ff ff       	call   c0022f59 <pg_ofs>
c0023146:	83 c4 04             	add    $0x4,%esp
c0023149:	85 c0                	test   %eax,%eax
c002314b:	74 1e                	je     c002316b <palloc_free_multiple+0x34>
c002314d:	83 ec 0c             	sub    $0xc,%esp
c0023150:	68 8e f1 02 c0       	push   $0xc002f18e
c0023155:	68 1b f1 02 c0       	push   $0xc002f11b
c002315a:	68 54 f2 02 c0       	push   $0xc002f254
c002315f:	6a 7b                	push   $0x7b
c0023161:	68 77 f1 02 c0       	push   $0xc002f177
c0023166:	e8 b3 63 00 00       	call   c002951e <debug_panic>
  if (pages == NULL || page_cnt == 0)
c002316b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002316f:	0f 84 fc 00 00 00    	je     c0023271 <palloc_free_multiple+0x13a>
c0023175:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023179:	0f 84 f2 00 00 00    	je     c0023271 <palloc_free_multiple+0x13a>
    return;

  if (page_from_pool (&kernel_pool, pages))
c002317f:	83 ec 08             	sub    $0x8,%esp
c0023182:	ff 75 08             	push   0x8(%ebp)
c0023185:	68 60 4e 03 c0       	push   $0xc0034e60
c002318a:	e8 a6 01 00 00       	call   c0023335 <page_from_pool>
c002318f:	83 c4 10             	add    $0x10,%esp
c0023192:	84 c0                	test   %al,%al
c0023194:	74 09                	je     c002319f <palloc_free_multiple+0x68>
    pool = &kernel_pool;
c0023196:	c7 45 f4 60 4e 03 c0 	movl   $0xc0034e60,-0xc(%ebp)
c002319d:	eb 39                	jmp    c00231d8 <palloc_free_multiple+0xa1>
  else if (page_from_pool (&user_pool, pages))
c002319f:	83 ec 08             	sub    $0x8,%esp
c00231a2:	ff 75 08             	push   0x8(%ebp)
c00231a5:	68 80 4e 03 c0       	push   $0xc0034e80
c00231aa:	e8 86 01 00 00       	call   c0023335 <page_from_pool>
c00231af:	83 c4 10             	add    $0x10,%esp
c00231b2:	84 c0                	test   %al,%al
c00231b4:	74 09                	je     c00231bf <palloc_free_multiple+0x88>
    pool = &user_pool;
c00231b6:	c7 45 f4 80 4e 03 c0 	movl   $0xc0034e80,-0xc(%ebp)
c00231bd:	eb 19                	jmp    c00231d8 <palloc_free_multiple+0xa1>
  else
    NOT_REACHED ();
c00231bf:	68 a4 f1 02 c0       	push   $0xc002f1a4
c00231c4:	68 54 f2 02 c0       	push   $0xc002f254
c00231c9:	68 84 00 00 00       	push   $0x84
c00231ce:	68 77 f1 02 c0       	push   $0xc002f177
c00231d3:	e8 46 63 00 00       	call   c002951e <debug_panic>

  page_idx = pg_no (pages) - pg_no (pool->base);
c00231d8:	83 ec 0c             	sub    $0xc,%esp
c00231db:	ff 75 08             	push   0x8(%ebp)
c00231de:	e8 83 fd ff ff       	call   c0022f66 <pg_no>
c00231e3:	83 c4 10             	add    $0x10,%esp
c00231e6:	89 c3                	mov    %eax,%ebx
c00231e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00231eb:	8b 40 1c             	mov    0x1c(%eax),%eax
c00231ee:	83 ec 0c             	sub    $0xc,%esp
c00231f1:	50                   	push   %eax
c00231f2:	e8 6f fd ff ff       	call   c0022f66 <pg_no>
c00231f7:	83 c4 10             	add    $0x10,%esp
c00231fa:	89 da                	mov    %ebx,%edx
c00231fc:	29 c2                	sub    %eax,%edx
c00231fe:	89 55 f0             	mov    %edx,-0x10(%ebp)

#ifndef NDEBUG
  memset (pages, 0xcc, PGSIZE * page_cnt);
c0023201:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023204:	c1 e0 0c             	shl    $0xc,%eax
c0023207:	83 ec 04             	sub    $0x4,%esp
c002320a:	50                   	push   %eax
c002320b:	68 cc 00 00 00       	push   $0xcc
c0023210:	ff 75 08             	push   0x8(%ebp)
c0023213:	e8 32 57 00 00       	call   c002894a <memset>
c0023218:	83 c4 10             	add    $0x10,%esp
#endif

  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c002321b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002321e:	8b 40 18             	mov    0x18(%eax),%eax
c0023221:	83 ec 04             	sub    $0x4,%esp
c0023224:	ff 75 0c             	push   0xc(%ebp)
c0023227:	ff 75 f0             	push   -0x10(%ebp)
c002322a:	50                   	push   %eax
c002322b:	e8 2e 79 00 00       	call   c002ab5e <bitmap_all>
c0023230:	83 c4 10             	add    $0x10,%esp
c0023233:	84 c0                	test   %al,%al
c0023235:	75 21                	jne    c0023258 <palloc_free_multiple+0x121>
c0023237:	83 ec 0c             	sub    $0xc,%esp
c002323a:	68 c8 f1 02 c0       	push   $0xc002f1c8
c002323f:	68 1b f1 02 c0       	push   $0xc002f11b
c0023244:	68 54 f2 02 c0       	push   $0xc002f254
c0023249:	68 8c 00 00 00       	push   $0x8c
c002324e:	68 77 f1 02 c0       	push   $0xc002f177
c0023253:	e8 c6 62 00 00       	call   c002951e <debug_panic>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c0023258:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002325b:	8b 40 18             	mov    0x18(%eax),%eax
c002325e:	6a 00                	push   $0x0
c0023260:	ff 75 0c             	push   0xc(%ebp)
c0023263:	ff 75 f0             	push   -0x10(%ebp)
c0023266:	50                   	push   %eax
c0023267:	e8 50 76 00 00       	call   c002a8bc <bitmap_set_multiple>
c002326c:	83 c4 10             	add    $0x10,%esp
c002326f:	eb 01                	jmp    c0023272 <palloc_free_multiple+0x13b>
    return;
c0023271:	90                   	nop
}
c0023272:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023275:	c9                   	leave  
c0023276:	c3                   	ret    

c0023277 <palloc_free_page>:

/* Frees the page at PAGE. */
void
palloc_free_page (void *page) 
{
c0023277:	55                   	push   %ebp
c0023278:	89 e5                	mov    %esp,%ebp
c002327a:	83 ec 08             	sub    $0x8,%esp
  palloc_free_multiple (page, 1);
c002327d:	83 ec 08             	sub    $0x8,%esp
c0023280:	6a 01                	push   $0x1
c0023282:	ff 75 08             	push   0x8(%ebp)
c0023285:	e8 ad fe ff ff       	call   c0023137 <palloc_free_multiple>
c002328a:	83 c4 10             	add    $0x10,%esp
}
c002328d:	90                   	nop
c002328e:	c9                   	leave  
c002328f:	c3                   	ret    

c0023290 <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c0023290:	55                   	push   %ebp
c0023291:	89 e5                	mov    %esp,%ebp
c0023293:	83 ec 18             	sub    $0x18,%esp
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c0023296:	83 ec 0c             	sub    $0xc,%esp
c0023299:	ff 75 10             	push   0x10(%ebp)
c002329c:	e8 b1 73 00 00       	call   c002a652 <bitmap_buf_size>
c00232a1:	83 c4 10             	add    $0x10,%esp
c00232a4:	05 ff 0f 00 00       	add    $0xfff,%eax
c00232a9:	c1 e8 0c             	shr    $0xc,%eax
c00232ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (bm_pages > page_cnt)
c00232af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00232b2:	3b 45 10             	cmp    0x10(%ebp),%eax
c00232b5:	76 1f                	jbe    c00232d6 <init_pool+0x46>
    PANIC ("Not enough memory in %s for bitmap.", name);
c00232b7:	83 ec 0c             	sub    $0xc,%esp
c00232ba:	ff 75 14             	push   0x14(%ebp)
c00232bd:	68 f8 f1 02 c0       	push   $0xc002f1f8
c00232c2:	68 6c f2 02 c0       	push   $0xc002f26c
c00232c7:	68 a1 00 00 00       	push   $0xa1
c00232cc:	68 77 f1 02 c0       	push   $0xc002f177
c00232d1:	e8 48 62 00 00       	call   c002951e <debug_panic>
  page_cnt -= bm_pages;
c00232d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00232d9:	29 45 10             	sub    %eax,0x10(%ebp)

  printf ("%zu pages available in %s.\n", page_cnt, name);
c00232dc:	83 ec 04             	sub    $0x4,%esp
c00232df:	ff 75 14             	push   0x14(%ebp)
c00232e2:	ff 75 10             	push   0x10(%ebp)
c00232e5:	68 1c f2 02 c0       	push   $0xc002f21c
c00232ea:	e8 8d 3e 00 00       	call   c002717c <printf>
c00232ef:	83 c4 10             	add    $0x10,%esp

  /* Initialize the pool. */
  lock_init (&p->lock);
c00232f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00232f5:	83 ec 0c             	sub    $0xc,%esp
c00232f8:	50                   	push   %eax
c00232f9:	e8 57 f7 ff ff       	call   c0022a55 <lock_init>
c00232fe:	83 c4 10             	add    $0x10,%esp
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c0023301:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023304:	c1 e0 0c             	shl    $0xc,%eax
c0023307:	83 ec 04             	sub    $0x4,%esp
c002330a:	50                   	push   %eax
c002330b:	ff 75 0c             	push   0xc(%ebp)
c002330e:	ff 75 10             	push   0x10(%ebp)
c0023311:	e8 d6 72 00 00       	call   c002a5ec <bitmap_create_in_buf>
c0023316:	83 c4 10             	add    $0x10,%esp
c0023319:	8b 55 08             	mov    0x8(%ebp),%edx
c002331c:	89 42 18             	mov    %eax,0x18(%edx)
  p->base = base + bm_pages * PGSIZE;
c002331f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023322:	c1 e0 0c             	shl    $0xc,%eax
c0023325:	89 c2                	mov    %eax,%edx
c0023327:	8b 45 0c             	mov    0xc(%ebp),%eax
c002332a:	01 c2                	add    %eax,%edx
c002332c:	8b 45 08             	mov    0x8(%ebp),%eax
c002332f:	89 50 1c             	mov    %edx,0x1c(%eax)
}
c0023332:	90                   	nop
c0023333:	c9                   	leave  
c0023334:	c3                   	ret    

c0023335 <page_from_pool>:

/* Returns true if PAGE was allocated from POOL,
   false otherwise. */
static bool
page_from_pool (const struct pool *pool, void *page) 
{
c0023335:	55                   	push   %ebp
c0023336:	89 e5                	mov    %esp,%ebp
c0023338:	83 ec 18             	sub    $0x18,%esp
  size_t page_no = pg_no (page);
c002333b:	ff 75 0c             	push   0xc(%ebp)
c002333e:	e8 23 fc ff ff       	call   c0022f66 <pg_no>
c0023343:	83 c4 04             	add    $0x4,%esp
c0023346:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t start_page = pg_no (pool->base);
c0023349:	8b 45 08             	mov    0x8(%ebp),%eax
c002334c:	8b 40 1c             	mov    0x1c(%eax),%eax
c002334f:	50                   	push   %eax
c0023350:	e8 11 fc ff ff       	call   c0022f66 <pg_no>
c0023355:	83 c4 04             	add    $0x4,%esp
c0023358:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t end_page = start_page + bitmap_size (pool->used_map);
c002335b:	8b 45 08             	mov    0x8(%ebp),%eax
c002335e:	8b 40 18             	mov    0x18(%eax),%eax
c0023361:	83 ec 0c             	sub    $0xc,%esp
c0023364:	50                   	push   %eax
c0023365:	e8 2a 73 00 00       	call   c002a694 <bitmap_size>
c002336a:	83 c4 10             	add    $0x10,%esp
c002336d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0023370:	01 d0                	add    %edx,%eax
c0023372:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return page_no >= start_page && page_no < end_page;
c0023375:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023378:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002337b:	72 0f                	jb     c002338c <page_from_pool+0x57>
c002337d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023380:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0023383:	73 07                	jae    c002338c <page_from_pool+0x57>
c0023385:	b8 01 00 00 00       	mov    $0x1,%eax
c002338a:	eb 05                	jmp    c0023391 <page_from_pool+0x5c>
c002338c:	b8 00 00 00 00       	mov    $0x0,%eax
c0023391:	83 e0 01             	and    $0x1,%eax
}
c0023394:	c9                   	leave  
c0023395:	c3                   	ret    

c0023396 <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c0023396:	55                   	push   %ebp
c0023397:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0023399:	8b 45 08             	mov    0x8(%ebp),%eax
c002339c:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c00233a1:	5d                   	pop    %ebp
c00233a2:	c3                   	ret    

c00233a3 <pg_round_down>:
static inline void *pg_round_down (const void *va) {
c00233a3:	55                   	push   %ebp
c00233a4:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c00233a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00233a9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c00233ae:	5d                   	pop    %ebp
c00233af:	c3                   	ret    

c00233b0 <malloc_init>:
static struct block *arena_to_block (struct arena *, size_t idx);

/* Initializes the malloc() descriptors. */
void
malloc_init (void) 
{
c00233b0:	55                   	push   %ebp
c00233b1:	89 e5                	mov    %esp,%ebp
c00233b3:	83 ec 18             	sub    $0x18,%esp
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c00233b6:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
c00233bd:	e9 90 00 00 00       	jmp    c0023452 <malloc_init+0xa2>
    {
      struct desc *d = &descs[desc_cnt++];
c00233c2:	8b 15 80 50 03 c0    	mov    0xc0035080,%edx
c00233c8:	8d 42 01             	lea    0x1(%edx),%eax
c00233cb:	a3 80 50 03 c0       	mov    %eax,0xc0035080
c00233d0:	89 d0                	mov    %edx,%eax
c00233d2:	01 c0                	add    %eax,%eax
c00233d4:	01 d0                	add    %edx,%eax
c00233d6:	c1 e0 04             	shl    $0x4,%eax
c00233d9:	05 a0 4e 03 c0       	add    $0xc0034ea0,%eax
c00233de:	89 45 f0             	mov    %eax,-0x10(%ebp)
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c00233e1:	a1 80 50 03 c0       	mov    0xc0035080,%eax
c00233e6:	83 f8 0a             	cmp    $0xa,%eax
c00233e9:	76 1e                	jbe    c0023409 <malloc_init+0x59>
c00233eb:	83 ec 0c             	sub    $0xc,%esp
c00233ee:	68 78 f2 02 c0       	push   $0xc002f278
c00233f3:	68 a1 f2 02 c0       	push   $0xc002f2a1
c00233f8:	68 ac f3 02 c0       	push   $0xc002f3ac
c00233fd:	6a 4f                	push   $0x4f
c00233ff:	68 b8 f2 02 c0       	push   $0xc002f2b8
c0023404:	e8 15 61 00 00       	call   c002951e <debug_panic>
      d->block_size = block_size;
c0023409:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002340c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002340f:	89 10                	mov    %edx,(%eax)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023411:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c0023416:	ba 00 00 00 00       	mov    $0x0,%edx
c002341b:	f7 75 f4             	divl   -0xc(%ebp)
c002341e:	89 c2                	mov    %eax,%edx
c0023420:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023423:	89 50 04             	mov    %edx,0x4(%eax)
      list_init (&d->free_list);
c0023426:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023429:	83 c0 08             	add    $0x8,%eax
c002342c:	83 ec 0c             	sub    $0xc,%esp
c002342f:	50                   	push   %eax
c0023430:	e8 60 63 00 00       	call   c0029795 <list_init>
c0023435:	83 c4 10             	add    $0x10,%esp
      lock_init (&d->lock);
c0023438:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002343b:	83 c0 18             	add    $0x18,%eax
c002343e:	83 ec 0c             	sub    $0xc,%esp
c0023441:	50                   	push   %eax
c0023442:	e8 0e f6 ff ff       	call   c0022a55 <lock_init>
c0023447:	83 c4 10             	add    $0x10,%esp
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c002344a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002344d:	01 c0                	add    %eax,%eax
c002344f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023452:	81 7d f4 ff 07 00 00 	cmpl   $0x7ff,-0xc(%ebp)
c0023459:	0f 86 63 ff ff ff    	jbe    c00233c2 <malloc_init+0x12>
    }
}
c002345f:	90                   	nop
c0023460:	90                   	nop
c0023461:	c9                   	leave  
c0023462:	c3                   	ret    

c0023463 <malloc>:

/* Obtains and returns a new block of at least SIZE bytes.
   Returns a null pointer if memory is not available. */
void *
malloc (size_t size) 
{
c0023463:	55                   	push   %ebp
c0023464:	89 e5                	mov    %esp,%ebp
c0023466:	83 ec 28             	sub    $0x28,%esp
  struct desc *d;
  struct block *b;
  struct arena *a;

  /* A null pointer satisfies a request for 0 bytes. */
  if (size == 0)
c0023469:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002346d:	75 0a                	jne    c0023479 <malloc+0x16>
    return NULL;
c002346f:	b8 00 00 00 00       	mov    $0x0,%eax
c0023474:	e9 b1 01 00 00       	jmp    c002362a <malloc+0x1c7>

  /* Find the smallest descriptor that satisfies a SIZE-byte
     request. */
  for (d = descs; d < descs + desc_cnt; d++)
c0023479:	c7 45 f4 a0 4e 03 c0 	movl   $0xc0034ea0,-0xc(%ebp)
c0023480:	eb 0e                	jmp    c0023490 <malloc+0x2d>
    if (d->block_size >= size)
c0023482:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023485:	8b 00                	mov    (%eax),%eax
c0023487:	39 45 08             	cmp    %eax,0x8(%ebp)
c002348a:	76 1f                	jbe    c00234ab <malloc+0x48>
  for (d = descs; d < descs + desc_cnt; d++)
c002348c:	83 45 f4 30          	addl   $0x30,-0xc(%ebp)
c0023490:	8b 15 80 50 03 c0    	mov    0xc0035080,%edx
c0023496:	89 d0                	mov    %edx,%eax
c0023498:	01 c0                	add    %eax,%eax
c002349a:	01 d0                	add    %edx,%eax
c002349c:	c1 e0 04             	shl    $0x4,%eax
c002349f:	05 a0 4e 03 c0       	add    $0xc0034ea0,%eax
c00234a4:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00234a7:	72 d9                	jb     c0023482 <malloc+0x1f>
c00234a9:	eb 01                	jmp    c00234ac <malloc+0x49>
      break;
c00234ab:	90                   	nop
  if (d == descs + desc_cnt) 
c00234ac:	8b 15 80 50 03 c0    	mov    0xc0035080,%edx
c00234b2:	89 d0                	mov    %edx,%eax
c00234b4:	01 c0                	add    %eax,%eax
c00234b6:	01 d0                	add    %edx,%eax
c00234b8:	c1 e0 04             	shl    $0x4,%eax
c00234bb:	05 a0 4e 03 c0       	add    $0xc0034ea0,%eax
c00234c0:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00234c3:	75 58                	jne    c002351d <malloc+0xba>
    {
      /* SIZE is too big for any descriptor.
         Allocate enough pages to hold SIZE plus an arena. */
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c00234c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00234c8:	05 0b 10 00 00       	add    $0x100b,%eax
c00234cd:	c1 e8 0c             	shr    $0xc,%eax
c00234d0:	89 45 e0             	mov    %eax,-0x20(%ebp)
      a = palloc_get_multiple (0, page_cnt);
c00234d3:	83 ec 08             	sub    $0x8,%esp
c00234d6:	ff 75 e0             	push   -0x20(%ebp)
c00234d9:	6a 00                	push   $0x0
c00234db:	e8 6b fb ff ff       	call   c002304b <palloc_get_multiple>
c00234e0:	83 c4 10             	add    $0x10,%esp
c00234e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if (a == NULL)
c00234e6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00234ea:	75 0a                	jne    c00234f6 <malloc+0x93>
        return NULL;
c00234ec:	b8 00 00 00 00       	mov    $0x0,%eax
c00234f1:	e9 34 01 00 00       	jmp    c002362a <malloc+0x1c7>

      /* Initialize the arena to indicate a big block of PAGE_CNT
         pages, and return it. */
      a->magic = ARENA_MAGIC;
c00234f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00234f9:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c00234ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023502:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c0023509:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002350c:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002350f:	89 50 08             	mov    %edx,0x8(%eax)
      return a + 1;
c0023512:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023515:	83 c0 0c             	add    $0xc,%eax
c0023518:	e9 0d 01 00 00       	jmp    c002362a <malloc+0x1c7>
    }

  lock_acquire (&d->lock);
c002351d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023520:	83 c0 18             	add    $0x18,%eax
c0023523:	83 ec 0c             	sub    $0xc,%esp
c0023526:	50                   	push   %eax
c0023527:	e8 76 f5 ff ff       	call   c0022aa2 <lock_acquire>
c002352c:	83 c4 10             	add    $0x10,%esp

  /* If the free list is empty, create a new arena. */
  if (list_empty (&d->free_list))
c002352f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023532:	83 c0 08             	add    $0x8,%eax
c0023535:	83 ec 0c             	sub    $0xc,%esp
c0023538:	50                   	push   %eax
c0023539:	e8 de 67 00 00       	call   c0029d1c <list_empty>
c002353e:	83 c4 10             	add    $0x10,%esp
c0023541:	84 c0                	test   %al,%al
c0023543:	0f 84 91 00 00 00    	je     c00235da <malloc+0x177>
    {
      size_t i;

      /* Allocate a page. */
      a = palloc_get_page (0);
c0023549:	83 ec 0c             	sub    $0xc,%esp
c002354c:	6a 00                	push   $0x0
c002354e:	e8 cc fb ff ff       	call   c002311f <palloc_get_page>
c0023553:	83 c4 10             	add    $0x10,%esp
c0023556:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if (a == NULL) 
c0023559:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002355d:	75 1c                	jne    c002357b <malloc+0x118>
        {
          lock_release (&d->lock);
c002355f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023562:	83 c0 18             	add    $0x18,%eax
c0023565:	83 ec 0c             	sub    $0xc,%esp
c0023568:	50                   	push   %eax
c0023569:	e8 70 f6 ff ff       	call   c0022bde <lock_release>
c002356e:	83 c4 10             	add    $0x10,%esp
          return NULL; 
c0023571:	b8 00 00 00 00       	mov    $0x0,%eax
c0023576:	e9 af 00 00 00       	jmp    c002362a <malloc+0x1c7>
        }

      /* Initialize arena and add its blocks to the free list. */
      a->magic = ARENA_MAGIC;
c002357b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002357e:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = d;
c0023584:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023587:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002358a:	89 50 04             	mov    %edx,0x4(%eax)
      a->free_cnt = d->blocks_per_arena;
c002358d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023590:	8b 50 04             	mov    0x4(%eax),%edx
c0023593:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023596:	89 50 08             	mov    %edx,0x8(%eax)
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023599:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00235a0:	eb 2d                	jmp    c00235cf <malloc+0x16c>
        {
          struct block *b = arena_to_block (a, i);
c00235a2:	83 ec 08             	sub    $0x8,%esp
c00235a5:	ff 75 f0             	push   -0x10(%ebp)
c00235a8:	ff 75 ec             	push   -0x14(%ebp)
c00235ab:	e8 ec 03 00 00       	call   c002399c <arena_to_block>
c00235b0:	83 c4 10             	add    $0x10,%esp
c00235b3:	89 45 e8             	mov    %eax,-0x18(%ebp)
          list_push_back (&d->free_list, &b->free_elem);
c00235b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00235b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00235bc:	83 c2 08             	add    $0x8,%edx
c00235bf:	83 ec 08             	sub    $0x8,%esp
c00235c2:	50                   	push   %eax
c00235c3:	52                   	push   %edx
c00235c4:	e8 ac 65 00 00       	call   c0029b75 <list_push_back>
c00235c9:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < d->blocks_per_arena; i++) 
c00235cc:	ff 45 f0             	incl   -0x10(%ebp)
c00235cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00235d2:	8b 40 04             	mov    0x4(%eax),%eax
c00235d5:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00235d8:	72 c8                	jb     c00235a2 <malloc+0x13f>
        }
    }

  /* Get a block from free list and return it. */
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c00235da:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00235dd:	83 c0 08             	add    $0x8,%eax
c00235e0:	83 ec 0c             	sub    $0xc,%esp
c00235e3:	50                   	push   %eax
c00235e4:	e8 0b 66 00 00       	call   c0029bf4 <list_pop_front>
c00235e9:	83 c4 10             	add    $0x10,%esp
c00235ec:	83 c0 04             	add    $0x4,%eax
c00235ef:	83 e8 04             	sub    $0x4,%eax
c00235f2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  a = block_to_arena (b);
c00235f5:	83 ec 0c             	sub    $0xc,%esp
c00235f8:	ff 75 e4             	push   -0x1c(%ebp)
c00235fb:	e8 9e 02 00 00       	call   c002389e <block_to_arena>
c0023600:	83 c4 10             	add    $0x10,%esp
c0023603:	89 45 ec             	mov    %eax,-0x14(%ebp)
  a->free_cnt--;
c0023606:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023609:	8b 40 08             	mov    0x8(%eax),%eax
c002360c:	8d 50 ff             	lea    -0x1(%eax),%edx
c002360f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023612:	89 50 08             	mov    %edx,0x8(%eax)
  lock_release (&d->lock);
c0023615:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023618:	83 c0 18             	add    $0x18,%eax
c002361b:	83 ec 0c             	sub    $0xc,%esp
c002361e:	50                   	push   %eax
c002361f:	e8 ba f5 ff ff       	call   c0022bde <lock_release>
c0023624:	83 c4 10             	add    $0x10,%esp
  return b;
c0023627:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
c002362a:	c9                   	leave  
c002362b:	c3                   	ret    

c002362c <calloc>:

/* Allocates and return A times B bytes initialized to zeroes.
   Returns a null pointer if memory is not available. */
void *
calloc (size_t a, size_t b) 
{
c002362c:	55                   	push   %ebp
c002362d:	89 e5                	mov    %esp,%ebp
c002362f:	83 ec 18             	sub    $0x18,%esp
  void *p;
  size_t size;

  /* Calculate block size and make sure it fits in size_t. */
  size = a * b;
c0023632:	8b 45 08             	mov    0x8(%ebp),%eax
c0023635:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023639:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (size < a || size < b)
c002363c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002363f:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023642:	72 08                	jb     c002364c <calloc+0x20>
c0023644:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023647:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002364a:	73 07                	jae    c0023653 <calloc+0x27>
    return NULL;
c002364c:	b8 00 00 00 00       	mov    $0x0,%eax
c0023651:	eb 2d                	jmp    c0023680 <calloc+0x54>

  /* Allocate and zero memory. */
  p = malloc (size);
c0023653:	83 ec 0c             	sub    $0xc,%esp
c0023656:	ff 75 f4             	push   -0xc(%ebp)
c0023659:	e8 05 fe ff ff       	call   c0023463 <malloc>
c002365e:	83 c4 10             	add    $0x10,%esp
c0023661:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (p != NULL)
c0023664:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0023668:	74 13                	je     c002367d <calloc+0x51>
    memset (p, 0, size);
c002366a:	83 ec 04             	sub    $0x4,%esp
c002366d:	ff 75 f4             	push   -0xc(%ebp)
c0023670:	6a 00                	push   $0x0
c0023672:	ff 75 f0             	push   -0x10(%ebp)
c0023675:	e8 d0 52 00 00       	call   c002894a <memset>
c002367a:	83 c4 10             	add    $0x10,%esp

  return p;
c002367d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0023680:	c9                   	leave  
c0023681:	c3                   	ret    

c0023682 <block_size>:

/* Returns the number of bytes allocated for BLOCK. */
static size_t
block_size (void *block) 
{
c0023682:	55                   	push   %ebp
c0023683:	89 e5                	mov    %esp,%ebp
c0023685:	53                   	push   %ebx
c0023686:	83 ec 14             	sub    $0x14,%esp
  struct block *b = block;
c0023689:	8b 45 08             	mov    0x8(%ebp),%eax
c002368c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct arena *a = block_to_arena (b);
c002368f:	83 ec 0c             	sub    $0xc,%esp
c0023692:	ff 75 f4             	push   -0xc(%ebp)
c0023695:	e8 04 02 00 00       	call   c002389e <block_to_arena>
c002369a:	83 c4 10             	add    $0x10,%esp
c002369d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct desc *d = a->desc;
c00236a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00236a3:	8b 40 04             	mov    0x4(%eax),%eax
c00236a6:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c00236a9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00236ad:	74 07                	je     c00236b6 <block_size+0x34>
c00236af:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00236b2:	8b 00                	mov    (%eax),%eax
c00236b4:	eb 1f                	jmp    c00236d5 <block_size+0x53>
c00236b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00236b9:	8b 40 08             	mov    0x8(%eax),%eax
c00236bc:	c1 e0 0c             	shl    $0xc,%eax
c00236bf:	89 c3                	mov    %eax,%ebx
c00236c1:	83 ec 0c             	sub    $0xc,%esp
c00236c4:	ff 75 08             	push   0x8(%ebp)
c00236c7:	e8 ca fc ff ff       	call   c0023396 <pg_ofs>
c00236cc:	83 c4 10             	add    $0x10,%esp
c00236cf:	89 c2                	mov    %eax,%edx
c00236d1:	89 d8                	mov    %ebx,%eax
c00236d3:	29 d0                	sub    %edx,%eax
}
c00236d5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00236d8:	c9                   	leave  
c00236d9:	c3                   	ret    

c00236da <realloc>:
   null pointer.
   A call with null OLD_BLOCK is equivalent to malloc(NEW_SIZE).
   A call with zero NEW_SIZE is equivalent to free(OLD_BLOCK). */
void *
realloc (void *old_block, size_t new_size) 
{
c00236da:	55                   	push   %ebp
c00236db:	89 e5                	mov    %esp,%ebp
c00236dd:	83 ec 18             	sub    $0x18,%esp
  if (new_size == 0) 
c00236e0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00236e4:	75 15                	jne    c00236fb <realloc+0x21>
    {
      free (old_block);
c00236e6:	83 ec 0c             	sub    $0xc,%esp
c00236e9:	ff 75 08             	push   0x8(%ebp)
c00236ec:	e8 6e 00 00 00       	call   c002375f <free>
c00236f1:	83 c4 10             	add    $0x10,%esp
      return NULL;
c00236f4:	b8 00 00 00 00       	mov    $0x0,%eax
c00236f9:	eb 62                	jmp    c002375d <realloc+0x83>
    }
  else 
    {
      void *new_block = malloc (new_size);
c00236fb:	83 ec 0c             	sub    $0xc,%esp
c00236fe:	ff 75 0c             	push   0xc(%ebp)
c0023701:	e8 5d fd ff ff       	call   c0023463 <malloc>
c0023706:	83 c4 10             	add    $0x10,%esp
c0023709:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (old_block != NULL && new_block != NULL)
c002370c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023710:	74 48                	je     c002375a <realloc+0x80>
c0023712:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0023716:	74 42                	je     c002375a <realloc+0x80>
        {
          size_t old_size = block_size (old_block);
c0023718:	83 ec 0c             	sub    $0xc,%esp
c002371b:	ff 75 08             	push   0x8(%ebp)
c002371e:	e8 5f ff ff ff       	call   c0023682 <block_size>
c0023723:	83 c4 10             	add    $0x10,%esp
c0023726:	89 45 f0             	mov    %eax,-0x10(%ebp)
          size_t min_size = new_size < old_size ? new_size : old_size;
c0023729:	8b 55 0c             	mov    0xc(%ebp),%edx
c002372c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002372f:	39 d0                	cmp    %edx,%eax
c0023731:	76 02                	jbe    c0023735 <realloc+0x5b>
c0023733:	89 d0                	mov    %edx,%eax
c0023735:	89 45 ec             	mov    %eax,-0x14(%ebp)
          memcpy (new_block, old_block, min_size);
c0023738:	83 ec 04             	sub    $0x4,%esp
c002373b:	ff 75 ec             	push   -0x14(%ebp)
c002373e:	ff 75 08             	push   0x8(%ebp)
c0023741:	ff 75 f4             	push   -0xc(%ebp)
c0023744:	e8 27 4c 00 00       	call   c0028370 <memcpy>
c0023749:	83 c4 10             	add    $0x10,%esp
          free (old_block);
c002374c:	83 ec 0c             	sub    $0xc,%esp
c002374f:	ff 75 08             	push   0x8(%ebp)
c0023752:	e8 08 00 00 00       	call   c002375f <free>
c0023757:	83 c4 10             	add    $0x10,%esp
        }
      return new_block;
c002375a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
}
c002375d:	c9                   	leave  
c002375e:	c3                   	ret    

c002375f <free>:

/* Frees block P, which must have been previously allocated with
   malloc(), calloc(), or realloc(). */
void
free (void *p) 
{
c002375f:	55                   	push   %ebp
c0023760:	89 e5                	mov    %esp,%ebp
c0023762:	83 ec 28             	sub    $0x28,%esp
  if (p != NULL)
c0023765:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023769:	0f 84 2d 01 00 00    	je     c002389c <free+0x13d>
    {
      struct block *b = p;
c002376f:	8b 45 08             	mov    0x8(%ebp),%eax
c0023772:	89 45 f0             	mov    %eax,-0x10(%ebp)
      struct arena *a = block_to_arena (b);
c0023775:	83 ec 0c             	sub    $0xc,%esp
c0023778:	ff 75 f0             	push   -0x10(%ebp)
c002377b:	e8 1e 01 00 00       	call   c002389e <block_to_arena>
c0023780:	83 c4 10             	add    $0x10,%esp
c0023783:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct desc *d = a->desc;
c0023786:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023789:	8b 40 04             	mov    0x4(%eax),%eax
c002378c:	89 45 e8             	mov    %eax,-0x18(%ebp)
      
      if (d != NULL) 
c002378f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023793:	0f 84 ed 00 00 00    	je     c0023886 <free+0x127>
        {
          /* It's a normal block.  We handle it here. */

#ifndef NDEBUG
          /* Clear the block to help detect use-after-free bugs. */
          memset (b, 0xcc, d->block_size);
c0023799:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002379c:	8b 00                	mov    (%eax),%eax
c002379e:	83 ec 04             	sub    $0x4,%esp
c00237a1:	50                   	push   %eax
c00237a2:	68 cc 00 00 00       	push   $0xcc
c00237a7:	ff 75 f0             	push   -0x10(%ebp)
c00237aa:	e8 9b 51 00 00       	call   c002894a <memset>
c00237af:	83 c4 10             	add    $0x10,%esp
#endif
  
          lock_acquire (&d->lock);
c00237b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00237b5:	83 c0 18             	add    $0x18,%eax
c00237b8:	83 ec 0c             	sub    $0xc,%esp
c00237bb:	50                   	push   %eax
c00237bc:	e8 e1 f2 ff ff       	call   c0022aa2 <lock_acquire>
c00237c1:	83 c4 10             	add    $0x10,%esp

          /* Add block to free list. */
          list_push_front (&d->free_list, &b->free_elem);
c00237c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00237c7:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00237ca:	83 c2 08             	add    $0x8,%edx
c00237cd:	83 ec 08             	sub    $0x8,%esp
c00237d0:	50                   	push   %eax
c00237d1:	52                   	push   %edx
c00237d2:	e8 78 63 00 00       	call   c0029b4f <list_push_front>
c00237d7:	83 c4 10             	add    $0x10,%esp

          /* If the arena is now entirely unused, free it. */
          if (++a->free_cnt >= d->blocks_per_arena) 
c00237da:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00237dd:	8b 40 08             	mov    0x8(%eax),%eax
c00237e0:	8d 50 01             	lea    0x1(%eax),%edx
c00237e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00237e6:	89 50 08             	mov    %edx,0x8(%eax)
c00237e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00237ec:	8b 50 08             	mov    0x8(%eax),%edx
c00237ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00237f2:	8b 40 04             	mov    0x4(%eax),%eax
c00237f5:	39 c2                	cmp    %eax,%edx
c00237f7:	72 79                	jb     c0023872 <free+0x113>
            {
              size_t i;

              ASSERT (a->free_cnt == d->blocks_per_arena);
c00237f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00237fc:	8b 50 08             	mov    0x8(%eax),%edx
c00237ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023802:	8b 40 04             	mov    0x4(%eax),%eax
c0023805:	39 c2                	cmp    %eax,%edx
c0023807:	74 21                	je     c002382a <free+0xcb>
c0023809:	83 ec 0c             	sub    $0xc,%esp
c002380c:	68 d0 f2 02 c0       	push   $0xc002f2d0
c0023811:	68 a1 f2 02 c0       	push   $0xc002f2a1
c0023816:	68 b8 f3 02 c0       	push   $0xc002f3b8
c002381b:	68 f6 00 00 00       	push   $0xf6
c0023820:	68 b8 f2 02 c0       	push   $0xc002f2b8
c0023825:	e8 f4 5c 00 00       	call   c002951e <debug_panic>
              for (i = 0; i < d->blocks_per_arena; i++) 
c002382a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0023831:	eb 26                	jmp    c0023859 <free+0xfa>
                {
                  struct block *b = arena_to_block (a, i);
c0023833:	83 ec 08             	sub    $0x8,%esp
c0023836:	ff 75 f4             	push   -0xc(%ebp)
c0023839:	ff 75 ec             	push   -0x14(%ebp)
c002383c:	e8 5b 01 00 00       	call   c002399c <arena_to_block>
c0023841:	83 c4 10             	add    $0x10,%esp
c0023844:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                  list_remove (&b->free_elem);
c0023847:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002384a:	83 ec 0c             	sub    $0xc,%esp
c002384d:	50                   	push   %eax
c002384e:	e8 48 63 00 00       	call   c0029b9b <list_remove>
c0023853:	83 c4 10             	add    $0x10,%esp
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023856:	ff 45 f4             	incl   -0xc(%ebp)
c0023859:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002385c:	8b 40 04             	mov    0x4(%eax),%eax
c002385f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0023862:	72 cf                	jb     c0023833 <free+0xd4>
                }
              palloc_free_page (a);
c0023864:	83 ec 0c             	sub    $0xc,%esp
c0023867:	ff 75 ec             	push   -0x14(%ebp)
c002386a:	e8 08 fa ff ff       	call   c0023277 <palloc_free_page>
c002386f:	83 c4 10             	add    $0x10,%esp
            }

          lock_release (&d->lock);
c0023872:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023875:	83 c0 18             	add    $0x18,%eax
c0023878:	83 ec 0c             	sub    $0xc,%esp
c002387b:	50                   	push   %eax
c002387c:	e8 5d f3 ff ff       	call   c0022bde <lock_release>
c0023881:	83 c4 10             	add    $0x10,%esp
c0023884:	eb 16                	jmp    c002389c <free+0x13d>
        }
      else
        {
          /* It's a big block.  Free its pages. */
          palloc_free_multiple (a, a->free_cnt);
c0023886:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023889:	8b 40 08             	mov    0x8(%eax),%eax
c002388c:	83 ec 08             	sub    $0x8,%esp
c002388f:	50                   	push   %eax
c0023890:	ff 75 ec             	push   -0x14(%ebp)
c0023893:	e8 9f f8 ff ff       	call   c0023137 <palloc_free_multiple>
c0023898:	83 c4 10             	add    $0x10,%esp
          return;
c002389b:	90                   	nop
        }
    }
}
c002389c:	c9                   	leave  
c002389d:	c3                   	ret    

c002389e <block_to_arena>:

/* Returns the arena that block B is inside. */
static struct arena *
block_to_arena (struct block *b)
{
c002389e:	55                   	push   %ebp
c002389f:	89 e5                	mov    %esp,%ebp
c00238a1:	83 ec 18             	sub    $0x18,%esp
  struct arena *a = pg_round_down (b);
c00238a4:	ff 75 08             	push   0x8(%ebp)
c00238a7:	e8 f7 fa ff ff       	call   c00233a3 <pg_round_down>
c00238ac:	83 c4 04             	add    $0x4,%esp
c00238af:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Check that the arena is valid. */
  ASSERT (a != NULL);
c00238b2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00238b6:	75 21                	jne    c00238d9 <block_to_arena+0x3b>
c00238b8:	83 ec 0c             	sub    $0xc,%esp
c00238bb:	68 f3 f2 02 c0       	push   $0xc002f2f3
c00238c0:	68 a1 f2 02 c0       	push   $0xc002f2a1
c00238c5:	68 c0 f3 02 c0       	push   $0xc002f3c0
c00238ca:	68 11 01 00 00       	push   $0x111
c00238cf:	68 b8 f2 02 c0       	push   $0xc002f2b8
c00238d4:	e8 45 5c 00 00       	call   c002951e <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c00238d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00238dc:	8b 00                	mov    (%eax),%eax
c00238de:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c00238e3:	74 21                	je     c0023906 <block_to_arena+0x68>
c00238e5:	83 ec 0c             	sub    $0xc,%esp
c00238e8:	68 fd f2 02 c0       	push   $0xc002f2fd
c00238ed:	68 a1 f2 02 c0       	push   $0xc002f2a1
c00238f2:	68 c0 f3 02 c0       	push   $0xc002f3c0
c00238f7:	68 12 01 00 00       	push   $0x112
c00238fc:	68 b8 f2 02 c0       	push   $0xc002f2b8
c0023901:	e8 18 5c 00 00       	call   c002951e <debug_panic>

  /* Check that the block is properly aligned for the arena. */
  ASSERT (a->desc == NULL
c0023906:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023909:	8b 40 04             	mov    0x4(%eax),%eax
c002390c:	85 c0                	test   %eax,%eax
c002390e:	74 49                	je     c0023959 <block_to_arena+0xbb>
c0023910:	83 ec 0c             	sub    $0xc,%esp
c0023913:	ff 75 08             	push   0x8(%ebp)
c0023916:	e8 7b fa ff ff       	call   c0023396 <pg_ofs>
c002391b:	83 c4 10             	add    $0x10,%esp
c002391e:	8d 50 f4             	lea    -0xc(%eax),%edx
c0023921:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023924:	8b 40 04             	mov    0x4(%eax),%eax
c0023927:	8b 08                	mov    (%eax),%ecx
c0023929:	89 d0                	mov    %edx,%eax
c002392b:	ba 00 00 00 00       	mov    $0x0,%edx
c0023930:	f7 f1                	div    %ecx
c0023932:	89 d0                	mov    %edx,%eax
c0023934:	85 c0                	test   %eax,%eax
c0023936:	74 21                	je     c0023959 <block_to_arena+0xbb>
c0023938:	83 ec 0c             	sub    $0xc,%esp
c002393b:	68 18 f3 02 c0       	push   $0xc002f318
c0023940:	68 a1 f2 02 c0       	push   $0xc002f2a1
c0023945:	68 c0 f3 02 c0       	push   $0xc002f3c0
c002394a:	68 15 01 00 00       	push   $0x115
c002394f:	68 b8 f2 02 c0       	push   $0xc002f2b8
c0023954:	e8 c5 5b 00 00       	call   c002951e <debug_panic>
          || (pg_ofs (b) - sizeof *a) % a->desc->block_size == 0);
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c0023959:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002395c:	8b 40 04             	mov    0x4(%eax),%eax
c002395f:	85 c0                	test   %eax,%eax
c0023961:	75 34                	jne    c0023997 <block_to_arena+0xf9>
c0023963:	83 ec 0c             	sub    $0xc,%esp
c0023966:	ff 75 08             	push   0x8(%ebp)
c0023969:	e8 28 fa ff ff       	call   c0023396 <pg_ofs>
c002396e:	83 c4 10             	add    $0x10,%esp
c0023971:	83 f8 0c             	cmp    $0xc,%eax
c0023974:	74 21                	je     c0023997 <block_to_arena+0xf9>
c0023976:	83 ec 0c             	sub    $0xc,%esp
c0023979:	68 60 f3 02 c0       	push   $0xc002f360
c002397e:	68 a1 f2 02 c0       	push   $0xc002f2a1
c0023983:	68 c0 f3 02 c0       	push   $0xc002f3c0
c0023988:	68 17 01 00 00       	push   $0x117
c002398d:	68 b8 f2 02 c0       	push   $0xc002f2b8
c0023992:	e8 87 5b 00 00       	call   c002951e <debug_panic>

  return a;
c0023997:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002399a:	c9                   	leave  
c002399b:	c3                   	ret    

c002399c <arena_to_block>:

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c002399c:	55                   	push   %ebp
c002399d:	89 e5                	mov    %esp,%ebp
c002399f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c00239a2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00239a6:	75 21                	jne    c00239c9 <arena_to_block+0x2d>
c00239a8:	83 ec 0c             	sub    $0xc,%esp
c00239ab:	68 f3 f2 02 c0       	push   $0xc002f2f3
c00239b0:	68 a1 f2 02 c0       	push   $0xc002f2a1
c00239b5:	68 d0 f3 02 c0       	push   $0xc002f3d0
c00239ba:	68 20 01 00 00       	push   $0x120
c00239bf:	68 b8 f2 02 c0       	push   $0xc002f2b8
c00239c4:	e8 55 5b 00 00       	call   c002951e <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c00239c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00239cc:	8b 00                	mov    (%eax),%eax
c00239ce:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c00239d3:	74 21                	je     c00239f6 <arena_to_block+0x5a>
c00239d5:	83 ec 0c             	sub    $0xc,%esp
c00239d8:	68 fd f2 02 c0       	push   $0xc002f2fd
c00239dd:	68 a1 f2 02 c0       	push   $0xc002f2a1
c00239e2:	68 d0 f3 02 c0       	push   $0xc002f3d0
c00239e7:	68 21 01 00 00       	push   $0x121
c00239ec:	68 b8 f2 02 c0       	push   $0xc002f2b8
c00239f1:	e8 28 5b 00 00       	call   c002951e <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c00239f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00239f9:	8b 40 04             	mov    0x4(%eax),%eax
c00239fc:	8b 40 04             	mov    0x4(%eax),%eax
c00239ff:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0023a02:	72 21                	jb     c0023a25 <arena_to_block+0x89>
c0023a04:	83 ec 0c             	sub    $0xc,%esp
c0023a07:	68 8c f3 02 c0       	push   $0xc002f38c
c0023a0c:	68 a1 f2 02 c0       	push   $0xc002f2a1
c0023a11:	68 d0 f3 02 c0       	push   $0xc002f3d0
c0023a16:	68 22 01 00 00       	push   $0x122
c0023a1b:	68 b8 f2 02 c0       	push   $0xc002f2b8
c0023a20:	e8 f9 5a 00 00       	call   c002951e <debug_panic>
  return (struct block *) ((uint8_t *) a
                           + sizeof *a
                           + idx * a->desc->block_size);
c0023a25:	8b 45 08             	mov    0x8(%ebp),%eax
c0023a28:	8b 40 04             	mov    0x4(%eax),%eax
c0023a2b:	8b 00                	mov    (%eax),%eax
c0023a2d:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023a31:	8d 50 0c             	lea    0xc(%eax),%edx
  return (struct block *) ((uint8_t *) a
c0023a34:	8b 45 08             	mov    0x8(%ebp),%eax
c0023a37:	01 d0                	add    %edx,%eax
}
c0023a39:	c9                   	leave  
c0023a3a:	c3                   	ret    

c0023a3b <outb>:
{
c0023a3b:	55                   	push   %ebp
c0023a3c:	89 e5                	mov    %esp,%ebp
c0023a3e:	83 ec 08             	sub    $0x8,%esp
c0023a41:	8b 45 08             	mov    0x8(%ebp),%eax
c0023a44:	8b 55 0c             	mov    0xc(%ebp),%edx
c0023a47:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0023a4b:	88 d0                	mov    %dl,%al
c0023a4d:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0023a50:	8a 45 f8             	mov    -0x8(%ebp),%al
c0023a53:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0023a56:	ee                   	out    %al,(%dx)
}
c0023a57:	90                   	nop
c0023a58:	c9                   	leave  
c0023a59:	c3                   	ret    

c0023a5a <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c0023a5a:	55                   	push   %ebp
c0023a5b:	89 e5                	mov    %esp,%ebp
c0023a5d:	83 ec 18             	sub    $0x18,%esp
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c0023a60:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023a64:	74 24                	je     c0023a8a <pit_configure_channel+0x30>
c0023a66:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0023a6a:	74 1e                	je     c0023a8a <pit_configure_channel+0x30>
c0023a6c:	83 ec 0c             	sub    $0xc,%esp
c0023a6f:	68 e0 f3 02 c0       	push   $0xc002f3e0
c0023a74:	68 fd f3 02 c0       	push   $0xc002f3fd
c0023a79:	68 40 f4 02 c0       	push   $0xc002f440
c0023a7e:	6a 33                	push   $0x33
c0023a80:	68 14 f4 02 c0       	push   $0xc002f414
c0023a85:	e8 94 5a 00 00       	call   c002951e <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c0023a8a:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
c0023a8e:	74 24                	je     c0023ab4 <pit_configure_channel+0x5a>
c0023a90:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0023a94:	74 1e                	je     c0023ab4 <pit_configure_channel+0x5a>
c0023a96:	83 ec 0c             	sub    $0xc,%esp
c0023a99:	68 28 f4 02 c0       	push   $0xc002f428
c0023a9e:	68 fd f3 02 c0       	push   $0xc002f3fd
c0023aa3:	68 40 f4 02 c0       	push   $0xc002f440
c0023aa8:	6a 34                	push   $0x34
c0023aaa:	68 14 f4 02 c0       	push   $0xc002f414
c0023aaf:	e8 6a 5a 00 00       	call   c002951e <debug_panic>

  /* Convert FREQUENCY to a PIT counter value.  The PIT has a
     clock that runs at PIT_HZ cycles per second.  We must
     translate FREQUENCY into a number of these cycles. */
  if (frequency < 19)
c0023ab4:	83 7d 10 12          	cmpl   $0x12,0x10(%ebp)
c0023ab8:	7f 08                	jg     c0023ac2 <pit_configure_channel+0x68>
    {
      /* Frequency is too low: the quotient would overflow the
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
c0023aba:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
c0023ac0:	eb 2a                	jmp    c0023aec <pit_configure_channel+0x92>
    }
  else if (frequency > PIT_HZ)
c0023ac2:	81 7d 10 dc 34 12 00 	cmpl   $0x1234dc,0x10(%ebp)
c0023ac9:	7e 08                	jle    c0023ad3 <pit_configure_channel+0x79>
      /* Frequency is too high: the quotient would underflow to
         0, which the PIT would interpret as 65536.  A count of 1
         is illegal in mode 2, so we force it to 2, which yields
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
c0023acb:	66 c7 45 f6 02 00    	movw   $0x2,-0xa(%ebp)
c0023ad1:	eb 19                	jmp    c0023aec <pit_configure_channel+0x92>
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c0023ad3:	8b 45 10             	mov    0x10(%ebp),%eax
c0023ad6:	89 c2                	mov    %eax,%edx
c0023ad8:	c1 ea 1f             	shr    $0x1f,%edx
c0023adb:	01 d0                	add    %edx,%eax
c0023add:	d1 f8                	sar    %eax
c0023adf:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0023ae4:	99                   	cltd   
c0023ae5:	f7 7d 10             	idivl  0x10(%ebp)
c0023ae8:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c0023aec:	e8 ac d8 ff ff       	call   c002139d <intr_disable>
c0023af1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0023af4:	8b 45 08             	mov    0x8(%ebp),%eax
c0023af7:	c1 e0 06             	shl    $0x6,%eax
c0023afa:	83 c8 30             	or     $0x30,%eax
c0023afd:	88 c2                	mov    %al,%dl
c0023aff:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023b02:	01 c0                	add    %eax,%eax
c0023b04:	09 d0                	or     %edx,%eax
c0023b06:	0f b6 c0             	movzbl %al,%eax
c0023b09:	83 ec 08             	sub    $0x8,%esp
c0023b0c:	50                   	push   %eax
c0023b0d:	6a 43                	push   $0x43
c0023b0f:	e8 27 ff ff ff       	call   c0023a3b <outb>
c0023b14:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count);
c0023b17:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
c0023b1b:	0f b6 d0             	movzbl %al,%edx
c0023b1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b21:	83 c0 40             	add    $0x40,%eax
c0023b24:	0f b7 c0             	movzwl %ax,%eax
c0023b27:	83 ec 08             	sub    $0x8,%esp
c0023b2a:	52                   	push   %edx
c0023b2b:	50                   	push   %eax
c0023b2c:	e8 0a ff ff ff       	call   c0023a3b <outb>
c0023b31:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c0023b34:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
c0023b38:	66 c1 e8 08          	shr    $0x8,%ax
c0023b3c:	0f b6 d0             	movzbl %al,%edx
c0023b3f:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b42:	83 c0 40             	add    $0x40,%eax
c0023b45:	0f b7 c0             	movzwl %ax,%eax
c0023b48:	83 ec 08             	sub    $0x8,%esp
c0023b4b:	52                   	push   %edx
c0023b4c:	50                   	push   %eax
c0023b4d:	e8 e9 fe ff ff       	call   c0023a3b <outb>
c0023b52:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0023b55:	83 ec 0c             	sub    $0xc,%esp
c0023b58:	ff 75 f0             	push   -0x10(%ebp)
c0023b5b:	e8 e5 d7 ff ff       	call   c0021345 <intr_set_level>
c0023b60:	83 c4 10             	add    $0x10,%esp
}
c0023b63:	90                   	nop
c0023b64:	c9                   	leave  
c0023b65:	c3                   	ret    

c0023b66 <timer_init>:

/* Sets up the timer to interrupt TIMER_FREQ times per second,
   and registers the corresponding interrupt. */
void
timer_init (void) 
{
c0023b66:	55                   	push   %ebp
c0023b67:	89 e5                	mov    %esp,%ebp
c0023b69:	83 ec 08             	sub    $0x8,%esp
  pit_configure_channel (0, 2, TIMER_FREQ);
c0023b6c:	83 ec 04             	sub    $0x4,%esp
c0023b6f:	6a 64                	push   $0x64
c0023b71:	6a 02                	push   $0x2
c0023b73:	6a 00                	push   $0x0
c0023b75:	e8 e0 fe ff ff       	call   c0023a5a <pit_configure_channel>
c0023b7a:	83 c4 10             	add    $0x10,%esp
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c0023b7d:	83 ec 04             	sub    $0x4,%esp
c0023b80:	68 58 f4 02 c0       	push   $0xc002f458
c0023b85:	68 89 3e 02 c0       	push   $0xc0023e89
c0023b8a:	6a 20                	push   $0x20
c0023b8c:	e8 2b da ff ff       	call   c00215bc <intr_register_ext>
c0023b91:	83 c4 10             	add    $0x10,%esp
}
c0023b94:	90                   	nop
c0023b95:	c9                   	leave  
c0023b96:	c3                   	ret    

c0023b97 <timer_calibrate>:

/* Calibrates loops_per_tick, used to implement brief delays. */
void
timer_calibrate (void) 
{
c0023b97:	55                   	push   %ebp
c0023b98:	89 e5                	mov    %esp,%ebp
c0023b9a:	53                   	push   %ebx
c0023b9b:	83 ec 14             	sub    $0x14,%esp
  unsigned high_bit, test_bit;

  ASSERT (intr_get_level () == INTR_ON);
c0023b9e:	e8 8c d7 ff ff       	call   c002132f <intr_get_level>
c0023ba3:	83 f8 01             	cmp    $0x1,%eax
c0023ba6:	74 1e                	je     c0023bc6 <timer_calibrate+0x2f>
c0023ba8:	83 ec 0c             	sub    $0xc,%esp
c0023bab:	68 63 f4 02 c0       	push   $0xc002f463
c0023bb0:	68 80 f4 02 c0       	push   $0xc002f480
c0023bb5:	68 10 f5 02 c0       	push   $0xc002f510
c0023bba:	6a 30                	push   $0x30
c0023bbc:	68 97 f4 02 c0       	push   $0xc002f497
c0023bc1:	e8 58 59 00 00       	call   c002951e <debug_panic>
  printf ("Calibrating timer...  ");
c0023bc6:	83 ec 0c             	sub    $0xc,%esp
c0023bc9:	68 ad f4 02 c0       	push   $0xc002f4ad
c0023bce:	e8 a9 35 00 00       	call   c002717c <printf>
c0023bd3:	83 c4 10             	add    $0x10,%esp

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
c0023bd6:	c7 05 90 50 03 c0 00 	movl   $0x400,0xc0035090
c0023bdd:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c0023be0:	eb 33                	jmp    c0023c15 <timer_calibrate+0x7e>
    {
      loops_per_tick <<= 1;
c0023be2:	a1 90 50 03 c0       	mov    0xc0035090,%eax
c0023be7:	01 c0                	add    %eax,%eax
c0023be9:	a3 90 50 03 c0       	mov    %eax,0xc0035090
      ASSERT (loops_per_tick != 0);
c0023bee:	a1 90 50 03 c0       	mov    0xc0035090,%eax
c0023bf3:	85 c0                	test   %eax,%eax
c0023bf5:	75 1e                	jne    c0023c15 <timer_calibrate+0x7e>
c0023bf7:	83 ec 0c             	sub    $0xc,%esp
c0023bfa:	68 c4 f4 02 c0       	push   $0xc002f4c4
c0023bff:	68 80 f4 02 c0       	push   $0xc002f480
c0023c04:	68 10 f5 02 c0       	push   $0xc002f510
c0023c09:	6a 39                	push   $0x39
c0023c0b:	68 97 f4 02 c0       	push   $0xc002f497
c0023c10:	e8 09 59 00 00       	call   c002951e <debug_panic>
  while (!too_many_loops (loops_per_tick << 1)) 
c0023c15:	a1 90 50 03 c0       	mov    0xc0035090,%eax
c0023c1a:	01 c0                	add    %eax,%eax
c0023c1c:	83 ec 0c             	sub    $0xc,%esp
c0023c1f:	50                   	push   %eax
c0023c20:	e8 8e 02 00 00       	call   c0023eb3 <too_many_loops>
c0023c25:	83 c4 10             	add    $0x10,%esp
c0023c28:	83 f0 01             	xor    $0x1,%eax
c0023c2b:	84 c0                	test   %al,%al
c0023c2d:	75 b3                	jne    c0023be2 <timer_calibrate+0x4b>
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
c0023c2f:	a1 90 50 03 c0       	mov    0xc0035090,%eax
c0023c34:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0023c37:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023c3a:	d1 e8                	shr    %eax
c0023c3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023c3f:	eb 29                	jmp    c0023c6a <timer_calibrate+0xd3>
    if (!too_many_loops (high_bit | test_bit))
c0023c41:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023c44:	0b 45 f4             	or     -0xc(%ebp),%eax
c0023c47:	83 ec 0c             	sub    $0xc,%esp
c0023c4a:	50                   	push   %eax
c0023c4b:	e8 63 02 00 00       	call   c0023eb3 <too_many_loops>
c0023c50:	83 c4 10             	add    $0x10,%esp
c0023c53:	83 f0 01             	xor    $0x1,%eax
c0023c56:	84 c0                	test   %al,%al
c0023c58:	74 0d                	je     c0023c67 <timer_calibrate+0xd0>
      loops_per_tick |= test_bit;
c0023c5a:	a1 90 50 03 c0       	mov    0xc0035090,%eax
c0023c5f:	0b 45 f4             	or     -0xc(%ebp),%eax
c0023c62:	a3 90 50 03 c0       	mov    %eax,0xc0035090
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0023c67:	d1 6d f4             	shrl   -0xc(%ebp)
c0023c6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023c6d:	c1 e8 0a             	shr    $0xa,%eax
c0023c70:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0023c73:	75 cc                	jne    c0023c41 <timer_calibrate+0xaa>

  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c0023c75:	a1 90 50 03 c0       	mov    0xc0035090,%eax
c0023c7a:	ba 00 00 00 00       	mov    $0x0,%edx
c0023c7f:	6b da 64             	imul   $0x64,%edx,%ebx
c0023c82:	6b c8 00             	imul   $0x0,%eax,%ecx
c0023c85:	01 d9                	add    %ebx,%ecx
c0023c87:	bb 64 00 00 00       	mov    $0x64,%ebx
c0023c8c:	f7 e3                	mul    %ebx
c0023c8e:	01 d1                	add    %edx,%ecx
c0023c90:	89 ca                	mov    %ecx,%edx
c0023c92:	83 ec 04             	sub    $0x4,%esp
c0023c95:	52                   	push   %edx
c0023c96:	50                   	push   %eax
c0023c97:	68 d8 f4 02 c0       	push   $0xc002f4d8
c0023c9c:	e8 db 34 00 00       	call   c002717c <printf>
c0023ca1:	83 c4 10             	add    $0x10,%esp
}
c0023ca4:	90                   	nop
c0023ca5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023ca8:	c9                   	leave  
c0023ca9:	c3                   	ret    

c0023caa <timer_ticks>:

/* Returns the number of timer ticks since the OS booted. */
int64_t
timer_ticks (void) 
{
c0023caa:	55                   	push   %ebp
c0023cab:	89 e5                	mov    %esp,%ebp
c0023cad:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0023cb0:	e8 e8 d6 ff ff       	call   c002139d <intr_disable>
c0023cb5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t t = ticks;
c0023cb8:	a1 88 50 03 c0       	mov    0xc0035088,%eax
c0023cbd:	8b 15 8c 50 03 c0    	mov    0xc003508c,%edx
c0023cc3:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0023cc6:	89 55 ec             	mov    %edx,-0x14(%ebp)
  intr_set_level (old_level);
c0023cc9:	83 ec 0c             	sub    $0xc,%esp
c0023ccc:	ff 75 f4             	push   -0xc(%ebp)
c0023ccf:	e8 71 d6 ff ff       	call   c0021345 <intr_set_level>
c0023cd4:	83 c4 10             	add    $0x10,%esp
  return t;
c0023cd7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023cda:	8b 55 ec             	mov    -0x14(%ebp),%edx
}
c0023cdd:	c9                   	leave  
c0023cde:	c3                   	ret    

c0023cdf <timer_elapsed>:

/* Returns the number of timer ticks elapsed since THEN, which
   should be a value once returned by timer_ticks(). */
int64_t
timer_elapsed (int64_t then) 
{
c0023cdf:	55                   	push   %ebp
c0023ce0:	89 e5                	mov    %esp,%ebp
c0023ce2:	83 ec 18             	sub    $0x18,%esp
c0023ce5:	8b 45 08             	mov    0x8(%ebp),%eax
c0023ce8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023ceb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023cee:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return timer_ticks () - then;
c0023cf1:	e8 b4 ff ff ff       	call   c0023caa <timer_ticks>
c0023cf6:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0023cf9:	1b 55 f4             	sbb    -0xc(%ebp),%edx
}
c0023cfc:	c9                   	leave  
c0023cfd:	c3                   	ret    

c0023cfe <timer_sleep>:

/* Sleeps for approximately TICKS timer ticks.  Interrupts must
   be turned on. */
void
timer_sleep (int64_t ticks) 
{
c0023cfe:	55                   	push   %ebp
c0023cff:	89 e5                	mov    %esp,%ebp
c0023d01:	83 ec 28             	sub    $0x28,%esp
c0023d04:	8b 45 08             	mov    0x8(%ebp),%eax
c0023d07:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0023d0a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023d0d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  int64_t start = timer_ticks ();
c0023d10:	e8 95 ff ff ff       	call   c0023caa <timer_ticks>
c0023d15:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023d18:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c0023d1b:	e8 0f d6 ff ff       	call   c002132f <intr_get_level>
c0023d20:	83 f8 01             	cmp    $0x1,%eax
c0023d23:	74 23                	je     c0023d48 <timer_sleep+0x4a>
c0023d25:	83 ec 0c             	sub    $0xc,%esp
c0023d28:	68 63 f4 02 c0       	push   $0xc002f463
c0023d2d:	68 80 f4 02 c0       	push   $0xc002f480
c0023d32:	68 20 f5 02 c0       	push   $0xc002f520
c0023d37:	6a 5e                	push   $0x5e
c0023d39:	68 97 f4 02 c0       	push   $0xc002f497
c0023d3e:	e8 db 57 00 00       	call   c002951e <debug_panic>
  while (timer_elapsed (start) < ticks) 
    thread_yield ();
c0023d43:	e8 26 d0 ff ff       	call   c0020d6e <thread_yield>
  while (timer_elapsed (start) < ticks) 
c0023d48:	83 ec 08             	sub    $0x8,%esp
c0023d4b:	ff 75 f4             	push   -0xc(%ebp)
c0023d4e:	ff 75 f0             	push   -0x10(%ebp)
c0023d51:	e8 89 ff ff ff       	call   c0023cdf <timer_elapsed>
c0023d56:	83 c4 10             	add    $0x10,%esp
c0023d59:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0023d5c:	89 d0                	mov    %edx,%eax
c0023d5e:	1b 45 e4             	sbb    -0x1c(%ebp),%eax
c0023d61:	7c e0                	jl     c0023d43 <timer_sleep+0x45>
}
c0023d63:	90                   	nop
c0023d64:	90                   	nop
c0023d65:	c9                   	leave  
c0023d66:	c3                   	ret    

c0023d67 <timer_msleep>:

/* Sleeps for approximately MS milliseconds.  Interrupts must be
   turned on. */
void
timer_msleep (int64_t ms) 
{
c0023d67:	55                   	push   %ebp
c0023d68:	89 e5                	mov    %esp,%ebp
c0023d6a:	83 ec 18             	sub    $0x18,%esp
c0023d6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0023d70:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023d73:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023d76:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ms, 1000);
c0023d79:	83 ec 04             	sub    $0x4,%esp
c0023d7c:	68 e8 03 00 00       	push   $0x3e8
c0023d81:	ff 75 f4             	push   -0xc(%ebp)
c0023d84:	ff 75 f0             	push   -0x10(%ebp)
c0023d87:	e8 fa 01 00 00       	call   c0023f86 <real_time_sleep>
c0023d8c:	83 c4 10             	add    $0x10,%esp
}
c0023d8f:	90                   	nop
c0023d90:	c9                   	leave  
c0023d91:	c3                   	ret    

c0023d92 <timer_usleep>:

/* Sleeps for approximately US microseconds.  Interrupts must be
   turned on. */
void
timer_usleep (int64_t us) 
{
c0023d92:	55                   	push   %ebp
c0023d93:	89 e5                	mov    %esp,%ebp
c0023d95:	83 ec 18             	sub    $0x18,%esp
c0023d98:	8b 45 08             	mov    0x8(%ebp),%eax
c0023d9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023d9e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023da1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (us, 1000 * 1000);
c0023da4:	83 ec 04             	sub    $0x4,%esp
c0023da7:	68 40 42 0f 00       	push   $0xf4240
c0023dac:	ff 75 f4             	push   -0xc(%ebp)
c0023daf:	ff 75 f0             	push   -0x10(%ebp)
c0023db2:	e8 cf 01 00 00       	call   c0023f86 <real_time_sleep>
c0023db7:	83 c4 10             	add    $0x10,%esp
}
c0023dba:	90                   	nop
c0023dbb:	c9                   	leave  
c0023dbc:	c3                   	ret    

c0023dbd <timer_nsleep>:

/* Sleeps for approximately NS nanoseconds.  Interrupts must be
   turned on. */
void
timer_nsleep (int64_t ns) 
{
c0023dbd:	55                   	push   %ebp
c0023dbe:	89 e5                	mov    %esp,%ebp
c0023dc0:	83 ec 18             	sub    $0x18,%esp
c0023dc3:	8b 45 08             	mov    0x8(%ebp),%eax
c0023dc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023dc9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ns, 1000 * 1000 * 1000);
c0023dcf:	83 ec 04             	sub    $0x4,%esp
c0023dd2:	68 00 ca 9a 3b       	push   $0x3b9aca00
c0023dd7:	ff 75 f4             	push   -0xc(%ebp)
c0023dda:	ff 75 f0             	push   -0x10(%ebp)
c0023ddd:	e8 a4 01 00 00       	call   c0023f86 <real_time_sleep>
c0023de2:	83 c4 10             	add    $0x10,%esp
}
c0023de5:	90                   	nop
c0023de6:	c9                   	leave  
c0023de7:	c3                   	ret    

c0023de8 <timer_mdelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_msleep()
   instead if interrupts are enabled. */
void
timer_mdelay (int64_t ms) 
{
c0023de8:	55                   	push   %ebp
c0023de9:	89 e5                	mov    %esp,%ebp
c0023deb:	83 ec 18             	sub    $0x18,%esp
c0023dee:	8b 45 08             	mov    0x8(%ebp),%eax
c0023df1:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023df4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023df7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ms, 1000);
c0023dfa:	83 ec 04             	sub    $0x4,%esp
c0023dfd:	68 e8 03 00 00       	push   $0x3e8
c0023e02:	ff 75 f4             	push   -0xc(%ebp)
c0023e05:	ff 75 f0             	push   -0x10(%ebp)
c0023e08:	e8 2b 02 00 00       	call   c0024038 <real_time_delay>
c0023e0d:	83 c4 10             	add    $0x10,%esp
}
c0023e10:	90                   	nop
c0023e11:	c9                   	leave  
c0023e12:	c3                   	ret    

c0023e13 <timer_udelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_usleep()
   instead if interrupts are enabled. */
void
timer_udelay (int64_t us) 
{
c0023e13:	55                   	push   %ebp
c0023e14:	89 e5                	mov    %esp,%ebp
c0023e16:	83 ec 18             	sub    $0x18,%esp
c0023e19:	8b 45 08             	mov    0x8(%ebp),%eax
c0023e1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023e1f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023e22:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (us, 1000 * 1000);
c0023e25:	83 ec 04             	sub    $0x4,%esp
c0023e28:	68 40 42 0f 00       	push   $0xf4240
c0023e2d:	ff 75 f4             	push   -0xc(%ebp)
c0023e30:	ff 75 f0             	push   -0x10(%ebp)
c0023e33:	e8 00 02 00 00       	call   c0024038 <real_time_delay>
c0023e38:	83 c4 10             	add    $0x10,%esp
}
c0023e3b:	90                   	nop
c0023e3c:	c9                   	leave  
c0023e3d:	c3                   	ret    

c0023e3e <timer_ndelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_nsleep()
   instead if interrupts are enabled.*/
void
timer_ndelay (int64_t ns) 
{
c0023e3e:	55                   	push   %ebp
c0023e3f:	89 e5                	mov    %esp,%ebp
c0023e41:	83 ec 18             	sub    $0x18,%esp
c0023e44:	8b 45 08             	mov    0x8(%ebp),%eax
c0023e47:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023e4a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023e4d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ns, 1000 * 1000 * 1000);
c0023e50:	83 ec 04             	sub    $0x4,%esp
c0023e53:	68 00 ca 9a 3b       	push   $0x3b9aca00
c0023e58:	ff 75 f4             	push   -0xc(%ebp)
c0023e5b:	ff 75 f0             	push   -0x10(%ebp)
c0023e5e:	e8 d5 01 00 00       	call   c0024038 <real_time_delay>
c0023e63:	83 c4 10             	add    $0x10,%esp
}
c0023e66:	90                   	nop
c0023e67:	c9                   	leave  
c0023e68:	c3                   	ret    

c0023e69 <timer_print_stats>:

/* Prints timer statistics. */
void
timer_print_stats (void) 
{
c0023e69:	55                   	push   %ebp
c0023e6a:	89 e5                	mov    %esp,%ebp
c0023e6c:	83 ec 08             	sub    $0x8,%esp
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c0023e6f:	e8 36 fe ff ff       	call   c0023caa <timer_ticks>
c0023e74:	83 ec 04             	sub    $0x4,%esp
c0023e77:	52                   	push   %edx
c0023e78:	50                   	push   %eax
c0023e79:	68 e8 f4 02 c0       	push   $0xc002f4e8
c0023e7e:	e8 f9 32 00 00       	call   c002717c <printf>
c0023e83:	83 c4 10             	add    $0x10,%esp
}
c0023e86:	90                   	nop
c0023e87:	c9                   	leave  
c0023e88:	c3                   	ret    

c0023e89 <timer_interrupt>:

/* Timer interrupt handler. */
static void
timer_interrupt (struct intr_frame *args UNUSED)
{
c0023e89:	55                   	push   %ebp
c0023e8a:	89 e5                	mov    %esp,%ebp
c0023e8c:	83 ec 08             	sub    $0x8,%esp
  ticks++;
c0023e8f:	a1 88 50 03 c0       	mov    0xc0035088,%eax
c0023e94:	8b 15 8c 50 03 c0    	mov    0xc003508c,%edx
c0023e9a:	83 c0 01             	add    $0x1,%eax
c0023e9d:	83 d2 00             	adc    $0x0,%edx
c0023ea0:	a3 88 50 03 c0       	mov    %eax,0xc0035088
c0023ea5:	89 15 8c 50 03 c0    	mov    %edx,0xc003508c
  thread_tick ();
c0023eab:	e8 f7 ca ff ff       	call   c00209a7 <thread_tick>
}
c0023eb0:	90                   	nop
c0023eb1:	c9                   	leave  
c0023eb2:	c3                   	ret    

c0023eb3 <too_many_loops>:

/* Returns true if LOOPS iterations waits for more than one timer
   tick, otherwise false. */
static bool
too_many_loops (unsigned loops) 
{
c0023eb3:	55                   	push   %ebp
c0023eb4:	89 e5                	mov    %esp,%ebp
c0023eb6:	57                   	push   %edi
c0023eb7:	56                   	push   %esi
c0023eb8:	53                   	push   %ebx
c0023eb9:	83 ec 2c             	sub    $0x2c,%esp
  /* Wait for a timer tick. */
  int64_t start = ticks;
c0023ebc:	a1 88 50 03 c0       	mov    0xc0035088,%eax
c0023ec1:	8b 15 8c 50 03 c0    	mov    0xc003508c,%edx
c0023ec7:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0023eca:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  while (ticks == start)
c0023ecd:	eb 00                	jmp    c0023ecf <too_many_loops+0x1c>
c0023ecf:	a1 88 50 03 c0       	mov    0xc0035088,%eax
c0023ed4:	8b 15 8c 50 03 c0    	mov    0xc003508c,%edx
c0023eda:	89 c7                	mov    %eax,%edi
c0023edc:	33 7d e0             	xor    -0x20(%ebp),%edi
c0023edf:	89 f9                	mov    %edi,%ecx
c0023ee1:	89 d0                	mov    %edx,%eax
c0023ee3:	33 45 e4             	xor    -0x1c(%ebp),%eax
c0023ee6:	89 c3                	mov    %eax,%ebx
c0023ee8:	89 d8                	mov    %ebx,%eax
c0023eea:	09 c8                	or     %ecx,%eax
c0023eec:	85 c0                	test   %eax,%eax
c0023eee:	74 df                	je     c0023ecf <too_many_loops+0x1c>
    barrier ();

  /* Run LOOPS loops. */
  start = ticks;
c0023ef0:	a1 88 50 03 c0       	mov    0xc0035088,%eax
c0023ef5:	8b 15 8c 50 03 c0    	mov    0xc003508c,%edx
c0023efb:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0023efe:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  busy_wait (loops);
c0023f01:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f04:	ba 00 00 00 00       	mov    $0x0,%edx
c0023f09:	83 ec 08             	sub    $0x8,%esp
c0023f0c:	52                   	push   %edx
c0023f0d:	50                   	push   %eax
c0023f0e:	e8 31 00 00 00       	call   c0023f44 <busy_wait>
c0023f13:	83 c4 10             	add    $0x10,%esp

  /* If the tick count changed, we iterated too long. */
  barrier ();
  return start != ticks;
c0023f16:	a1 88 50 03 c0       	mov    0xc0035088,%eax
c0023f1b:	8b 15 8c 50 03 c0    	mov    0xc003508c,%edx
c0023f21:	89 c7                	mov    %eax,%edi
c0023f23:	33 7d e0             	xor    -0x20(%ebp),%edi
c0023f26:	89 7d d0             	mov    %edi,-0x30(%ebp)
c0023f29:	89 d0                	mov    %edx,%eax
c0023f2b:	33 45 e4             	xor    -0x1c(%ebp),%eax
c0023f2e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c0023f31:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0023f34:	0b 45 d4             	or     -0x2c(%ebp),%eax
c0023f37:	85 c0                	test   %eax,%eax
c0023f39:	0f 95 c0             	setne  %al
}
c0023f3c:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0023f3f:	5b                   	pop    %ebx
c0023f40:	5e                   	pop    %esi
c0023f41:	5f                   	pop    %edi
c0023f42:	5d                   	pop    %ebp
c0023f43:	c3                   	ret    

c0023f44 <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c0023f44:	55                   	push   %ebp
c0023f45:	89 e5                	mov    %esp,%ebp
c0023f47:	53                   	push   %ebx
c0023f48:	83 ec 0c             	sub    $0xc,%esp
c0023f4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023f51:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023f54:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (loops-- > 0)
c0023f57:	eb 00                	jmp    c0023f59 <busy_wait+0x15>
c0023f59:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023f5c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023f5f:	89 c1                	mov    %eax,%ecx
c0023f61:	89 d3                	mov    %edx,%ebx
c0023f63:	83 c1 ff             	add    $0xffffffff,%ecx
c0023f66:	83 d3 ff             	adc    $0xffffffff,%ebx
c0023f69:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0023f6c:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c0023f6f:	bb 00 00 00 00       	mov    $0x0,%ebx
c0023f74:	b9 00 00 00 00       	mov    $0x0,%ecx
c0023f79:	39 c3                	cmp    %eax,%ebx
c0023f7b:	19 d1                	sbb    %edx,%ecx
c0023f7d:	7c da                	jl     c0023f59 <busy_wait+0x15>
    barrier ();
}
c0023f7f:	90                   	nop
c0023f80:	90                   	nop
c0023f81:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023f84:	c9                   	leave  
c0023f85:	c3                   	ret    

c0023f86 <real_time_sleep>:

/* Sleep for approximately NUM/DENOM seconds. */
static void
real_time_sleep (int64_t num, int32_t denom) 
{
c0023f86:	55                   	push   %ebp
c0023f87:	89 e5                	mov    %esp,%ebp
c0023f89:	53                   	push   %ebx
c0023f8a:	83 ec 24             	sub    $0x24,%esp
c0023f8d:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f90:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0023f93:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023f96:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          
        (NUM / DENOM) s          
     ---------------------- = NUM * TIMER_FREQ / DENOM ticks. 
     1 s / TIMER_FREQ ticks
  */
  int64_t ticks = num * TIMER_FREQ / denom;
c0023f99:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023f9c:	6b d0 64             	imul   $0x64,%eax,%edx
c0023f9f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0023fa2:	6b c0 00             	imul   $0x0,%eax,%eax
c0023fa5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c0023fa8:	b8 64 00 00 00       	mov    $0x64,%eax
c0023fad:	f7 65 e0             	mull   -0x20(%ebp)
c0023fb0:	01 d1                	add    %edx,%ecx
c0023fb2:	89 ca                	mov    %ecx,%edx
c0023fb4:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0023fb7:	89 cb                	mov    %ecx,%ebx
c0023fb9:	c1 fb 1f             	sar    $0x1f,%ebx
c0023fbc:	53                   	push   %ebx
c0023fbd:	51                   	push   %ecx
c0023fbe:	52                   	push   %edx
c0023fbf:	50                   	push   %eax
c0023fc0:	e8 63 4f 00 00       	call   c0028f28 <__divdi3>
c0023fc5:	83 c4 10             	add    $0x10,%esp
c0023fc8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023fcb:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c0023fce:	e8 5c d3 ff ff       	call   c002132f <intr_get_level>
c0023fd3:	83 f8 01             	cmp    $0x1,%eax
c0023fd6:	74 21                	je     c0023ff9 <real_time_sleep+0x73>
c0023fd8:	83 ec 0c             	sub    $0xc,%esp
c0023fdb:	68 63 f4 02 c0       	push   $0xc002f463
c0023fe0:	68 80 f4 02 c0       	push   $0xc002f480
c0023fe5:	68 2c f5 02 c0       	push   $0xc002f52c
c0023fea:	68 de 00 00 00       	push   $0xde
c0023fef:	68 97 f4 02 c0       	push   $0xc002f497
c0023ff4:	e8 25 55 00 00       	call   c002951e <debug_panic>
  if (ticks > 0)
c0023ff9:	ba 00 00 00 00       	mov    $0x0,%edx
c0023ffe:	b8 00 00 00 00       	mov    $0x0,%eax
c0024003:	3b 55 f0             	cmp    -0x10(%ebp),%edx
c0024006:	1b 45 f4             	sbb    -0xc(%ebp),%eax
c0024009:	7d 13                	jge    c002401e <real_time_sleep+0x98>
    {
      /* We're waiting for at least one full timer tick.  Use
         timer_sleep() because it will yield the CPU to other
         processes. */                
      timer_sleep (ticks); 
c002400b:	83 ec 08             	sub    $0x8,%esp
c002400e:	ff 75 f4             	push   -0xc(%ebp)
c0024011:	ff 75 f0             	push   -0x10(%ebp)
c0024014:	e8 e5 fc ff ff       	call   c0023cfe <timer_sleep>
c0024019:	83 c4 10             	add    $0x10,%esp
    {
      /* Otherwise, use a busy-wait loop for more accurate
         sub-tick timing. */
      real_time_delay (num, denom); 
    }
}
c002401c:	eb 14                	jmp    c0024032 <real_time_sleep+0xac>
      real_time_delay (num, denom); 
c002401e:	83 ec 04             	sub    $0x4,%esp
c0024021:	ff 75 10             	push   0x10(%ebp)
c0024024:	ff 75 e4             	push   -0x1c(%ebp)
c0024027:	ff 75 e0             	push   -0x20(%ebp)
c002402a:	e8 09 00 00 00       	call   c0024038 <real_time_delay>
c002402f:	83 c4 10             	add    $0x10,%esp
}
c0024032:	90                   	nop
c0024033:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024036:	c9                   	leave  
c0024037:	c3                   	ret    

c0024038 <real_time_delay>:

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c0024038:	55                   	push   %ebp
c0024039:	89 e5                	mov    %esp,%ebp
c002403b:	56                   	push   %esi
c002403c:	53                   	push   %ebx
c002403d:	83 ec 10             	sub    $0x10,%esp
c0024040:	8b 45 08             	mov    0x8(%ebp),%eax
c0024043:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024046:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024049:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c002404c:	8b 45 10             	mov    0x10(%ebp),%eax
c002404f:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0024054:	99                   	cltd   
c0024055:	f7 f9                	idiv   %ecx
c0024057:	89 d0                	mov    %edx,%eax
c0024059:	85 c0                	test   %eax,%eax
c002405b:	74 21                	je     c002407e <real_time_delay+0x46>
c002405d:	83 ec 0c             	sub    $0xc,%esp
c0024060:	68 fb f4 02 c0       	push   $0xc002f4fb
c0024065:	68 80 f4 02 c0       	push   $0xc002f480
c002406a:	68 3c f5 02 c0       	push   $0xc002f53c
c002406f:	68 f4 00 00 00       	push   $0xf4
c0024074:	68 97 f4 02 c0       	push   $0xc002f497
c0024079:	e8 a0 54 00 00       	call   c002951e <debug_panic>
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c002407e:	a1 90 50 03 c0       	mov    0xc0035090,%eax
c0024083:	ba 00 00 00 00       	mov    $0x0,%edx
c0024088:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c002408b:	89 cb                	mov    %ecx,%ebx
c002408d:	0f af da             	imul   %edx,%ebx
c0024090:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0024093:	0f af c8             	imul   %eax,%ecx
c0024096:	01 d9                	add    %ebx,%ecx
c0024098:	f7 65 f0             	mull   -0x10(%ebp)
c002409b:	01 d1                	add    %edx,%ecx
c002409d:	89 ca                	mov    %ecx,%edx
c002409f:	6a 00                	push   $0x0
c00240a1:	68 e8 03 00 00       	push   $0x3e8
c00240a6:	52                   	push   %edx
c00240a7:	50                   	push   %eax
c00240a8:	e8 7b 4e 00 00       	call   c0028f28 <__divdi3>
c00240ad:	83 c4 10             	add    $0x10,%esp
c00240b0:	6b da 64             	imul   $0x64,%edx,%ebx
c00240b3:	6b c8 00             	imul   $0x0,%eax,%ecx
c00240b6:	8d 34 0b             	lea    (%ebx,%ecx,1),%esi
c00240b9:	b9 64 00 00 00       	mov    $0x64,%ecx
c00240be:	f7 e1                	mul    %ecx
c00240c0:	89 c1                	mov    %eax,%ecx
c00240c2:	89 d3                	mov    %edx,%ebx
c00240c4:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
c00240c7:	89 c3                	mov    %eax,%ebx
c00240c9:	8b 75 10             	mov    0x10(%ebp),%esi
c00240cc:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
c00240d1:	f7 ee                	imul   %esi
c00240d3:	89 d0                	mov    %edx,%eax
c00240d5:	c1 f8 06             	sar    $0x6,%eax
c00240d8:	c1 fe 1f             	sar    $0x1f,%esi
c00240db:	89 f2                	mov    %esi,%edx
c00240dd:	29 d0                	sub    %edx,%eax
c00240df:	99                   	cltd   
c00240e0:	52                   	push   %edx
c00240e1:	50                   	push   %eax
c00240e2:	53                   	push   %ebx
c00240e3:	51                   	push   %ecx
c00240e4:	e8 3f 4e 00 00       	call   c0028f28 <__divdi3>
c00240e9:	83 c4 10             	add    $0x10,%esp
c00240ec:	83 ec 08             	sub    $0x8,%esp
c00240ef:	52                   	push   %edx
c00240f0:	50                   	push   %eax
c00240f1:	e8 4e fe ff ff       	call   c0023f44 <busy_wait>
c00240f6:	83 c4 10             	add    $0x10,%esp
}
c00240f9:	90                   	nop
c00240fa:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00240fd:	5b                   	pop    %ebx
c00240fe:	5e                   	pop    %esi
c00240ff:	5d                   	pop    %ebp
c0024100:	c3                   	ret    

c0024101 <isupper>:
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c0024101:	55                   	push   %ebp
c0024102:	89 e5                	mov    %esp,%ebp
c0024104:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c0024108:	7e 0d                	jle    c0024117 <isupper+0x16>
c002410a:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c002410e:	7f 07                	jg     c0024117 <isupper+0x16>
c0024110:	b8 01 00 00 00       	mov    $0x1,%eax
c0024115:	eb 05                	jmp    c002411c <isupper+0x1b>
c0024117:	b8 00 00 00 00       	mov    $0x0,%eax
c002411c:	5d                   	pop    %ebp
c002411d:	c3                   	ret    

c002411e <tolower>:
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c002411e:	55                   	push   %ebp
c002411f:	89 e5                	mov    %esp,%ebp
c0024121:	ff 75 08             	push   0x8(%ebp)
c0024124:	e8 d8 ff ff ff       	call   c0024101 <isupper>
c0024129:	83 c4 04             	add    $0x4,%esp
c002412c:	85 c0                	test   %eax,%eax
c002412e:	74 08                	je     c0024138 <tolower+0x1a>
c0024130:	8b 45 08             	mov    0x8(%ebp),%eax
c0024133:	83 c0 20             	add    $0x20,%eax
c0024136:	eb 03                	jmp    c002413b <tolower+0x1d>
c0024138:	8b 45 08             	mov    0x8(%ebp),%eax
c002413b:	c9                   	leave  
c002413c:	c3                   	ret    

c002413d <inb>:
{
c002413d:	55                   	push   %ebp
c002413e:	89 e5                	mov    %esp,%ebp
c0024140:	83 ec 14             	sub    $0x14,%esp
c0024143:	8b 45 08             	mov    0x8(%ebp),%eax
c0024146:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002414a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002414d:	89 c2                	mov    %eax,%edx
c002414f:	ec                   	in     (%dx),%al
c0024150:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024153:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0024156:	c9                   	leave  
c0024157:	c3                   	ret    

c0024158 <kbd_init>:
static intr_handler_func keyboard_interrupt;

/* Initializes the keyboard. */
void
kbd_init (void) 
{
c0024158:	55                   	push   %ebp
c0024159:	89 e5                	mov    %esp,%ebp
c002415b:	83 ec 08             	sub    $0x8,%esp
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c002415e:	83 ec 04             	sub    $0x4,%esp
c0024161:	68 60 f5 02 c0       	push   $0xc002f560
c0024166:	68 9e 41 02 c0       	push   $0xc002419e
c002416b:	6a 21                	push   $0x21
c002416d:	e8 4a d4 ff ff       	call   c00215bc <intr_register_ext>
c0024172:	83 c4 10             	add    $0x10,%esp
}
c0024175:	90                   	nop
c0024176:	c9                   	leave  
c0024177:	c3                   	ret    

c0024178 <kbd_print_stats>:

/* Prints keyboard statistics. */
void
kbd_print_stats (void) 
{
c0024178:	55                   	push   %ebp
c0024179:	89 e5                	mov    %esp,%ebp
c002417b:	83 ec 08             	sub    $0x8,%esp
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c002417e:	a1 a0 50 03 c0       	mov    0xc00350a0,%eax
c0024183:	8b 15 a4 50 03 c0    	mov    0xc00350a4,%edx
c0024189:	83 ec 04             	sub    $0x4,%esp
c002418c:	52                   	push   %edx
c002418d:	50                   	push   %eax
c002418e:	68 6e f5 02 c0       	push   $0xc002f56e
c0024193:	e8 e4 2f 00 00       	call   c002717c <printf>
c0024198:	83 c4 10             	add    $0x10,%esp
}
c002419b:	90                   	nop
c002419c:	c9                   	leave  
c002419d:	c3                   	ret    

c002419e <keyboard_interrupt>:

static bool map_key (const struct keymap[], unsigned scancode, uint8_t *);

static void
keyboard_interrupt (struct intr_frame *args UNUSED) 
{
c002419e:	55                   	push   %ebp
c002419f:	89 e5                	mov    %esp,%ebp
c00241a1:	53                   	push   %ebx
c00241a2:	83 ec 14             	sub    $0x14,%esp
  /* Status of shift keys. */
  bool shift = left_shift || right_shift;
c00241a5:	a0 98 50 03 c0       	mov    0xc0035098,%al
c00241aa:	84 c0                	test   %al,%al
c00241ac:	75 09                	jne    c00241b7 <keyboard_interrupt+0x19>
c00241ae:	a0 99 50 03 c0       	mov    0xc0035099,%al
c00241b3:	84 c0                	test   %al,%al
c00241b5:	74 07                	je     c00241be <keyboard_interrupt+0x20>
c00241b7:	b8 01 00 00 00       	mov    $0x1,%eax
c00241bc:	eb 05                	jmp    c00241c3 <keyboard_interrupt+0x25>
c00241be:	b8 00 00 00 00       	mov    $0x0,%eax
c00241c3:	88 45 ef             	mov    %al,-0x11(%ebp)
c00241c6:	80 65 ef 01          	andb   $0x1,-0x11(%ebp)
  bool alt = left_alt || right_alt;
c00241ca:	a0 9a 50 03 c0       	mov    0xc003509a,%al
c00241cf:	84 c0                	test   %al,%al
c00241d1:	75 09                	jne    c00241dc <keyboard_interrupt+0x3e>
c00241d3:	a0 9b 50 03 c0       	mov    0xc003509b,%al
c00241d8:	84 c0                	test   %al,%al
c00241da:	74 07                	je     c00241e3 <keyboard_interrupt+0x45>
c00241dc:	b8 01 00 00 00       	mov    $0x1,%eax
c00241e1:	eb 05                	jmp    c00241e8 <keyboard_interrupt+0x4a>
c00241e3:	b8 00 00 00 00       	mov    $0x0,%eax
c00241e8:	88 45 ee             	mov    %al,-0x12(%ebp)
c00241eb:	80 65 ee 01          	andb   $0x1,-0x12(%ebp)
  bool ctrl = left_ctrl || right_ctrl;
c00241ef:	a0 9c 50 03 c0       	mov    0xc003509c,%al
c00241f4:	84 c0                	test   %al,%al
c00241f6:	75 09                	jne    c0024201 <keyboard_interrupt+0x63>
c00241f8:	a0 9d 50 03 c0       	mov    0xc003509d,%al
c00241fd:	84 c0                	test   %al,%al
c00241ff:	74 07                	je     c0024208 <keyboard_interrupt+0x6a>
c0024201:	b8 01 00 00 00       	mov    $0x1,%eax
c0024206:	eb 05                	jmp    c002420d <keyboard_interrupt+0x6f>
c0024208:	b8 00 00 00 00       	mov    $0x0,%eax
c002420d:	88 45 ed             	mov    %al,-0x13(%ebp)
c0024210:	80 65 ed 01          	andb   $0x1,-0x13(%ebp)

  /* Character that corresponds to `code'. */
  uint8_t c;

  /* Read scancode, including second byte if prefix code. */
  code = inb (DATA_REG);
c0024214:	6a 60                	push   $0x60
c0024216:	e8 22 ff ff ff       	call   c002413d <inb>
c002421b:	83 c4 04             	add    $0x4,%esp
c002421e:	0f b6 c0             	movzbl %al,%eax
c0024221:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (code == 0xe0)
c0024224:	81 7d f4 e0 00 00 00 	cmpl   $0xe0,-0xc(%ebp)
c002422b:	75 1a                	jne    c0024247 <keyboard_interrupt+0xa9>
    code = (code << 8) | inb (DATA_REG);
c002422d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024230:	c1 e0 08             	shl    $0x8,%eax
c0024233:	89 c3                	mov    %eax,%ebx
c0024235:	6a 60                	push   $0x60
c0024237:	e8 01 ff ff ff       	call   c002413d <inb>
c002423c:	83 c4 04             	add    $0x4,%esp
c002423f:	0f b6 c0             	movzbl %al,%eax
c0024242:	09 d8                	or     %ebx,%eax
c0024244:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Bit 0x80 distinguishes key press from key release
     (even if there's a prefix). */
  release = (code & 0x80) != 0;
c0024247:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002424a:	25 80 00 00 00       	and    $0x80,%eax
c002424f:	85 c0                	test   %eax,%eax
c0024251:	0f 95 c0             	setne  %al
c0024254:	88 45 ec             	mov    %al,-0x14(%ebp)
  code &= ~0x80u;
c0024257:	81 65 f4 7f ff ff ff 	andl   $0xffffff7f,-0xc(%ebp)

  /* Interpret key. */
  if (code == 0x3a) 
c002425e:	83 7d f4 3a          	cmpl   $0x3a,-0xc(%ebp)
c0024262:	75 2e                	jne    c0024292 <keyboard_interrupt+0xf4>
    {
      /* Caps Lock. */
      if (!release)
c0024264:	8a 45 ec             	mov    -0x14(%ebp),%al
c0024267:	83 f0 01             	xor    $0x1,%eax
c002426a:	84 c0                	test   %al,%al
c002426c:	0f 84 79 01 00 00    	je     c00243eb <keyboard_interrupt+0x24d>
        caps_lock = !caps_lock;
c0024272:	a0 9e 50 03 c0       	mov    0xc003509e,%al
c0024277:	0f b6 c0             	movzbl %al,%eax
c002427a:	85 c0                	test   %eax,%eax
c002427c:	0f 95 c0             	setne  %al
c002427f:	83 f0 01             	xor    $0x1,%eax
c0024282:	0f b6 c0             	movzbl %al,%eax
c0024285:	83 e0 01             	and    $0x1,%eax
c0024288:	a2 9e 50 03 c0       	mov    %al,0xc003509e
          {
            *key->state_var = !release;
            break;
          }
    }
}
c002428d:	e9 59 01 00 00       	jmp    c00243eb <keyboard_interrupt+0x24d>
  else if (map_key (invariant_keymap, code, &c)
c0024292:	83 ec 04             	sub    $0x4,%esp
c0024295:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0024298:	50                   	push   %eax
c0024299:	ff 75 f4             	push   -0xc(%ebp)
c002429c:	68 c0 f5 02 c0       	push   $0xc002f5c0
c00242a1:	e8 4b 01 00 00       	call   c00243f1 <map_key>
c00242a6:	83 c4 10             	add    $0x10,%esp
c00242a9:	84 c0                	test   %al,%al
c00242ab:	75 4e                	jne    c00242fb <keyboard_interrupt+0x15d>
           || (!shift && map_key (unshifted_keymap, code, &c))
c00242ad:	8a 45 ef             	mov    -0x11(%ebp),%al
c00242b0:	83 f0 01             	xor    $0x1,%eax
c00242b3:	84 c0                	test   %al,%al
c00242b5:	74 1b                	je     c00242d2 <keyboard_interrupt+0x134>
c00242b7:	83 ec 04             	sub    $0x4,%esp
c00242ba:	8d 45 eb             	lea    -0x15(%ebp),%eax
c00242bd:	50                   	push   %eax
c00242be:	ff 75 f4             	push   -0xc(%ebp)
c00242c1:	68 40 f6 02 c0       	push   $0xc002f640
c00242c6:	e8 26 01 00 00       	call   c00243f1 <map_key>
c00242cb:	83 c4 10             	add    $0x10,%esp
c00242ce:	84 c0                	test   %al,%al
c00242d0:	75 29                	jne    c00242fb <keyboard_interrupt+0x15d>
           || (shift && map_key (shifted_keymap, code, &c)))
c00242d2:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c00242d6:	0f 84 ce 00 00 00    	je     c00243aa <keyboard_interrupt+0x20c>
c00242dc:	83 ec 04             	sub    $0x4,%esp
c00242df:	8d 45 eb             	lea    -0x15(%ebp),%eax
c00242e2:	50                   	push   %eax
c00242e3:	ff 75 f4             	push   -0xc(%ebp)
c00242e6:	68 a0 f6 02 c0       	push   $0xc002f6a0
c00242eb:	e8 01 01 00 00       	call   c00243f1 <map_key>
c00242f0:	83 c4 10             	add    $0x10,%esp
c00242f3:	84 c0                	test   %al,%al
c00242f5:	0f 84 af 00 00 00    	je     c00243aa <keyboard_interrupt+0x20c>
      if (!release) 
c00242fb:	8a 45 ec             	mov    -0x14(%ebp),%al
c00242fe:	83 f0 01             	xor    $0x1,%eax
c0024301:	84 c0                	test   %al,%al
c0024303:	0f 84 e1 00 00 00    	je     c00243ea <keyboard_interrupt+0x24c>
          if (c == 0177 && ctrl && alt)
c0024309:	8a 45 eb             	mov    -0x15(%ebp),%al
c002430c:	3c 7f                	cmp    $0x7f,%al
c002430e:	75 11                	jne    c0024321 <keyboard_interrupt+0x183>
c0024310:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0024314:	74 0b                	je     c0024321 <keyboard_interrupt+0x183>
c0024316:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c002431a:	74 05                	je     c0024321 <keyboard_interrupt+0x183>
            shutdown_reboot ();
c002431c:	e8 eb 28 00 00       	call   c0026c0c <shutdown_reboot>
          if (ctrl && c >= 0x40 && c < 0x60) 
c0024321:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0024325:	74 19                	je     c0024340 <keyboard_interrupt+0x1a2>
c0024327:	8a 45 eb             	mov    -0x15(%ebp),%al
c002432a:	3c 3f                	cmp    $0x3f,%al
c002432c:	76 12                	jbe    c0024340 <keyboard_interrupt+0x1a2>
c002432e:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024331:	3c 5f                	cmp    $0x5f,%al
c0024333:	77 0b                	ja     c0024340 <keyboard_interrupt+0x1a2>
              c -= 0x40; 
c0024335:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024338:	83 e8 40             	sub    $0x40,%eax
c002433b:	88 45 eb             	mov    %al,-0x15(%ebp)
c002433e:	eb 1f                	jmp    c002435f <keyboard_interrupt+0x1c1>
          else if (shift == caps_lock)
c0024340:	a0 9e 50 03 c0       	mov    0xc003509e,%al
c0024345:	38 45 ef             	cmp    %al,-0x11(%ebp)
c0024348:	75 15                	jne    c002435f <keyboard_interrupt+0x1c1>
            c = tolower (c);
c002434a:	8a 45 eb             	mov    -0x15(%ebp),%al
c002434d:	0f b6 c0             	movzbl %al,%eax
c0024350:	83 ec 0c             	sub    $0xc,%esp
c0024353:	50                   	push   %eax
c0024354:	e8 c5 fd ff ff       	call   c002411e <tolower>
c0024359:	83 c4 10             	add    $0x10,%esp
c002435c:	88 45 eb             	mov    %al,-0x15(%ebp)
          if (alt)
c002435f:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c0024363:	74 09                	je     c002436e <keyboard_interrupt+0x1d0>
            c += 0x80;
c0024365:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024368:	83 c0 80             	add    $0xffffff80,%eax
c002436b:	88 45 eb             	mov    %al,-0x15(%ebp)
          if (!input_full ())
c002436e:	e8 44 21 00 00       	call   c00264b7 <input_full>
c0024373:	83 f0 01             	xor    $0x1,%eax
c0024376:	84 c0                	test   %al,%al
c0024378:	74 70                	je     c00243ea <keyboard_interrupt+0x24c>
              key_cnt++;
c002437a:	a1 a0 50 03 c0       	mov    0xc00350a0,%eax
c002437f:	8b 15 a4 50 03 c0    	mov    0xc00350a4,%edx
c0024385:	83 c0 01             	add    $0x1,%eax
c0024388:	83 d2 00             	adc    $0x0,%edx
c002438b:	a3 a0 50 03 c0       	mov    %eax,0xc00350a0
c0024390:	89 15 a4 50 03 c0    	mov    %edx,0xc00350a4
              input_putc (c);
c0024396:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024399:	0f b6 c0             	movzbl %al,%eax
c002439c:	83 ec 0c             	sub    $0xc,%esp
c002439f:	50                   	push   %eax
c00243a0:	e8 54 20 00 00       	call   c00263f9 <input_putc>
c00243a5:	83 c4 10             	add    $0x10,%esp
      if (!release) 
c00243a8:	eb 40                	jmp    c00243ea <keyboard_interrupt+0x24c>
      for (key = shift_keys; key->scancode != 0; key++) 
c00243aa:	c7 45 f0 e0 f6 02 c0 	movl   $0xc002f6e0,-0x10(%ebp)
c00243b1:	eb 2c                	jmp    c00243df <keyboard_interrupt+0x241>
        if (key->scancode == code)
c00243b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00243b6:	8b 00                	mov    (%eax),%eax
c00243b8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00243bb:	75 1e                	jne    c00243db <keyboard_interrupt+0x23d>
            *key->state_var = !release;
c00243bd:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c00243c1:	85 c0                	test   %eax,%eax
c00243c3:	0f 95 c0             	setne  %al
c00243c6:	83 f0 01             	xor    $0x1,%eax
c00243c9:	0f b6 c8             	movzbl %al,%ecx
c00243cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00243cf:	8b 50 04             	mov    0x4(%eax),%edx
c00243d2:	88 c8                	mov    %cl,%al
c00243d4:	83 e0 01             	and    $0x1,%eax
c00243d7:	88 02                	mov    %al,(%edx)
            break;
c00243d9:	eb 10                	jmp    c00243eb <keyboard_interrupt+0x24d>
      for (key = shift_keys; key->scancode != 0; key++) 
c00243db:	83 45 f0 08          	addl   $0x8,-0x10(%ebp)
c00243df:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00243e2:	8b 00                	mov    (%eax),%eax
c00243e4:	85 c0                	test   %eax,%eax
c00243e6:	75 cb                	jne    c00243b3 <keyboard_interrupt+0x215>
}
c00243e8:	eb 01                	jmp    c00243eb <keyboard_interrupt+0x24d>
      if (!release) 
c00243ea:	90                   	nop
}
c00243eb:	90                   	nop
c00243ec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00243ef:	c9                   	leave  
c00243f0:	c3                   	ret    

c00243f1 <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c00243f1:	55                   	push   %ebp
c00243f2:	89 e5                	mov    %esp,%ebp
c00243f4:	53                   	push   %ebx
c00243f5:	83 ec 04             	sub    $0x4,%esp
  for (; k->first_scancode != 0; k++)
c00243f8:	eb 55                	jmp    c002444f <map_key+0x5e>
    if (scancode >= k->first_scancode
c00243fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00243fd:	8a 00                	mov    (%eax),%al
c00243ff:	0f b6 c0             	movzbl %al,%eax
c0024402:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0024405:	72 44                	jb     c002444b <map_key+0x5a>
        && scancode < k->first_scancode + strlen (k->chars)) 
c0024407:	8b 45 08             	mov    0x8(%ebp),%eax
c002440a:	8a 00                	mov    (%eax),%al
c002440c:	0f b6 d8             	movzbl %al,%ebx
c002440f:	8b 45 08             	mov    0x8(%ebp),%eax
c0024412:	8b 40 04             	mov    0x4(%eax),%eax
c0024415:	83 ec 0c             	sub    $0xc,%esp
c0024418:	50                   	push   %eax
c0024419:	e8 85 45 00 00       	call   c00289a3 <strlen>
c002441e:	83 c4 10             	add    $0x10,%esp
c0024421:	01 d8                	add    %ebx,%eax
c0024423:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0024426:	73 23                	jae    c002444b <map_key+0x5a>
      {
        *c = k->chars[scancode - k->first_scancode];
c0024428:	8b 45 08             	mov    0x8(%ebp),%eax
c002442b:	8b 50 04             	mov    0x4(%eax),%edx
c002442e:	8b 45 08             	mov    0x8(%ebp),%eax
c0024431:	8a 00                	mov    (%eax),%al
c0024433:	0f b6 c0             	movzbl %al,%eax
c0024436:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0024439:	29 c1                	sub    %eax,%ecx
c002443b:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
c002443e:	8a 00                	mov    (%eax),%al
c0024440:	88 c2                	mov    %al,%dl
c0024442:	8b 45 10             	mov    0x10(%ebp),%eax
c0024445:	88 10                	mov    %dl,(%eax)
        return true; 
c0024447:	b0 01                	mov    $0x1,%al
c0024449:	eb 0f                	jmp    c002445a <map_key+0x69>
  for (; k->first_scancode != 0; k++)
c002444b:	83 45 08 08          	addl   $0x8,0x8(%ebp)
c002444f:	8b 45 08             	mov    0x8(%ebp),%eax
c0024452:	8a 00                	mov    (%eax),%al
c0024454:	84 c0                	test   %al,%al
c0024456:	75 a2                	jne    c00243fa <map_key+0x9>
      }

  return false;
c0024458:	b0 00                	mov    $0x0,%al
}
c002445a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002445d:	c9                   	leave  
c002445e:	c3                   	ret    

c002445f <inb>:
{
c002445f:	55                   	push   %ebp
c0024460:	89 e5                	mov    %esp,%ebp
c0024462:	83 ec 14             	sub    $0x14,%esp
c0024465:	8b 45 08             	mov    0x8(%ebp),%eax
c0024468:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002446c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002446f:	89 c2                	mov    %eax,%edx
c0024471:	ec                   	in     (%dx),%al
c0024472:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024475:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0024478:	c9                   	leave  
c0024479:	c3                   	ret    

c002447a <outb>:
{
c002447a:	55                   	push   %ebp
c002447b:	89 e5                	mov    %esp,%ebp
c002447d:	83 ec 08             	sub    $0x8,%esp
c0024480:	8b 45 08             	mov    0x8(%ebp),%eax
c0024483:	8b 55 0c             	mov    0xc(%ebp),%edx
c0024486:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c002448a:	88 d0                	mov    %dl,%al
c002448c:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002448f:	8a 45 f8             	mov    -0x8(%ebp),%al
c0024492:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0024495:	ee                   	out    %al,(%dx)
}
c0024496:	90                   	nop
c0024497:	c9                   	leave  
c0024498:	c3                   	ret    

c0024499 <outw>:
}

/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
c0024499:	55                   	push   %ebp
c002449a:	89 e5                	mov    %esp,%ebp
c002449c:	83 ec 08             	sub    $0x8,%esp
c002449f:	8b 55 08             	mov    0x8(%ebp),%edx
c00244a2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00244a5:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c00244a9:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c00244ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00244b0:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00244b3:	66 ef                	out    %ax,(%dx)
}
c00244b5:	90                   	nop
c00244b6:	c9                   	leave  
c00244b7:	c3                   	ret    

c00244b8 <ptov>:
{
c00244b8:	55                   	push   %ebp
c00244b9:	89 e5                	mov    %esp,%ebp
c00244bb:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c00244be:	8b 45 08             	mov    0x8(%ebp),%eax
c00244c1:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00244c6:	76 1e                	jbe    c00244e6 <ptov+0x2e>
c00244c8:	83 ec 0c             	sub    $0xc,%esp
c00244cb:	68 18 f7 02 c0       	push   $0xc002f718
c00244d0:	68 33 f7 02 c0       	push   $0xc002f733
c00244d5:	68 7c f7 02 c0       	push   $0xc002f77c
c00244da:	6a 4a                	push   $0x4a
c00244dc:	68 4a f7 02 c0       	push   $0xc002f74a
c00244e1:	e8 38 50 00 00       	call   c002951e <debug_panic>
  return (void *) (paddr + PHYS_BASE);
c00244e6:	8b 45 08             	mov    0x8(%ebp),%eax
c00244e9:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c00244ee:	c9                   	leave  
c00244ef:	c3                   	ret    

c00244f0 <init>:
static void find_cursor (size_t *x, size_t *y);

/* Initializes the VGA text display. */
static void
init (void)
{
c00244f0:	55                   	push   %ebp
c00244f1:	89 e5                	mov    %esp,%ebp
c00244f3:	83 ec 08             	sub    $0x8,%esp
  /* Already initialized? */
  static bool inited;
  if (!inited)
c00244f6:	a0 b4 50 03 c0       	mov    0xc00350b4,%al
c00244fb:	83 f0 01             	xor    $0x1,%eax
c00244fe:	84 c0                	test   %al,%al
c0024500:	74 31                	je     c0024533 <init+0x43>
    {
      fb = ptov (0xb8000);
c0024502:	83 ec 0c             	sub    $0xc,%esp
c0024505:	68 00 80 0b 00       	push   $0xb8000
c002450a:	e8 a9 ff ff ff       	call   c00244b8 <ptov>
c002450f:	83 c4 10             	add    $0x10,%esp
c0024512:	a3 b0 50 03 c0       	mov    %eax,0xc00350b0
      find_cursor (&cx, &cy);
c0024517:	83 ec 08             	sub    $0x8,%esp
c002451a:	68 ac 50 03 c0       	push   $0xc00350ac
c002451f:	68 a8 50 03 c0       	push   $0xc00350a8
c0024524:	e8 90 02 00 00       	call   c00247b9 <find_cursor>
c0024529:	83 c4 10             	add    $0x10,%esp
      inited = true; 
c002452c:	c6 05 b4 50 03 c0 01 	movb   $0x1,0xc00350b4
    }
}
c0024533:	90                   	nop
c0024534:	c9                   	leave  
c0024535:	c3                   	ret    

c0024536 <vga_putc>:

/* Writes C to the VGA text display, interpreting control
   characters in the conventional ways.  */
void
vga_putc (int c)
{
c0024536:	55                   	push   %ebp
c0024537:	89 e5                	mov    %esp,%ebp
c0024539:	83 ec 18             	sub    $0x18,%esp
  /* Disable interrupts to lock out interrupt handlers
     that might write to the console. */
  enum intr_level old_level = intr_disable ();
c002453c:	e8 5c ce ff ff       	call   c002139d <intr_disable>
c0024541:	89 45 f4             	mov    %eax,-0xc(%ebp)

  init ();
c0024544:	e8 a7 ff ff ff       	call   c00244f0 <init>
c0024549:	8b 45 08             	mov    0x8(%ebp),%eax
c002454c:	83 e8 07             	sub    $0x7,%eax
c002454f:	83 f8 06             	cmp    $0x6,%eax
c0024552:	0f 87 8b 00 00 00    	ja     c00245e3 <vga_putc+0xad>
c0024558:	8b 04 85 60 f7 02 c0 	mov    -0x3ffd08a0(,%eax,4),%eax
c002455f:	ff e0                	jmp    *%eax
  
  switch (c) 
    {
    case '\n':
      newline ();
c0024561:	e8 96 01 00 00       	call   c00246fc <newline>
      break;
c0024566:	e9 e2 00 00 00       	jmp    c002464d <vga_putc+0x117>

    case '\f':
      cls ();
c002456b:	e8 f3 00 00 00       	call   c0024663 <cls>
      break;
c0024570:	e9 d8 00 00 00       	jmp    c002464d <vga_putc+0x117>

    case '\b':
      if (cx > 0)
c0024575:	a1 a8 50 03 c0       	mov    0xc00350a8,%eax
c002457a:	85 c0                	test   %eax,%eax
c002457c:	0f 84 c4 00 00 00    	je     c0024646 <vga_putc+0x110>
        cx--;
c0024582:	a1 a8 50 03 c0       	mov    0xc00350a8,%eax
c0024587:	48                   	dec    %eax
c0024588:	a3 a8 50 03 c0       	mov    %eax,0xc00350a8
      break;
c002458d:	e9 b4 00 00 00       	jmp    c0024646 <vga_putc+0x110>
      
    case '\r':
      cx = 0;
c0024592:	c7 05 a8 50 03 c0 00 	movl   $0x0,0xc00350a8
c0024599:	00 00 00 
      break;
c002459c:	e9 ac 00 00 00       	jmp    c002464d <vga_putc+0x117>

    case '\t':
      cx = ROUND_UP (cx + 1, 8);
c00245a1:	a1 a8 50 03 c0       	mov    0xc00350a8,%eax
c00245a6:	83 c0 08             	add    $0x8,%eax
c00245a9:	83 e0 f8             	and    $0xfffffff8,%eax
c00245ac:	a3 a8 50 03 c0       	mov    %eax,0xc00350a8
      if (cx >= COL_CNT)
c00245b1:	a1 a8 50 03 c0       	mov    0xc00350a8,%eax
c00245b6:	83 f8 4f             	cmp    $0x4f,%eax
c00245b9:	0f 86 8a 00 00 00    	jbe    c0024649 <vga_putc+0x113>
        newline ();
c00245bf:	e8 38 01 00 00       	call   c00246fc <newline>
      break;
c00245c4:	e9 80 00 00 00       	jmp    c0024649 <vga_putc+0x113>

    case '\a':
      intr_set_level (old_level);
c00245c9:	83 ec 0c             	sub    $0xc,%esp
c00245cc:	ff 75 f4             	push   -0xc(%ebp)
c00245cf:	e8 71 cd ff ff       	call   c0021345 <intr_set_level>
c00245d4:	83 c4 10             	add    $0x10,%esp
      speaker_beep ();
c00245d7:	e8 58 28 00 00       	call   c0026e34 <speaker_beep>
      intr_disable ();
c00245dc:	e8 bc cd ff ff       	call   c002139d <intr_disable>
      break;
c00245e1:	eb 6a                	jmp    c002464d <vga_putc+0x117>
      
    default:
      fb[cy][cx][0] = c;
c00245e3:	8b 0d b0 50 03 c0    	mov    0xc00350b0,%ecx
c00245e9:	8b 15 ac 50 03 c0    	mov    0xc00350ac,%edx
c00245ef:	89 d0                	mov    %edx,%eax
c00245f1:	c1 e0 02             	shl    $0x2,%eax
c00245f4:	01 d0                	add    %edx,%eax
c00245f6:	c1 e0 05             	shl    $0x5,%eax
c00245f9:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c00245fc:	a1 a8 50 03 c0       	mov    0xc00350a8,%eax
c0024601:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0024604:	88 0c 42             	mov    %cl,(%edx,%eax,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c0024607:	8b 0d b0 50 03 c0    	mov    0xc00350b0,%ecx
c002460d:	8b 15 ac 50 03 c0    	mov    0xc00350ac,%edx
c0024613:	89 d0                	mov    %edx,%eax
c0024615:	c1 e0 02             	shl    $0x2,%eax
c0024618:	01 d0                	add    %edx,%eax
c002461a:	c1 e0 05             	shl    $0x5,%eax
c002461d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024620:	a1 a8 50 03 c0       	mov    0xc00350a8,%eax
c0024625:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c002462a:	a1 a8 50 03 c0       	mov    0xc00350a8,%eax
c002462f:	40                   	inc    %eax
c0024630:	a3 a8 50 03 c0       	mov    %eax,0xc00350a8
c0024635:	a1 a8 50 03 c0       	mov    0xc00350a8,%eax
c002463a:	83 f8 4f             	cmp    $0x4f,%eax
c002463d:	76 0d                	jbe    c002464c <vga_putc+0x116>
        newline ();
c002463f:	e8 b8 00 00 00       	call   c00246fc <newline>
      break;
c0024644:	eb 06                	jmp    c002464c <vga_putc+0x116>
      break;
c0024646:	90                   	nop
c0024647:	eb 04                	jmp    c002464d <vga_putc+0x117>
      break;
c0024649:	90                   	nop
c002464a:	eb 01                	jmp    c002464d <vga_putc+0x117>
      break;
c002464c:	90                   	nop
    }

  /* Update cursor position. */
  move_cursor ();
c002464d:	e8 0b 01 00 00       	call   c002475d <move_cursor>

  intr_set_level (old_level);
c0024652:	83 ec 0c             	sub    $0xc,%esp
c0024655:	ff 75 f4             	push   -0xc(%ebp)
c0024658:	e8 e8 cc ff ff       	call   c0021345 <intr_set_level>
c002465d:	83 c4 10             	add    $0x10,%esp
}
c0024660:	90                   	nop
c0024661:	c9                   	leave  
c0024662:	c3                   	ret    

c0024663 <cls>:

/* Clears the screen and moves the cursor to the upper left. */
static void
cls (void)
{
c0024663:	55                   	push   %ebp
c0024664:	89 e5                	mov    %esp,%ebp
c0024666:	83 ec 18             	sub    $0x18,%esp
  size_t y;

  for (y = 0; y < ROW_CNT; y++)
c0024669:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0024670:	eb 11                	jmp    c0024683 <cls+0x20>
    clear_row (y);
c0024672:	83 ec 0c             	sub    $0xc,%esp
c0024675:	ff 75 f4             	push   -0xc(%ebp)
c0024678:	e8 28 00 00 00       	call   c00246a5 <clear_row>
c002467d:	83 c4 10             	add    $0x10,%esp
  for (y = 0; y < ROW_CNT; y++)
c0024680:	ff 45 f4             	incl   -0xc(%ebp)
c0024683:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0024687:	76 e9                	jbe    c0024672 <cls+0xf>

  cx = cy = 0;
c0024689:	c7 05 ac 50 03 c0 00 	movl   $0x0,0xc00350ac
c0024690:	00 00 00 
c0024693:	a1 ac 50 03 c0       	mov    0xc00350ac,%eax
c0024698:	a3 a8 50 03 c0       	mov    %eax,0xc00350a8
  move_cursor ();
c002469d:	e8 bb 00 00 00       	call   c002475d <move_cursor>
}
c00246a2:	90                   	nop
c00246a3:	c9                   	leave  
c00246a4:	c3                   	ret    

c00246a5 <clear_row>:

/* Clears row Y to spaces. */
static void
clear_row (size_t y) 
{
c00246a5:	55                   	push   %ebp
c00246a6:	89 e5                	mov    %esp,%ebp
c00246a8:	83 ec 10             	sub    $0x10,%esp
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c00246ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00246b2:	eb 3e                	jmp    c00246f2 <clear_row+0x4d>
    {
      fb[y][x][0] = ' ';
c00246b4:	8b 0d b0 50 03 c0    	mov    0xc00350b0,%ecx
c00246ba:	8b 55 08             	mov    0x8(%ebp),%edx
c00246bd:	89 d0                	mov    %edx,%eax
c00246bf:	c1 e0 02             	shl    $0x2,%eax
c00246c2:	01 d0                	add    %edx,%eax
c00246c4:	c1 e0 05             	shl    $0x5,%eax
c00246c7:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c00246ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00246cd:	c6 04 42 20          	movb   $0x20,(%edx,%eax,2)
      fb[y][x][1] = GRAY_ON_BLACK;
c00246d1:	8b 0d b0 50 03 c0    	mov    0xc00350b0,%ecx
c00246d7:	8b 55 08             	mov    0x8(%ebp),%edx
c00246da:	89 d0                	mov    %edx,%eax
c00246dc:	c1 e0 02             	shl    $0x2,%eax
c00246df:	01 d0                	add    %edx,%eax
c00246e1:	c1 e0 05             	shl    $0x5,%eax
c00246e4:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c00246e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00246ea:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
  for (x = 0; x < COL_CNT; x++)
c00246ef:	ff 45 fc             	incl   -0x4(%ebp)
c00246f2:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
c00246f6:	76 bc                	jbe    c00246b4 <clear_row+0xf>
    }
}
c00246f8:	90                   	nop
c00246f9:	90                   	nop
c00246fa:	c9                   	leave  
c00246fb:	c3                   	ret    

c00246fc <newline>:
/* Advances the cursor to the first column in the next line on
   the screen.  If the cursor is already on the last line on the
   screen, scrolls the screen upward one line. */
static void
newline (void)
{
c00246fc:	55                   	push   %ebp
c00246fd:	89 e5                	mov    %esp,%ebp
c00246ff:	83 ec 08             	sub    $0x8,%esp
  cx = 0;
c0024702:	c7 05 a8 50 03 c0 00 	movl   $0x0,0xc00350a8
c0024709:	00 00 00 
  cy++;
c002470c:	a1 ac 50 03 c0       	mov    0xc00350ac,%eax
c0024711:	40                   	inc    %eax
c0024712:	a3 ac 50 03 c0       	mov    %eax,0xc00350ac
  if (cy >= ROW_CNT)
c0024717:	a1 ac 50 03 c0       	mov    0xc00350ac,%eax
c002471c:	83 f8 18             	cmp    $0x18,%eax
c002471f:	76 39                	jbe    c002475a <newline+0x5e>
    {
      cy = ROW_CNT - 1;
c0024721:	c7 05 ac 50 03 c0 18 	movl   $0x18,0xc00350ac
c0024728:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c002472b:	a1 b0 50 03 c0       	mov    0xc00350b0,%eax
c0024730:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0024736:	a1 b0 50 03 c0       	mov    0xc00350b0,%eax
c002473b:	83 ec 04             	sub    $0x4,%esp
c002473e:	68 00 0f 00 00       	push   $0xf00
c0024743:	52                   	push   %edx
c0024744:	50                   	push   %eax
c0024745:	e8 b4 3c 00 00       	call   c00283fe <memmove>
c002474a:	83 c4 10             	add    $0x10,%esp
      clear_row (ROW_CNT - 1);
c002474d:	83 ec 0c             	sub    $0xc,%esp
c0024750:	6a 18                	push   $0x18
c0024752:	e8 4e ff ff ff       	call   c00246a5 <clear_row>
c0024757:	83 c4 10             	add    $0x10,%esp
    }
}
c002475a:	90                   	nop
c002475b:	c9                   	leave  
c002475c:	c3                   	ret    

c002475d <move_cursor>:

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
c002475d:	55                   	push   %ebp
c002475e:	89 e5                	mov    %esp,%ebp
c0024760:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c0024763:	a1 ac 50 03 c0       	mov    0xc00350ac,%eax
c0024768:	89 c2                	mov    %eax,%edx
c002476a:	89 d0                	mov    %edx,%eax
c002476c:	c1 e0 02             	shl    $0x2,%eax
c002476f:	01 d0                	add    %edx,%eax
c0024771:	c1 e0 04             	shl    $0x4,%eax
c0024774:	89 c2                	mov    %eax,%edx
c0024776:	a1 a8 50 03 c0       	mov    0xc00350a8,%eax
c002477b:	01 d0                	add    %edx,%eax
c002477d:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  outw (0x3d4, 0x0e | (cp & 0xff00));
c0024781:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c0024785:	b0 00                	mov    $0x0,%al
c0024787:	83 c8 0e             	or     $0xe,%eax
c002478a:	0f b7 c0             	movzwl %ax,%eax
c002478d:	50                   	push   %eax
c002478e:	68 d4 03 00 00       	push   $0x3d4
c0024793:	e8 01 fd ff ff       	call   c0024499 <outw>
c0024798:	83 c4 08             	add    $0x8,%esp
  outw (0x3d4, 0x0f | (cp << 8));
c002479b:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c002479f:	c1 e0 08             	shl    $0x8,%eax
c00247a2:	83 c8 0f             	or     $0xf,%eax
c00247a5:	0f b7 c0             	movzwl %ax,%eax
c00247a8:	50                   	push   %eax
c00247a9:	68 d4 03 00 00       	push   $0x3d4
c00247ae:	e8 e6 fc ff ff       	call   c0024499 <outw>
c00247b3:	83 c4 08             	add    $0x8,%esp
}
c00247b6:	90                   	nop
c00247b7:	c9                   	leave  
c00247b8:	c3                   	ret    

c00247b9 <find_cursor>:

/* Reads the current hardware cursor position into (*X,*Y). */
static void
find_cursor (size_t *x, size_t *y) 
{
c00247b9:	55                   	push   %ebp
c00247ba:	89 e5                	mov    %esp,%ebp
c00247bc:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
c00247bf:	6a 0e                	push   $0xe
c00247c1:	68 d4 03 00 00       	push   $0x3d4
c00247c6:	e8 af fc ff ff       	call   c002447a <outb>
c00247cb:	83 c4 08             	add    $0x8,%esp
  cp = inb (0x3d5) << 8;
c00247ce:	68 d5 03 00 00       	push   $0x3d5
c00247d3:	e8 87 fc ff ff       	call   c002445f <inb>
c00247d8:	83 c4 04             	add    $0x4,%esp
c00247db:	0f b6 c0             	movzbl %al,%eax
c00247de:	c1 e0 08             	shl    $0x8,%eax
c00247e1:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

  outb (0x3d4, 0x0f);
c00247e5:	6a 0f                	push   $0xf
c00247e7:	68 d4 03 00 00       	push   $0x3d4
c00247ec:	e8 89 fc ff ff       	call   c002447a <outb>
c00247f1:	83 c4 08             	add    $0x8,%esp
  cp |= inb (0x3d5);
c00247f4:	68 d5 03 00 00       	push   $0x3d5
c00247f9:	e8 61 fc ff ff       	call   c002445f <inb>
c00247fe:	83 c4 04             	add    $0x4,%esp
c0024801:	0f b6 c0             	movzbl %al,%eax
c0024804:	66 09 45 fe          	or     %ax,-0x2(%ebp)

  *x = cp % COL_CNT;
c0024808:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c002480c:	b9 50 00 00 00       	mov    $0x50,%ecx
c0024811:	ba 00 00 00 00       	mov    $0x0,%edx
c0024816:	66 f7 f1             	div    %cx
c0024819:	89 d0                	mov    %edx,%eax
c002481b:	0f b7 d0             	movzwl %ax,%edx
c002481e:	8b 45 08             	mov    0x8(%ebp),%eax
c0024821:	89 10                	mov    %edx,(%eax)
  *y = cp / COL_CNT;
c0024823:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c0024827:	0f b7 d0             	movzwl %ax,%edx
c002482a:	89 d0                	mov    %edx,%eax
c002482c:	c1 e0 02             	shl    $0x2,%eax
c002482f:	01 d0                	add    %edx,%eax
c0024831:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c0024838:	01 c8                	add    %ecx,%eax
c002483a:	01 c0                	add    %eax,%eax
c002483c:	01 d0                	add    %edx,%eax
c002483e:	89 c1                	mov    %eax,%ecx
c0024840:	c1 e1 08             	shl    $0x8,%ecx
c0024843:	01 c8                	add    %ecx,%eax
c0024845:	c1 e0 02             	shl    $0x2,%eax
c0024848:	01 d0                	add    %edx,%eax
c002484a:	c1 e8 10             	shr    $0x10,%eax
c002484d:	66 c1 e8 06          	shr    $0x6,%ax
c0024851:	0f b7 d0             	movzwl %ax,%edx
c0024854:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024857:	89 10                	mov    %edx,(%eax)
}
c0024859:	90                   	nop
c002485a:	c9                   	leave  
c002485b:	c3                   	ret    

c002485c <inb>:
{
c002485c:	55                   	push   %ebp
c002485d:	89 e5                	mov    %esp,%ebp
c002485f:	83 ec 14             	sub    $0x14,%esp
c0024862:	8b 45 08             	mov    0x8(%ebp),%eax
c0024865:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024869:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002486c:	89 c2                	mov    %eax,%edx
c002486e:	ec                   	in     (%dx),%al
c002486f:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024872:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0024875:	c9                   	leave  
c0024876:	c3                   	ret    

c0024877 <outb>:
{
c0024877:	55                   	push   %ebp
c0024878:	89 e5                	mov    %esp,%ebp
c002487a:	83 ec 08             	sub    $0x8,%esp
c002487d:	8b 45 08             	mov    0x8(%ebp),%eax
c0024880:	8b 55 0c             	mov    0xc(%ebp),%edx
c0024883:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0024887:	88 d0                	mov    %dl,%al
c0024889:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002488c:	8a 45 f8             	mov    -0x8(%ebp),%al
c002488f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0024892:	ee                   	out    %al,(%dx)
}
c0024893:	90                   	nop
c0024894:	c9                   	leave  
c0024895:	c3                   	ret    

c0024896 <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c0024896:	55                   	push   %ebp
c0024897:	89 e5                	mov    %esp,%ebp
c0024899:	83 ec 08             	sub    $0x8,%esp
  ASSERT (mode == UNINIT);
c002489c:	a1 c0 50 03 c0       	mov    0xc00350c0,%eax
c00248a1:	85 c0                	test   %eax,%eax
c00248a3:	74 1e                	je     c00248c3 <init_poll+0x2d>
c00248a5:	83 ec 0c             	sub    $0xc,%esp
c00248a8:	68 84 f7 02 c0       	push   $0xc002f784
c00248ad:	68 93 f7 02 c0       	push   $0xc002f793
c00248b2:	68 10 f8 02 c0       	push   $0xc002f810
c00248b7:	6a 45                	push   $0x45
c00248b9:	68 aa f7 02 c0       	push   $0xc002f7aa
c00248be:	e8 5b 4c 00 00       	call   c002951e <debug_panic>
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
c00248c3:	83 ec 08             	sub    $0x8,%esp
c00248c6:	6a 00                	push   $0x0
c00248c8:	68 f9 03 00 00       	push   $0x3f9
c00248cd:	e8 a5 ff ff ff       	call   c0024877 <outb>
c00248d2:	83 c4 10             	add    $0x10,%esp
  outb (FCR_REG, 0);                    /* Disable FIFO. */
c00248d5:	83 ec 08             	sub    $0x8,%esp
c00248d8:	6a 00                	push   $0x0
c00248da:	68 fa 03 00 00       	push   $0x3fa
c00248df:	e8 93 ff ff ff       	call   c0024877 <outb>
c00248e4:	83 c4 10             	add    $0x10,%esp
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
c00248e7:	83 ec 0c             	sub    $0xc,%esp
c00248ea:	68 80 25 00 00       	push   $0x2580
c00248ef:	e8 e8 01 00 00       	call   c0024adc <set_serial>
c00248f4:	83 c4 10             	add    $0x10,%esp
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
c00248f7:	83 ec 08             	sub    $0x8,%esp
c00248fa:	6a 08                	push   $0x8
c00248fc:	68 fc 03 00 00       	push   $0x3fc
c0024901:	e8 71 ff ff ff       	call   c0024877 <outb>
c0024906:	83 c4 10             	add    $0x10,%esp
  intq_init (&txq);
c0024909:	83 ec 0c             	sub    $0xc,%esp
c002490c:	68 e0 50 03 c0       	push   $0xc00350e0
c0024911:	e8 e0 1b 00 00       	call   c00264f6 <intq_init>
c0024916:	83 c4 10             	add    $0x10,%esp
  mode = POLL;
c0024919:	c7 05 c0 50 03 c0 01 	movl   $0x1,0xc00350c0
c0024920:	00 00 00 
} 
c0024923:	90                   	nop
c0024924:	c9                   	leave  
c0024925:	c3                   	ret    

c0024926 <serial_init_queue>:
/* Initializes the serial port device for queued interrupt-driven
   I/O.  With interrupt-driven I/O we don't waste CPU time
   waiting for the serial device to become ready. */
void
serial_init_queue (void) 
{
c0024926:	55                   	push   %ebp
c0024927:	89 e5                	mov    %esp,%ebp
c0024929:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  if (mode == UNINIT)
c002492c:	a1 c0 50 03 c0       	mov    0xc00350c0,%eax
c0024931:	85 c0                	test   %eax,%eax
c0024933:	75 05                	jne    c002493a <serial_init_queue+0x14>
    init_poll ();
c0024935:	e8 5c ff ff ff       	call   c0024896 <init_poll>
  ASSERT (mode == POLL);
c002493a:	a1 c0 50 03 c0       	mov    0xc00350c0,%eax
c002493f:	83 f8 01             	cmp    $0x1,%eax
c0024942:	74 1e                	je     c0024962 <serial_init_queue+0x3c>
c0024944:	83 ec 0c             	sub    $0xc,%esp
c0024947:	68 c1 f7 02 c0       	push   $0xc002f7c1
c002494c:	68 93 f7 02 c0       	push   $0xc002f793
c0024951:	68 1c f8 02 c0       	push   $0xc002f81c
c0024956:	6a 58                	push   $0x58
c0024958:	68 aa f7 02 c0       	push   $0xc002f7aa
c002495d:	e8 bc 4b 00 00       	call   c002951e <debug_panic>

  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c0024962:	83 ec 04             	sub    $0x4,%esp
c0024965:	68 ce f7 02 c0       	push   $0xc002f7ce
c002496a:	68 65 4c 02 c0       	push   $0xc0024c65
c002496f:	6a 24                	push   $0x24
c0024971:	e8 46 cc ff ff       	call   c00215bc <intr_register_ext>
c0024976:	83 c4 10             	add    $0x10,%esp
  mode = QUEUE;
c0024979:	c7 05 c0 50 03 c0 02 	movl   $0x2,0xc00350c0
c0024980:	00 00 00 
  old_level = intr_disable ();
c0024983:	e8 15 ca ff ff       	call   c002139d <intr_disable>
c0024988:	89 45 f4             	mov    %eax,-0xc(%ebp)
  write_ier ();
c002498b:	e8 f5 01 00 00       	call   c0024b85 <write_ier>
  intr_set_level (old_level);
c0024990:	83 ec 0c             	sub    $0xc,%esp
c0024993:	ff 75 f4             	push   -0xc(%ebp)
c0024996:	e8 aa c9 ff ff       	call   c0021345 <intr_set_level>
c002499b:	83 c4 10             	add    $0x10,%esp
}
c002499e:	90                   	nop
c002499f:	c9                   	leave  
c00249a0:	c3                   	ret    

c00249a1 <serial_putc>:

/* Sends BYTE to the serial port. */
void
serial_putc (uint8_t byte) 
{
c00249a1:	55                   	push   %ebp
c00249a2:	89 e5                	mov    %esp,%ebp
c00249a4:	83 ec 28             	sub    $0x28,%esp
c00249a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00249aa:	88 45 e4             	mov    %al,-0x1c(%ebp)
  enum intr_level old_level = intr_disable ();
c00249ad:	e8 eb c9 ff ff       	call   c002139d <intr_disable>
c00249b2:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (mode != QUEUE)
c00249b5:	a1 c0 50 03 c0       	mov    0xc00350c0,%eax
c00249ba:	83 f8 02             	cmp    $0x2,%eax
c00249bd:	74 20                	je     c00249df <serial_putc+0x3e>
    {
      /* If we're not set up for interrupt-driven I/O yet,
         use dumb polling to transmit a byte. */
      if (mode == UNINIT)
c00249bf:	a1 c0 50 03 c0       	mov    0xc00350c0,%eax
c00249c4:	85 c0                	test   %eax,%eax
c00249c6:	75 05                	jne    c00249cd <serial_putc+0x2c>
        init_poll ();
c00249c8:	e8 c9 fe ff ff       	call   c0024896 <init_poll>
      putc_poll (byte); 
c00249cd:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00249d1:	83 ec 0c             	sub    $0xc,%esp
c00249d4:	50                   	push   %eax
c00249d5:	e8 22 02 00 00       	call   c0024bfc <putc_poll>
c00249da:	83 c4 10             	add    $0x10,%esp
c00249dd:	eb 53                	jmp    c0024a32 <serial_putc+0x91>
    }
  else 
    {
      /* Otherwise, queue a byte and update the interrupt enable
         register. */
      if (old_level == INTR_OFF && intq_full (&txq)) 
c00249df:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00249e3:	75 33                	jne    c0024a18 <serial_putc+0x77>
c00249e5:	83 ec 0c             	sub    $0xc,%esp
c00249e8:	68 e0 50 03 c0       	push   $0xc00350e0
c00249ed:	e8 88 1b 00 00       	call   c002657a <intq_full>
c00249f2:	83 c4 10             	add    $0x10,%esp
c00249f5:	84 c0                	test   %al,%al
c00249f7:	74 1f                	je     c0024a18 <serial_putc+0x77>
          /* Interrupts are off and the transmit queue is full.
             If we wanted to wait for the queue to empty,
             we'd have to reenable interrupts.
             That's impolite, so we'll send a character via
             polling instead. */
          putc_poll (intq_getc (&txq)); 
c00249f9:	83 ec 0c             	sub    $0xc,%esp
c00249fc:	68 e0 50 03 c0       	push   $0xc00350e0
c0024a01:	e8 c0 1b 00 00       	call   c00265c6 <intq_getc>
c0024a06:	83 c4 10             	add    $0x10,%esp
c0024a09:	0f b6 c0             	movzbl %al,%eax
c0024a0c:	83 ec 0c             	sub    $0xc,%esp
c0024a0f:	50                   	push   %eax
c0024a10:	e8 e7 01 00 00       	call   c0024bfc <putc_poll>
c0024a15:	83 c4 10             	add    $0x10,%esp
        }

      intq_putc (&txq, byte); 
c0024a18:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0024a1c:	83 ec 08             	sub    $0x8,%esp
c0024a1f:	50                   	push   %eax
c0024a20:	68 e0 50 03 c0       	push   $0xc00350e0
c0024a25:	e8 7a 1c 00 00       	call   c00266a4 <intq_putc>
c0024a2a:	83 c4 10             	add    $0x10,%esp
      write_ier ();
c0024a2d:	e8 53 01 00 00       	call   c0024b85 <write_ier>
    }
  
  intr_set_level (old_level);
c0024a32:	83 ec 0c             	sub    $0xc,%esp
c0024a35:	ff 75 f4             	push   -0xc(%ebp)
c0024a38:	e8 08 c9 ff ff       	call   c0021345 <intr_set_level>
c0024a3d:	83 c4 10             	add    $0x10,%esp
}
c0024a40:	90                   	nop
c0024a41:	c9                   	leave  
c0024a42:	c3                   	ret    

c0024a43 <serial_flush>:

/* Flushes anything in the serial buffer out the port in polling
   mode. */
void
serial_flush (void) 
{
c0024a43:	55                   	push   %ebp
c0024a44:	89 e5                	mov    %esp,%ebp
c0024a46:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0024a49:	e8 4f c9 ff ff       	call   c002139d <intr_disable>
c0024a4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!intq_empty (&txq))
c0024a51:	eb 1f                	jmp    c0024a72 <serial_flush+0x2f>
    putc_poll (intq_getc (&txq));
c0024a53:	83 ec 0c             	sub    $0xc,%esp
c0024a56:	68 e0 50 03 c0       	push   $0xc00350e0
c0024a5b:	e8 66 1b 00 00       	call   c00265c6 <intq_getc>
c0024a60:	83 c4 10             	add    $0x10,%esp
c0024a63:	0f b6 c0             	movzbl %al,%eax
c0024a66:	83 ec 0c             	sub    $0xc,%esp
c0024a69:	50                   	push   %eax
c0024a6a:	e8 8d 01 00 00       	call   c0024bfc <putc_poll>
c0024a6f:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq))
c0024a72:	83 ec 0c             	sub    $0xc,%esp
c0024a75:	68 e0 50 03 c0       	push   $0xc00350e0
c0024a7a:	e8 bb 1a 00 00       	call   c002653a <intq_empty>
c0024a7f:	83 c4 10             	add    $0x10,%esp
c0024a82:	83 f0 01             	xor    $0x1,%eax
c0024a85:	84 c0                	test   %al,%al
c0024a87:	75 ca                	jne    c0024a53 <serial_flush+0x10>
  intr_set_level (old_level);
c0024a89:	83 ec 0c             	sub    $0xc,%esp
c0024a8c:	ff 75 f4             	push   -0xc(%ebp)
c0024a8f:	e8 b1 c8 ff ff       	call   c0021345 <intr_set_level>
c0024a94:	83 c4 10             	add    $0x10,%esp
}
c0024a97:	90                   	nop
c0024a98:	c9                   	leave  
c0024a99:	c3                   	ret    

c0024a9a <serial_notify>:
   whether we should block receive interrupts.
   Called by the input buffer routines when characters are added
   to or removed from the buffer. */
void
serial_notify (void) 
{
c0024a9a:	55                   	push   %ebp
c0024a9b:	89 e5                	mov    %esp,%ebp
c0024a9d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0024aa0:	e8 8a c8 ff ff       	call   c002132f <intr_get_level>
c0024aa5:	85 c0                	test   %eax,%eax
c0024aa7:	74 21                	je     c0024aca <serial_notify+0x30>
c0024aa9:	83 ec 0c             	sub    $0xc,%esp
c0024aac:	68 d5 f7 02 c0       	push   $0xc002f7d5
c0024ab1:	68 93 f7 02 c0       	push   $0xc002f793
c0024ab6:	68 30 f8 02 c0       	push   $0xc002f830
c0024abb:	68 96 00 00 00       	push   $0x96
c0024ac0:	68 aa f7 02 c0       	push   $0xc002f7aa
c0024ac5:	e8 54 4a 00 00       	call   c002951e <debug_panic>
  if (mode == QUEUE)
c0024aca:	a1 c0 50 03 c0       	mov    0xc00350c0,%eax
c0024acf:	83 f8 02             	cmp    $0x2,%eax
c0024ad2:	75 05                	jne    c0024ad9 <serial_notify+0x3f>
    write_ier ();
c0024ad4:	e8 ac 00 00 00       	call   c0024b85 <write_ier>
}
c0024ad9:	90                   	nop
c0024ada:	c9                   	leave  
c0024adb:	c3                   	ret    

c0024adc <set_serial>:

/* Configures the serial port for BPS bits per second. */
static void
set_serial (int bps)
{
c0024adc:	55                   	push   %ebp
c0024add:	89 e5                	mov    %esp,%ebp
c0024adf:	83 ec 18             	sub    $0x18,%esp
  int base_rate = 1843200 / 16;         /* Base rate of 16550A, in Hz. */
c0024ae2:	c7 45 f4 00 c2 01 00 	movl   $0x1c200,-0xc(%ebp)
  uint16_t divisor = base_rate / bps;   /* Clock rate divisor. */
c0024ae9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024aec:	99                   	cltd   
c0024aed:	f7 7d 08             	idivl  0x8(%ebp)
c0024af0:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

  ASSERT (bps >= 300 && bps <= 115200);
c0024af4:	81 7d 08 2b 01 00 00 	cmpl   $0x12b,0x8(%ebp)
c0024afb:	7e 09                	jle    c0024b06 <set_serial+0x2a>
c0024afd:	81 7d 08 00 c2 01 00 	cmpl   $0x1c200,0x8(%ebp)
c0024b04:	7e 21                	jle    c0024b27 <set_serial+0x4b>
c0024b06:	83 ec 0c             	sub    $0xc,%esp
c0024b09:	68 f3 f7 02 c0       	push   $0xc002f7f3
c0024b0e:	68 93 f7 02 c0       	push   $0xc002f793
c0024b13:	68 40 f8 02 c0       	push   $0xc002f840
c0024b18:	68 a2 00 00 00       	push   $0xa2
c0024b1d:	68 aa f7 02 c0       	push   $0xc002f7aa
c0024b22:	e8 f7 49 00 00       	call   c002951e <debug_panic>

  /* Enable DLAB. */
  outb (LCR_REG, LCR_N81 | LCR_DLAB);
c0024b27:	83 ec 08             	sub    $0x8,%esp
c0024b2a:	68 83 00 00 00       	push   $0x83
c0024b2f:	68 fb 03 00 00       	push   $0x3fb
c0024b34:	e8 3e fd ff ff       	call   c0024877 <outb>
c0024b39:	83 c4 10             	add    $0x10,%esp

  /* Set data rate. */
  outb (LS_REG, divisor & 0xff);
c0024b3c:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
c0024b40:	0f b6 c0             	movzbl %al,%eax
c0024b43:	83 ec 08             	sub    $0x8,%esp
c0024b46:	50                   	push   %eax
c0024b47:	68 f8 03 00 00       	push   $0x3f8
c0024b4c:	e8 26 fd ff ff       	call   c0024877 <outb>
c0024b51:	83 c4 10             	add    $0x10,%esp
  outb (MS_REG, divisor >> 8);
c0024b54:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
c0024b58:	66 c1 e8 08          	shr    $0x8,%ax
c0024b5c:	0f b6 c0             	movzbl %al,%eax
c0024b5f:	83 ec 08             	sub    $0x8,%esp
c0024b62:	50                   	push   %eax
c0024b63:	68 f9 03 00 00       	push   $0x3f9
c0024b68:	e8 0a fd ff ff       	call   c0024877 <outb>
c0024b6d:	83 c4 10             	add    $0x10,%esp
  
  /* Reset DLAB. */
  outb (LCR_REG, LCR_N81);
c0024b70:	83 ec 08             	sub    $0x8,%esp
c0024b73:	6a 03                	push   $0x3
c0024b75:	68 fb 03 00 00       	push   $0x3fb
c0024b7a:	e8 f8 fc ff ff       	call   c0024877 <outb>
c0024b7f:	83 c4 10             	add    $0x10,%esp
}
c0024b82:	90                   	nop
c0024b83:	c9                   	leave  
c0024b84:	c3                   	ret    

c0024b85 <write_ier>:

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c0024b85:	55                   	push   %ebp
c0024b86:	89 e5                	mov    %esp,%ebp
c0024b88:	83 ec 18             	sub    $0x18,%esp
  uint8_t ier = 0;
c0024b8b:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c0024b8f:	e8 9b c7 ff ff       	call   c002132f <intr_get_level>
c0024b94:	85 c0                	test   %eax,%eax
c0024b96:	74 21                	je     c0024bb9 <write_ier+0x34>
c0024b98:	83 ec 0c             	sub    $0xc,%esp
c0024b9b:	68 d5 f7 02 c0       	push   $0xc002f7d5
c0024ba0:	68 93 f7 02 c0       	push   $0xc002f793
c0024ba5:	68 4c f8 02 c0       	push   $0xc002f84c
c0024baa:	68 b5 00 00 00       	push   $0xb5
c0024baf:	68 aa f7 02 c0       	push   $0xc002f7aa
c0024bb4:	e8 65 49 00 00       	call   c002951e <debug_panic>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c0024bb9:	83 ec 0c             	sub    $0xc,%esp
c0024bbc:	68 e0 50 03 c0       	push   $0xc00350e0
c0024bc1:	e8 74 19 00 00       	call   c002653a <intq_empty>
c0024bc6:	83 c4 10             	add    $0x10,%esp
c0024bc9:	83 f0 01             	xor    $0x1,%eax
c0024bcc:	84 c0                	test   %al,%al
c0024bce:	74 04                	je     c0024bd4 <write_ier+0x4f>
    ier |= IER_XMIT;
c0024bd0:	80 4d f7 02          	orb    $0x2,-0x9(%ebp)

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c0024bd4:	e8 de 18 00 00       	call   c00264b7 <input_full>
c0024bd9:	83 f0 01             	xor    $0x1,%eax
c0024bdc:	84 c0                	test   %al,%al
c0024bde:	74 04                	je     c0024be4 <write_ier+0x5f>
    ier |= IER_RECV;
c0024be0:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
  
  outb (IER_REG, ier);
c0024be4:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0024be8:	83 ec 08             	sub    $0x8,%esp
c0024beb:	50                   	push   %eax
c0024bec:	68 f9 03 00 00       	push   $0x3f9
c0024bf1:	e8 81 fc ff ff       	call   c0024877 <outb>
c0024bf6:	83 c4 10             	add    $0x10,%esp
}
c0024bf9:	90                   	nop
c0024bfa:	c9                   	leave  
c0024bfb:	c3                   	ret    

c0024bfc <putc_poll>:

/* Polls the serial port until it's ready,
   and then transmits BYTE. */
static void
putc_poll (uint8_t byte) 
{
c0024bfc:	55                   	push   %ebp
c0024bfd:	89 e5                	mov    %esp,%ebp
c0024bff:	83 ec 18             	sub    $0x18,%esp
c0024c02:	8b 45 08             	mov    0x8(%ebp),%eax
c0024c05:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0024c08:	e8 22 c7 ff ff       	call   c002132f <intr_get_level>
c0024c0d:	85 c0                	test   %eax,%eax
c0024c0f:	74 22                	je     c0024c33 <putc_poll+0x37>
c0024c11:	83 ec 0c             	sub    $0xc,%esp
c0024c14:	68 d5 f7 02 c0       	push   $0xc002f7d5
c0024c19:	68 93 f7 02 c0       	push   $0xc002f793
c0024c1e:	68 58 f8 02 c0       	push   $0xc002f858
c0024c23:	68 c9 00 00 00       	push   $0xc9
c0024c28:	68 aa f7 02 c0       	push   $0xc002f7aa
c0024c2d:	e8 ec 48 00 00       	call   c002951e <debug_panic>

  while ((inb (LSR_REG) & LSR_THRE) == 0)
    continue;
c0024c32:	90                   	nop
  while ((inb (LSR_REG) & LSR_THRE) == 0)
c0024c33:	83 ec 0c             	sub    $0xc,%esp
c0024c36:	68 fd 03 00 00       	push   $0x3fd
c0024c3b:	e8 1c fc ff ff       	call   c002485c <inb>
c0024c40:	83 c4 10             	add    $0x10,%esp
c0024c43:	0f b6 c0             	movzbl %al,%eax
c0024c46:	83 e0 20             	and    $0x20,%eax
c0024c49:	85 c0                	test   %eax,%eax
c0024c4b:	74 e5                	je     c0024c32 <putc_poll+0x36>
  outb (THR_REG, byte);
c0024c4d:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0024c51:	83 ec 08             	sub    $0x8,%esp
c0024c54:	50                   	push   %eax
c0024c55:	68 f8 03 00 00       	push   $0x3f8
c0024c5a:	e8 18 fc ff ff       	call   c0024877 <outb>
c0024c5f:	83 c4 10             	add    $0x10,%esp
}
c0024c62:	90                   	nop
c0024c63:	c9                   	leave  
c0024c64:	c3                   	ret    

c0024c65 <serial_interrupt>:

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c0024c65:	55                   	push   %ebp
c0024c66:	89 e5                	mov    %esp,%ebp
c0024c68:	83 ec 08             	sub    $0x8,%esp
  /* Inquire about interrupt in UART.  Without this, we can
     occasionally miss an interrupt running under QEMU. */
  inb (IIR_REG);
c0024c6b:	68 fa 03 00 00       	push   $0x3fa
c0024c70:	e8 e7 fb ff ff       	call   c002485c <inb>
c0024c75:	83 c4 04             	add    $0x4,%esp

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0024c78:	eb 1c                	jmp    c0024c96 <serial_interrupt+0x31>
    input_putc (inb (RBR_REG));
c0024c7a:	68 f8 03 00 00       	push   $0x3f8
c0024c7f:	e8 d8 fb ff ff       	call   c002485c <inb>
c0024c84:	83 c4 04             	add    $0x4,%esp
c0024c87:	0f b6 c0             	movzbl %al,%eax
c0024c8a:	83 ec 0c             	sub    $0xc,%esp
c0024c8d:	50                   	push   %eax
c0024c8e:	e8 66 17 00 00       	call   c00263f9 <input_putc>
c0024c93:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0024c96:	e8 1c 18 00 00       	call   c00264b7 <input_full>
c0024c9b:	83 f0 01             	xor    $0x1,%eax
c0024c9e:	84 c0                	test   %al,%al
c0024ca0:	74 40                	je     c0024ce2 <serial_interrupt+0x7d>
c0024ca2:	83 ec 0c             	sub    $0xc,%esp
c0024ca5:	68 fd 03 00 00       	push   $0x3fd
c0024caa:	e8 ad fb ff ff       	call   c002485c <inb>
c0024caf:	83 c4 10             	add    $0x10,%esp
c0024cb2:	0f b6 c0             	movzbl %al,%eax
c0024cb5:	83 e0 01             	and    $0x1,%eax
c0024cb8:	85 c0                	test   %eax,%eax
c0024cba:	75 be                	jne    c0024c7a <serial_interrupt+0x15>

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024cbc:	eb 24                	jmp    c0024ce2 <serial_interrupt+0x7d>
    outb (THR_REG, intq_getc (&txq));
c0024cbe:	83 ec 0c             	sub    $0xc,%esp
c0024cc1:	68 e0 50 03 c0       	push   $0xc00350e0
c0024cc6:	e8 fb 18 00 00       	call   c00265c6 <intq_getc>
c0024ccb:	83 c4 10             	add    $0x10,%esp
c0024cce:	0f b6 c0             	movzbl %al,%eax
c0024cd1:	83 ec 08             	sub    $0x8,%esp
c0024cd4:	50                   	push   %eax
c0024cd5:	68 f8 03 00 00       	push   $0x3f8
c0024cda:	e8 98 fb ff ff       	call   c0024877 <outb>
c0024cdf:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024ce2:	83 ec 0c             	sub    $0xc,%esp
c0024ce5:	68 e0 50 03 c0       	push   $0xc00350e0
c0024cea:	e8 4b 18 00 00       	call   c002653a <intq_empty>
c0024cef:	83 c4 10             	add    $0x10,%esp
c0024cf2:	83 f0 01             	xor    $0x1,%eax
c0024cf5:	84 c0                	test   %al,%al
c0024cf7:	74 1a                	je     c0024d13 <serial_interrupt+0xae>
c0024cf9:	83 ec 0c             	sub    $0xc,%esp
c0024cfc:	68 fd 03 00 00       	push   $0x3fd
c0024d01:	e8 56 fb ff ff       	call   c002485c <inb>
c0024d06:	83 c4 10             	add    $0x10,%esp
c0024d09:	0f b6 c0             	movzbl %al,%eax
c0024d0c:	83 e0 20             	and    $0x20,%eax
c0024d0f:	85 c0                	test   %eax,%eax
c0024d11:	75 ab                	jne    c0024cbe <serial_interrupt+0x59>

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c0024d13:	e8 6d fe ff ff       	call   c0024b85 <write_ier>
}
c0024d18:	90                   	nop
c0024d19:	c9                   	leave  
c0024d1a:	c3                   	ret    

c0024d1b <block_type_name>:

/* Returns a human-readable name for the given block device
   TYPE. */
const char *
block_type_name (enum block_type type)
{
c0024d1b:	55                   	push   %ebp
c0024d1c:	89 e5                	mov    %esp,%ebp
c0024d1e:	83 ec 08             	sub    $0x8,%esp
      "swap",
      "raw",
      "foreign",
    };

  ASSERT (type < BLOCK_CNT);
c0024d21:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
c0024d25:	76 1e                	jbe    c0024d45 <block_type_name+0x2a>
c0024d27:	83 ec 0c             	sub    $0xc,%esp
c0024d2a:	68 64 f8 02 c0       	push   $0xc002f864
c0024d2f:	68 75 f8 02 c0       	push   $0xc002f875
c0024d34:	68 7c f9 02 c0       	push   $0xc002f97c
c0024d39:	6a 2f                	push   $0x2f
c0024d3b:	68 8c f8 02 c0       	push   $0xc002f88c
c0024d40:	e8 d9 47 00 00       	call   c002951e <debug_panic>
  return block_type_names[type];
c0024d45:	8b 45 08             	mov    0x8(%ebp),%eax
c0024d48:	8b 04 85 1c 34 03 c0 	mov    -0x3ffccbe4(,%eax,4),%eax
}
c0024d4f:	c9                   	leave  
c0024d50:	c3                   	ret    

c0024d51 <block_get_role>:

/* Returns the block device fulfilling the given ROLE, or a null
   pointer if no block device has been assigned that role. */
struct block *
block_get_role (enum block_type role)
{
c0024d51:	55                   	push   %ebp
c0024d52:	89 e5                	mov    %esp,%ebp
c0024d54:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c0024d57:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c0024d5b:	76 1e                	jbe    c0024d7b <block_get_role+0x2a>
c0024d5d:	83 ec 0c             	sub    $0xc,%esp
c0024d60:	68 a2 f8 02 c0       	push   $0xc002f8a2
c0024d65:	68 75 f8 02 c0       	push   $0xc002f875
c0024d6a:	68 b4 f9 02 c0       	push   $0xc002f9b4
c0024d6f:	6a 38                	push   $0x38
c0024d71:	68 8c f8 02 c0       	push   $0xc002f88c
c0024d76:	e8 a3 47 00 00       	call   c002951e <debug_panic>
  return block_by_role[role];
c0024d7b:	8b 45 08             	mov    0x8(%ebp),%eax
c0024d7e:	8b 04 85 48 51 03 c0 	mov    -0x3ffcaeb8(,%eax,4),%eax
}
c0024d85:	c9                   	leave  
c0024d86:	c3                   	ret    

c0024d87 <block_set_role>:

/* Assigns BLOCK the given ROLE. */
void
block_set_role (enum block_type role, struct block *block)
{
c0024d87:	55                   	push   %ebp
c0024d88:	89 e5                	mov    %esp,%ebp
c0024d8a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c0024d8d:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c0024d91:	76 1e                	jbe    c0024db1 <block_set_role+0x2a>
c0024d93:	83 ec 0c             	sub    $0xc,%esp
c0024d96:	68 a2 f8 02 c0       	push   $0xc002f8a2
c0024d9b:	68 75 f8 02 c0       	push   $0xc002f875
c0024da0:	68 c4 f9 02 c0       	push   $0xc002f9c4
c0024da5:	6a 40                	push   $0x40
c0024da7:	68 8c f8 02 c0       	push   $0xc002f88c
c0024dac:	e8 6d 47 00 00       	call   c002951e <debug_panic>
  block_by_role[role] = block;
c0024db1:	8b 45 08             	mov    0x8(%ebp),%eax
c0024db4:	8b 55 0c             	mov    0xc(%ebp),%edx
c0024db7:	89 14 85 48 51 03 c0 	mov    %edx,-0x3ffcaeb8(,%eax,4)
}
c0024dbe:	90                   	nop
c0024dbf:	c9                   	leave  
c0024dc0:	c3                   	ret    

c0024dc1 <block_first>:

/* Returns the first block device in kernel probe order, or a
   null pointer if no block devices are registered. */
struct block *
block_first (void)
{
c0024dc1:	55                   	push   %ebp
c0024dc2:	89 e5                	mov    %esp,%ebp
c0024dc4:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_begin (&all_blocks));
c0024dc7:	83 ec 0c             	sub    $0xc,%esp
c0024dca:	68 0c 34 03 c0       	push   $0xc003340c
c0024dcf:	e8 16 4a 00 00       	call   c00297ea <list_begin>
c0024dd4:	83 c4 10             	add    $0x10,%esp
c0024dd7:	83 ec 0c             	sub    $0xc,%esp
c0024dda:	50                   	push   %eax
c0024ddb:	e8 6b 03 00 00       	call   c002514b <list_elem_to_block>
c0024de0:	83 c4 10             	add    $0x10,%esp
}
c0024de3:	c9                   	leave  
c0024de4:	c3                   	ret    

c0024de5 <block_next>:

/* Returns the block device following BLOCK in kernel probe
   order, or a null pointer if BLOCK is the last block device. */
struct block *
block_next (struct block *block)
{
c0024de5:	55                   	push   %ebp
c0024de6:	89 e5                	mov    %esp,%ebp
c0024de8:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_next (&block->list_elem));
c0024deb:	8b 45 08             	mov    0x8(%ebp),%eax
c0024dee:	83 ec 0c             	sub    $0xc,%esp
c0024df1:	50                   	push   %eax
c0024df2:	e8 25 4a 00 00       	call   c002981c <list_next>
c0024df7:	83 c4 10             	add    $0x10,%esp
c0024dfa:	83 ec 0c             	sub    $0xc,%esp
c0024dfd:	50                   	push   %eax
c0024dfe:	e8 48 03 00 00       	call   c002514b <list_elem_to_block>
c0024e03:	83 c4 10             	add    $0x10,%esp
}
c0024e06:	c9                   	leave  
c0024e07:	c3                   	ret    

c0024e08 <block_get_by_name>:

/* Returns the block device with the given NAME, or a null
   pointer if no block device has that name. */
struct block *
block_get_by_name (const char *name)
{
c0024e08:	55                   	push   %ebp
c0024e09:	89 e5                	mov    %esp,%ebp
c0024e0b:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0024e0e:	83 ec 0c             	sub    $0xc,%esp
c0024e11:	68 0c 34 03 c0       	push   $0xc003340c
c0024e16:	e8 cf 49 00 00       	call   c00297ea <list_begin>
c0024e1b:	83 c4 10             	add    $0x10,%esp
c0024e1e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0024e21:	eb 3b                	jmp    c0024e5e <block_get_by_name+0x56>
       e = list_next (e))
    {
      struct block *block = list_entry (e, struct block, list_elem);
c0024e23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024e26:	83 c0 04             	add    $0x4,%eax
c0024e29:	83 e8 04             	sub    $0x4,%eax
c0024e2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!strcmp (name, block->name))
c0024e2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024e32:	83 c0 08             	add    $0x8,%eax
c0024e35:	83 ec 08             	sub    $0x8,%esp
c0024e38:	50                   	push   %eax
c0024e39:	ff 75 08             	push   0x8(%ebp)
c0024e3c:	e8 2c 37 00 00       	call   c002856d <strcmp>
c0024e41:	83 c4 10             	add    $0x10,%esp
c0024e44:	85 c0                	test   %eax,%eax
c0024e46:	75 05                	jne    c0024e4d <block_get_by_name+0x45>
        return block;
c0024e48:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024e4b:	eb 2b                	jmp    c0024e78 <block_get_by_name+0x70>
       e = list_next (e))
c0024e4d:	83 ec 0c             	sub    $0xc,%esp
c0024e50:	ff 75 f4             	push   -0xc(%ebp)
c0024e53:	e8 c4 49 00 00       	call   c002981c <list_next>
c0024e58:	83 c4 10             	add    $0x10,%esp
c0024e5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0024e5e:	83 ec 0c             	sub    $0xc,%esp
c0024e61:	68 0c 34 03 c0       	push   $0xc003340c
c0024e66:	e8 fb 49 00 00       	call   c0029866 <list_end>
c0024e6b:	83 c4 10             	add    $0x10,%esp
c0024e6e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0024e71:	75 b0                	jne    c0024e23 <block_get_by_name+0x1b>
    }

  return NULL;
c0024e73:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0024e78:	c9                   	leave  
c0024e79:	c3                   	ret    

c0024e7a <check_sector>:

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
c0024e7a:	55                   	push   %ebp
c0024e7b:	89 e5                	mov    %esp,%ebp
c0024e7d:	53                   	push   %ebx
c0024e7e:	83 ec 04             	sub    $0x4,%esp
  if (sector >= block->size)
c0024e81:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e84:	8b 40 1c             	mov    0x1c(%eax),%eax
c0024e87:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0024e8a:	72 32                	jb     c0024ebe <check_sector+0x44>
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c0024e8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e8f:	8b 58 1c             	mov    0x1c(%eax),%ebx
c0024e92:	83 ec 0c             	sub    $0xc,%esp
c0024e95:	ff 75 08             	push   0x8(%ebp)
c0024e98:	e8 fd 00 00 00       	call   c0024f9a <block_name>
c0024e9d:	83 c4 10             	add    $0x10,%esp
c0024ea0:	83 ec 04             	sub    $0x4,%esp
c0024ea3:	53                   	push   %ebx
c0024ea4:	ff 75 0c             	push   0xc(%ebp)
c0024ea7:	50                   	push   %eax
c0024ea8:	68 b8 f8 02 c0       	push   $0xc002f8b8
c0024ead:	68 d4 f9 02 c0       	push   $0xc002f9d4
c0024eb2:	6a 6f                	push   $0x6f
c0024eb4:	68 8c f8 02 c0       	push   $0xc002f88c
c0024eb9:	e8 60 46 00 00       	call   c002951e <debug_panic>
             "size=%"PRDSNu")\n", block_name (block), sector, block->size);
    }
}
c0024ebe:	90                   	nop
c0024ebf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024ec2:	c9                   	leave  
c0024ec3:	c3                   	ret    

c0024ec4 <block_read>:
   have room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_read (struct block *block, block_sector_t sector, void *buffer)
{
c0024ec4:	55                   	push   %ebp
c0024ec5:	89 e5                	mov    %esp,%ebp
c0024ec7:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c0024eca:	83 ec 08             	sub    $0x8,%esp
c0024ecd:	ff 75 0c             	push   0xc(%ebp)
c0024ed0:	ff 75 08             	push   0x8(%ebp)
c0024ed3:	e8 a2 ff ff ff       	call   c0024e7a <check_sector>
c0024ed8:	83 c4 10             	add    $0x10,%esp
  block->ops->read (block->aux, sector, buffer);
c0024edb:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ede:	8b 40 20             	mov    0x20(%eax),%eax
c0024ee1:	8b 00                	mov    (%eax),%eax
c0024ee3:	8b 55 08             	mov    0x8(%ebp),%edx
c0024ee6:	8b 52 24             	mov    0x24(%edx),%edx
c0024ee9:	83 ec 04             	sub    $0x4,%esp
c0024eec:	ff 75 10             	push   0x10(%ebp)
c0024eef:	ff 75 0c             	push   0xc(%ebp)
c0024ef2:	52                   	push   %edx
c0024ef3:	ff d0                	call   *%eax
c0024ef5:	83 c4 10             	add    $0x10,%esp
  block->read_cnt++;
c0024ef8:	8b 45 08             	mov    0x8(%ebp),%eax
c0024efb:	8b 50 2c             	mov    0x2c(%eax),%edx
c0024efe:	8b 40 28             	mov    0x28(%eax),%eax
c0024f01:	83 c0 01             	add    $0x1,%eax
c0024f04:	83 d2 00             	adc    $0x0,%edx
c0024f07:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0024f0a:	89 41 28             	mov    %eax,0x28(%ecx)
c0024f0d:	89 51 2c             	mov    %edx,0x2c(%ecx)
}
c0024f10:	90                   	nop
c0024f11:	c9                   	leave  
c0024f12:	c3                   	ret    

c0024f13 <block_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_write (struct block *block, block_sector_t sector, const void *buffer)
{
c0024f13:	55                   	push   %ebp
c0024f14:	89 e5                	mov    %esp,%ebp
c0024f16:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c0024f19:	83 ec 08             	sub    $0x8,%esp
c0024f1c:	ff 75 0c             	push   0xc(%ebp)
c0024f1f:	ff 75 08             	push   0x8(%ebp)
c0024f22:	e8 53 ff ff ff       	call   c0024e7a <check_sector>
c0024f27:	83 c4 10             	add    $0x10,%esp
  ASSERT (block->type != BLOCK_FOREIGN);
c0024f2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f2d:	8b 40 18             	mov    0x18(%eax),%eax
c0024f30:	83 f8 05             	cmp    $0x5,%eax
c0024f33:	75 21                	jne    c0024f56 <block_write+0x43>
c0024f35:	83 ec 0c             	sub    $0xc,%esp
c0024f38:	68 eb f8 02 c0       	push   $0xc002f8eb
c0024f3d:	68 75 f8 02 c0       	push   $0xc002f875
c0024f42:	68 e4 f9 02 c0       	push   $0xc002f9e4
c0024f47:	68 89 00 00 00       	push   $0x89
c0024f4c:	68 8c f8 02 c0       	push   $0xc002f88c
c0024f51:	e8 c8 45 00 00       	call   c002951e <debug_panic>
  block->ops->write (block->aux, sector, buffer);
c0024f56:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f59:	8b 40 20             	mov    0x20(%eax),%eax
c0024f5c:	8b 40 04             	mov    0x4(%eax),%eax
c0024f5f:	8b 55 08             	mov    0x8(%ebp),%edx
c0024f62:	8b 52 24             	mov    0x24(%edx),%edx
c0024f65:	83 ec 04             	sub    $0x4,%esp
c0024f68:	ff 75 10             	push   0x10(%ebp)
c0024f6b:	ff 75 0c             	push   0xc(%ebp)
c0024f6e:	52                   	push   %edx
c0024f6f:	ff d0                	call   *%eax
c0024f71:	83 c4 10             	add    $0x10,%esp
  block->write_cnt++;
c0024f74:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f77:	8b 50 34             	mov    0x34(%eax),%edx
c0024f7a:	8b 40 30             	mov    0x30(%eax),%eax
c0024f7d:	83 c0 01             	add    $0x1,%eax
c0024f80:	83 d2 00             	adc    $0x0,%edx
c0024f83:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0024f86:	89 41 30             	mov    %eax,0x30(%ecx)
c0024f89:	89 51 34             	mov    %edx,0x34(%ecx)
}
c0024f8c:	90                   	nop
c0024f8d:	c9                   	leave  
c0024f8e:	c3                   	ret    

c0024f8f <block_size>:

/* Returns the number of sectors in BLOCK. */
block_sector_t
block_size (struct block *block)
{
c0024f8f:	55                   	push   %ebp
c0024f90:	89 e5                	mov    %esp,%ebp
  return block->size;
c0024f92:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f95:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0024f98:	5d                   	pop    %ebp
c0024f99:	c3                   	ret    

c0024f9a <block_name>:

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
c0024f9a:	55                   	push   %ebp
c0024f9b:	89 e5                	mov    %esp,%ebp
  return block->name;
c0024f9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0024fa0:	83 c0 08             	add    $0x8,%eax
}
c0024fa3:	5d                   	pop    %ebp
c0024fa4:	c3                   	ret    

c0024fa5 <block_type>:

/* Returns BLOCK's type. */
enum block_type
block_type (struct block *block)
{
c0024fa5:	55                   	push   %ebp
c0024fa6:	89 e5                	mov    %esp,%ebp
  return block->type;
c0024fa8:	8b 45 08             	mov    0x8(%ebp),%eax
c0024fab:	8b 40 18             	mov    0x18(%eax),%eax
}
c0024fae:	5d                   	pop    %ebp
c0024faf:	c3                   	ret    

c0024fb0 <block_print_stats>:

/* Prints statistics for each block device used for a Pintos role. */
void
block_print_stats (void)
{
c0024fb0:	55                   	push   %ebp
c0024fb1:	89 e5                	mov    %esp,%ebp
c0024fb3:	57                   	push   %edi
c0024fb4:	56                   	push   %esi
c0024fb5:	83 ec 20             	sub    $0x20,%esp
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0024fb8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0024fbf:	eb 60                	jmp    c0025021 <block_print_stats+0x71>
    {
      struct block *block = block_by_role[i];
c0024fc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024fc4:	8b 04 85 48 51 03 c0 	mov    -0x3ffcaeb8(,%eax,4),%eax
c0024fcb:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (block != NULL)
c0024fce:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0024fd2:	74 4a                	je     c002501e <block_print_stats+0x6e>
        {
          printf ("%s (%s): %llu reads, %llu writes\n",
c0024fd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024fd7:	8b 50 34             	mov    0x34(%eax),%edx
c0024fda:	8b 40 30             	mov    0x30(%eax),%eax
c0024fdd:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0024fe0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0024fe3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024fe6:	8b 70 28             	mov    0x28(%eax),%esi
c0024fe9:	8b 78 2c             	mov    0x2c(%eax),%edi
c0024fec:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024fef:	8b 40 18             	mov    0x18(%eax),%eax
c0024ff2:	83 ec 0c             	sub    $0xc,%esp
c0024ff5:	50                   	push   %eax
c0024ff6:	e8 20 fd ff ff       	call   c0024d1b <block_type_name>
c0024ffb:	83 c4 10             	add    $0x10,%esp
                  block->name, block_type_name (block->type),
c0024ffe:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025001:	83 c2 08             	add    $0x8,%edx
          printf ("%s (%s): %llu reads, %llu writes\n",
c0025004:	83 ec 04             	sub    $0x4,%esp
c0025007:	ff 75 e4             	push   -0x1c(%ebp)
c002500a:	ff 75 e0             	push   -0x20(%ebp)
c002500d:	57                   	push   %edi
c002500e:	56                   	push   %esi
c002500f:	50                   	push   %eax
c0025010:	52                   	push   %edx
c0025011:	68 08 f9 02 c0       	push   $0xc002f908
c0025016:	e8 61 21 00 00       	call   c002717c <printf>
c002501b:	83 c4 20             	add    $0x20,%esp
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c002501e:	ff 45 f4             	incl   -0xc(%ebp)
c0025021:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c0025025:	7e 9a                	jle    c0024fc1 <block_print_stats+0x11>
                  block->read_cnt, block->write_cnt);
        }
    }
}
c0025027:	90                   	nop
c0025028:	90                   	nop
c0025029:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002502c:	5e                   	pop    %esi
c002502d:	5f                   	pop    %edi
c002502e:	5d                   	pop    %ebp
c002502f:	c3                   	ret    

c0025030 <block_register>:
   will be passed AUX in each function call. */
struct block *
block_register (const char *name, enum block_type type,
                const char *extra_info, block_sector_t size,
                const struct block_operations *ops, void *aux)
{
c0025030:	55                   	push   %ebp
c0025031:	89 e5                	mov    %esp,%ebp
c0025033:	83 ec 18             	sub    $0x18,%esp
  struct block *block = malloc (sizeof *block);
c0025036:	83 ec 0c             	sub    $0xc,%esp
c0025039:	6a 38                	push   $0x38
c002503b:	e8 23 e4 ff ff       	call   c0023463 <malloc>
c0025040:	83 c4 10             	add    $0x10,%esp
c0025043:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (block == NULL)
c0025046:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002504a:	75 19                	jne    c0025065 <block_register+0x35>
    PANIC ("Failed to allocate memory for block device descriptor");
c002504c:	68 2c f9 02 c0       	push   $0xc002f92c
c0025051:	68 f0 f9 02 c0       	push   $0xc002f9f0
c0025056:	68 c1 00 00 00       	push   $0xc1
c002505b:	68 8c f8 02 c0       	push   $0xc002f88c
c0025060:	e8 b9 44 00 00       	call   c002951e <debug_panic>

  list_push_back (&all_blocks, &block->list_elem);
c0025065:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025068:	83 ec 08             	sub    $0x8,%esp
c002506b:	50                   	push   %eax
c002506c:	68 0c 34 03 c0       	push   $0xc003340c
c0025071:	e8 ff 4a 00 00       	call   c0029b75 <list_push_back>
c0025076:	83 c4 10             	add    $0x10,%esp
  strlcpy (block->name, name, sizeof block->name);
c0025079:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002507c:	83 c0 08             	add    $0x8,%eax
c002507f:	83 ec 04             	sub    $0x4,%esp
c0025082:	6a 10                	push   $0x10
c0025084:	ff 75 08             	push   0x8(%ebp)
c0025087:	50                   	push   %eax
c0025088:	e8 8c 39 00 00       	call   c0028a19 <strlcpy>
c002508d:	83 c4 10             	add    $0x10,%esp
  block->type = type;
c0025090:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025093:	8b 55 0c             	mov    0xc(%ebp),%edx
c0025096:	89 50 18             	mov    %edx,0x18(%eax)
  block->size = size;
c0025099:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002509c:	8b 55 14             	mov    0x14(%ebp),%edx
c002509f:	89 50 1c             	mov    %edx,0x1c(%eax)
  block->ops = ops;
c00250a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250a5:	8b 55 18             	mov    0x18(%ebp),%edx
c00250a8:	89 50 20             	mov    %edx,0x20(%eax)
  block->aux = aux;
c00250ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250ae:	8b 55 1c             	mov    0x1c(%ebp),%edx
c00250b1:	89 50 24             	mov    %edx,0x24(%eax)
  block->read_cnt = 0;
c00250b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250b7:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c00250be:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  block->write_cnt = 0;
c00250c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250c8:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
c00250cf:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c00250d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250d9:	8b 40 1c             	mov    0x1c(%eax),%eax
c00250dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00250df:	83 c2 08             	add    $0x8,%edx
c00250e2:	83 ec 04             	sub    $0x4,%esp
c00250e5:	50                   	push   %eax
c00250e6:	52                   	push   %edx
c00250e7:	68 62 f9 02 c0       	push   $0xc002f962
c00250ec:	e8 8b 20 00 00       	call   c002717c <printf>
c00250f1:	83 c4 10             	add    $0x10,%esp
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c00250f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250f7:	8b 40 1c             	mov    0x1c(%eax),%eax
c00250fa:	ba 00 00 00 00       	mov    $0x0,%edx
c00250ff:	0f a4 c2 09          	shld   $0x9,%eax,%edx
c0025103:	c1 e0 09             	shl    $0x9,%eax
c0025106:	83 ec 08             	sub    $0x8,%esp
c0025109:	52                   	push   %edx
c002510a:	50                   	push   %eax
c002510b:	e8 7c 2d 00 00       	call   c0027e8c <print_human_readable_size>
c0025110:	83 c4 10             	add    $0x10,%esp
  printf (")");
c0025113:	83 ec 0c             	sub    $0xc,%esp
c0025116:	6a 29                	push   $0x29
c0025118:	e8 4b 66 00 00       	call   c002b768 <putchar>
c002511d:	83 c4 10             	add    $0x10,%esp
  if (extra_info != NULL)
c0025120:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0025124:	74 13                	je     c0025139 <block_register+0x109>
    printf (", %s", extra_info);
c0025126:	83 ec 08             	sub    $0x8,%esp
c0025129:	ff 75 10             	push   0x10(%ebp)
c002512c:	68 74 f9 02 c0       	push   $0xc002f974
c0025131:	e8 46 20 00 00       	call   c002717c <printf>
c0025136:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c0025139:	83 ec 0c             	sub    $0xc,%esp
c002513c:	6a 0a                	push   $0xa
c002513e:	e8 25 66 00 00       	call   c002b768 <putchar>
c0025143:	83 c4 10             	add    $0x10,%esp

  return block;
c0025146:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0025149:	c9                   	leave  
c002514a:	c3                   	ret    

c002514b <list_elem_to_block>:

/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
c002514b:	55                   	push   %ebp
c002514c:	89 e5                	mov    %esp,%ebp
c002514e:	83 ec 08             	sub    $0x8,%esp
  return (list_elem != list_end (&all_blocks)
c0025151:	83 ec 0c             	sub    $0xc,%esp
c0025154:	68 0c 34 03 c0       	push   $0xc003340c
c0025159:	e8 08 47 00 00       	call   c0029866 <list_end>
c002515e:	83 c4 10             	add    $0x10,%esp
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c0025161:	39 45 08             	cmp    %eax,0x8(%ebp)
c0025164:	74 0b                	je     c0025171 <list_elem_to_block+0x26>
          ? list_entry (list_elem, struct block, list_elem)
c0025166:	8b 45 08             	mov    0x8(%ebp),%eax
c0025169:	83 c0 04             	add    $0x4,%eax
          : NULL);
c002516c:	83 e8 04             	sub    $0x4,%eax
c002516f:	eb 05                	jmp    c0025176 <list_elem_to_block+0x2b>
c0025171:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0025176:	c9                   	leave  
c0025177:	c3                   	ret    

c0025178 <partition_scan>:
static const char *partition_type_name (uint8_t);

/* Scans BLOCK for partitions of interest to Pintos. */
void
partition_scan (struct block *block)
{
c0025178:	55                   	push   %ebp
c0025179:	89 e5                	mov    %esp,%ebp
c002517b:	83 ec 18             	sub    $0x18,%esp
  int part_nr = 0;
c002517e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  read_partition_table (block, 0, 0, &part_nr);
c0025185:	8d 45 f4             	lea    -0xc(%ebp),%eax
c0025188:	50                   	push   %eax
c0025189:	6a 00                	push   $0x0
c002518b:	6a 00                	push   $0x0
c002518d:	ff 75 08             	push   0x8(%ebp)
c0025190:	e8 2c 00 00 00       	call   c00251c1 <read_partition_table>
c0025195:	83 c4 10             	add    $0x10,%esp
  if (part_nr == 0)
c0025198:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002519b:	85 c0                	test   %eax,%eax
c002519d:	75 1f                	jne    c00251be <partition_scan+0x46>
    printf ("%s: Device contains no partitions\n", block_name (block));
c002519f:	83 ec 0c             	sub    $0xc,%esp
c00251a2:	ff 75 08             	push   0x8(%ebp)
c00251a5:	e8 f0 fd ff ff       	call   c0024f9a <block_name>
c00251aa:	83 c4 10             	add    $0x10,%esp
c00251ad:	83 ec 08             	sub    $0x8,%esp
c00251b0:	50                   	push   %eax
c00251b1:	68 00 fa 02 c0       	push   $0xc002fa00
c00251b6:	e8 c1 1f 00 00       	call   c002717c <printf>
c00251bb:	83 c4 10             	add    $0x10,%esp
}
c00251be:	90                   	nop
c00251bf:	c9                   	leave  
c00251c0:	c3                   	ret    

c00251c1 <read_partition_table>:
   partitions are found. */
static void
read_partition_table (struct block *block, block_sector_t sector,
                      block_sector_t primary_extended_sector,
                      int *part_nr)
{
c00251c1:	55                   	push   %ebp
c00251c2:	89 e5                	mov    %esp,%ebp
c00251c4:	53                   	push   %ebx
c00251c5:	83 ec 14             	sub    $0x14,%esp

  struct partition_table *pt;
  size_t i;

  /* Check SECTOR validity. */
  if (sector >= block_size (block))
c00251c8:	83 ec 0c             	sub    $0xc,%esp
c00251cb:	ff 75 08             	push   0x8(%ebp)
c00251ce:	e8 bc fd ff ff       	call   c0024f8f <block_size>
c00251d3:	83 c4 10             	add    $0x10,%esp
c00251d6:	39 45 0c             	cmp    %eax,0xc(%ebp)
c00251d9:	72 27                	jb     c0025202 <read_partition_table+0x41>
    {
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c00251db:	83 ec 0c             	sub    $0xc,%esp
c00251de:	ff 75 08             	push   0x8(%ebp)
c00251e1:	e8 b4 fd ff ff       	call   c0024f9a <block_name>
c00251e6:	83 c4 10             	add    $0x10,%esp
c00251e9:	83 ec 04             	sub    $0x4,%esp
c00251ec:	ff 75 0c             	push   0xc(%ebp)
c00251ef:	50                   	push   %eax
c00251f0:	68 24 fa 02 c0       	push   $0xc002fa24
c00251f5:	e8 82 1f 00 00       	call   c002717c <printf>
c00251fa:	83 c4 10             	add    $0x10,%esp
              block_name (block), sector);
      return;
c00251fd:	e9 d2 01 00 00       	jmp    c00253d4 <read_partition_table+0x213>
    }

  /* Read sector. */
  ASSERT (sizeof *pt == BLOCK_SECTOR_SIZE);
  pt = malloc (sizeof *pt);
c0025202:	83 ec 0c             	sub    $0xc,%esp
c0025205:	68 00 02 00 00       	push   $0x200
c002520a:	e8 54 e2 ff ff       	call   c0023463 <malloc>
c002520f:	83 c4 10             	add    $0x10,%esp
c0025212:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (pt == NULL)
c0025215:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0025219:	75 16                	jne    c0025231 <read_partition_table+0x70>
    PANIC ("Failed to allocate memory for partition table.");
c002521b:	68 5c fa 02 c0       	push   $0xc002fa5c
c0025220:	68 e4 fb 02 c0       	push   $0xc002fbe4
c0025225:	6a 5a                	push   $0x5a
c0025227:	68 8b fa 02 c0       	push   $0xc002fa8b
c002522c:	e8 ed 42 00 00       	call   c002951e <debug_panic>
  block_read (block, 0, pt);
c0025231:	83 ec 04             	sub    $0x4,%esp
c0025234:	ff 75 f0             	push   -0x10(%ebp)
c0025237:	6a 00                	push   $0x0
c0025239:	ff 75 08             	push   0x8(%ebp)
c002523c:	e8 83 fc ff ff       	call   c0024ec4 <block_read>
c0025241:	83 c4 10             	add    $0x10,%esp

  /* Check signature. */
  if (pt->signature != 0xaa55)
c0025244:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025247:	66 8b 80 fe 01 00 00 	mov    0x1fe(%eax),%ax
c002524e:	66 3d 55 aa          	cmp    $0xaa55,%ax
c0025252:	74 5c                	je     c00252b0 <read_partition_table+0xef>
    {
      if (primary_extended_sector == 0)
c0025254:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0025258:	75 21                	jne    c002527b <read_partition_table+0xba>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c002525a:	83 ec 0c             	sub    $0xc,%esp
c002525d:	ff 75 08             	push   0x8(%ebp)
c0025260:	e8 35 fd ff ff       	call   c0024f9a <block_name>
c0025265:	83 c4 10             	add    $0x10,%esp
c0025268:	83 ec 08             	sub    $0x8,%esp
c002526b:	50                   	push   %eax
c002526c:	68 a8 fa 02 c0       	push   $0xc002faa8
c0025271:	e8 06 1f 00 00       	call   c002717c <printf>
c0025276:	83 c4 10             	add    $0x10,%esp
c0025279:	eb 22                	jmp    c002529d <read_partition_table+0xdc>
      else
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c002527b:	83 ec 0c             	sub    $0xc,%esp
c002527e:	ff 75 08             	push   0x8(%ebp)
c0025281:	e8 14 fd ff ff       	call   c0024f9a <block_name>
c0025286:	83 c4 10             	add    $0x10,%esp
c0025289:	83 ec 04             	sub    $0x4,%esp
c002528c:	ff 75 0c             	push   0xc(%ebp)
c002528f:	50                   	push   %eax
c0025290:	68 d0 fa 02 c0       	push   $0xc002fad0
c0025295:	e8 e2 1e 00 00       	call   c002717c <printf>
c002529a:	83 c4 10             	add    $0x10,%esp
                block_name (block), sector);
      free (pt);
c002529d:	83 ec 0c             	sub    $0xc,%esp
c00252a0:	ff 75 f0             	push   -0x10(%ebp)
c00252a3:	e8 b7 e4 ff ff       	call   c002375f <free>
c00252a8:	83 c4 10             	add    $0x10,%esp
      return;
c00252ab:	e9 24 01 00 00       	jmp    c00253d4 <read_partition_table+0x213>
    }

  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c00252b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00252b7:	e9 00 01 00 00       	jmp    c00253bc <read_partition_table+0x1fb>
    {
      struct partition_table_entry *e = &pt->partitions[i];
c00252bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00252bf:	83 c0 1b             	add    $0x1b,%eax
c00252c2:	c1 e0 04             	shl    $0x4,%eax
c00252c5:	89 c2                	mov    %eax,%edx
c00252c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00252ca:	01 d0                	add    %edx,%eax
c00252cc:	83 c0 0e             	add    $0xe,%eax
c00252cf:	89 45 ec             	mov    %eax,-0x14(%ebp)

      if (e->size == 0 || e->type == 0)
c00252d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00252d5:	8b 40 0c             	mov    0xc(%eax),%eax
c00252d8:	85 c0                	test   %eax,%eax
c00252da:	0f 84 d9 00 00 00    	je     c00253b9 <read_partition_table+0x1f8>
c00252e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00252e3:	8a 40 04             	mov    0x4(%eax),%al
c00252e6:	84 c0                	test   %al,%al
c00252e8:	0f 84 cb 00 00 00    	je     c00253b9 <read_partition_table+0x1f8>
        {
          /* Ignore empty partition. */
        }
      else if (e->type == 0x05       /* Extended partition. */
c00252ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00252f1:	8a 40 04             	mov    0x4(%eax),%al
c00252f4:	3c 05                	cmp    $0x5,%al
c00252f6:	74 1e                	je     c0025316 <read_partition_table+0x155>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c00252f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00252fb:	8a 40 04             	mov    0x4(%eax),%al
c00252fe:	3c 0f                	cmp    $0xf,%al
c0025300:	74 14                	je     c0025316 <read_partition_table+0x155>
               || e->type == 0x85    /* Linux extended partition. */
c0025302:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025305:	8a 40 04             	mov    0x4(%eax),%al
c0025308:	3c 85                	cmp    $0x85,%al
c002530a:	74 0a                	je     c0025316 <read_partition_table+0x155>
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c002530c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002530f:	8a 40 04             	mov    0x4(%eax),%al
c0025312:	3c c5                	cmp    $0xc5,%al
c0025314:	75 65                	jne    c002537b <read_partition_table+0x1ba>
        {
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c0025316:	83 ec 0c             	sub    $0xc,%esp
c0025319:	ff 75 08             	push   0x8(%ebp)
c002531c:	e8 79 fc ff ff       	call   c0024f9a <block_name>
c0025321:	83 c4 10             	add    $0x10,%esp
c0025324:	83 ec 04             	sub    $0x4,%esp
c0025327:	ff 75 0c             	push   0xc(%ebp)
c002532a:	50                   	push   %eax
c002532b:	68 04 fb 02 c0       	push   $0xc002fb04
c0025330:	e8 47 1e 00 00       	call   c002717c <printf>
c0025335:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c0025338:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002533c:	75 1e                	jne    c002535c <read_partition_table+0x19b>
            read_partition_table (block, e->offset, e->offset, part_nr);
c002533e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025341:	8b 50 08             	mov    0x8(%eax),%edx
c0025344:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025347:	8b 40 08             	mov    0x8(%eax),%eax
c002534a:	ff 75 14             	push   0x14(%ebp)
c002534d:	52                   	push   %edx
c002534e:	50                   	push   %eax
c002534f:	ff 75 08             	push   0x8(%ebp)
c0025352:	e8 6a fe ff ff       	call   c00251c1 <read_partition_table>
c0025357:	83 c4 10             	add    $0x10,%esp
          if (sector == 0)
c002535a:	eb 5d                	jmp    c00253b9 <read_partition_table+0x1f8>
          else
            read_partition_table (block, e->offset + primary_extended_sector,
c002535c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002535f:	8b 50 08             	mov    0x8(%eax),%edx
c0025362:	8b 45 10             	mov    0x10(%ebp),%eax
c0025365:	01 d0                	add    %edx,%eax
c0025367:	ff 75 14             	push   0x14(%ebp)
c002536a:	ff 75 10             	push   0x10(%ebp)
c002536d:	50                   	push   %eax
c002536e:	ff 75 08             	push   0x8(%ebp)
c0025371:	e8 4b fe ff ff       	call   c00251c1 <read_partition_table>
c0025376:	83 c4 10             	add    $0x10,%esp
          if (sector == 0)
c0025379:	eb 3e                	jmp    c00253b9 <read_partition_table+0x1f8>
                                  primary_extended_sector, part_nr);
        }
      else
        {
          ++*part_nr;
c002537b:	8b 45 14             	mov    0x14(%ebp),%eax
c002537e:	8b 00                	mov    (%eax),%eax
c0025380:	8d 50 01             	lea    0x1(%eax),%edx
c0025383:	8b 45 14             	mov    0x14(%ebp),%eax
c0025386:	89 10                	mov    %edx,(%eax)

          found_partition (block, e->type, e->offset + sector,
c0025388:	8b 45 14             	mov    0x14(%ebp),%eax
c002538b:	8b 08                	mov    (%eax),%ecx
c002538d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025390:	8b 50 0c             	mov    0xc(%eax),%edx
c0025393:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025396:	8b 58 08             	mov    0x8(%eax),%ebx
c0025399:	8b 45 0c             	mov    0xc(%ebp),%eax
c002539c:	01 c3                	add    %eax,%ebx
c002539e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00253a1:	8a 40 04             	mov    0x4(%eax),%al
c00253a4:	0f b6 c0             	movzbl %al,%eax
c00253a7:	83 ec 0c             	sub    $0xc,%esp
c00253aa:	51                   	push   %ecx
c00253ab:	52                   	push   %edx
c00253ac:	53                   	push   %ebx
c00253ad:	50                   	push   %eax
c00253ae:	ff 75 08             	push   0x8(%ebp)
c00253b1:	e8 23 00 00 00       	call   c00253d9 <found_partition>
c00253b6:	83 c4 20             	add    $0x20,%esp
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c00253b9:	ff 45 f4             	incl   -0xc(%ebp)
c00253bc:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c00253c0:	0f 86 f6 fe ff ff    	jbe    c00252bc <read_partition_table+0xfb>
                           e->size, *part_nr);
        }
    }

  free (pt);
c00253c6:	83 ec 0c             	sub    $0xc,%esp
c00253c9:	ff 75 f0             	push   -0x10(%ebp)
c00253cc:	e8 8e e3 ff ff       	call   c002375f <free>
c00253d1:	83 c4 10             	add    $0x10,%esp
}
c00253d4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00253d7:	c9                   	leave  
c00253d8:	c3                   	ret    

c00253d9 <found_partition>:
   if so then add it to the proper element of partitions[]. */
static void
found_partition (struct block *block, uint8_t part_type,
                 block_sector_t start, block_sector_t size,
                 int part_nr)
{
c00253d9:	55                   	push   %ebp
c00253da:	89 e5                	mov    %esp,%ebp
c00253dc:	56                   	push   %esi
c00253dd:	53                   	push   %ebx
c00253de:	81 ec b0 00 00 00    	sub    $0xb0,%esp
c00253e4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00253e7:	88 85 54 ff ff ff    	mov    %al,-0xac(%ebp)
  if (start >= block_size (block))
c00253ed:	83 ec 0c             	sub    $0xc,%esp
c00253f0:	ff 75 08             	push   0x8(%ebp)
c00253f3:	e8 97 fb ff ff       	call   c0024f8f <block_size>
c00253f8:	83 c4 10             	add    $0x10,%esp
c00253fb:	39 45 10             	cmp    %eax,0x10(%ebp)
c00253fe:	72 27                	jb     c0025427 <found_partition+0x4e>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c0025400:	83 ec 0c             	sub    $0xc,%esp
c0025403:	ff 75 08             	push   0x8(%ebp)
c0025406:	e8 8f fb ff ff       	call   c0024f9a <block_name>
c002540b:	83 c4 10             	add    $0x10,%esp
c002540e:	ff 75 10             	push   0x10(%ebp)
c0025411:	ff 75 18             	push   0x18(%ebp)
c0025414:	50                   	push   %eax
c0025415:	68 2c fb 02 c0       	push   $0xc002fb2c
c002541a:	e8 5d 1d 00 00       	call   c002717c <printf>
c002541f:	83 c4 10             	add    $0x10,%esp
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
    }
}
c0025422:	e9 76 01 00 00       	jmp    c002559d <found_partition+0x1c4>
  else if (start + size < start || start + size > block_size (block))
c0025427:	8b 55 10             	mov    0x10(%ebp),%edx
c002542a:	8b 45 14             	mov    0x14(%ebp),%eax
c002542d:	01 d0                	add    %edx,%eax
c002542f:	39 45 10             	cmp    %eax,0x10(%ebp)
c0025432:	77 1b                	ja     c002544f <found_partition+0x76>
c0025434:	8b 55 10             	mov    0x10(%ebp),%edx
c0025437:	8b 45 14             	mov    0x14(%ebp),%eax
c002543a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c002543d:	83 ec 0c             	sub    $0xc,%esp
c0025440:	ff 75 08             	push   0x8(%ebp)
c0025443:	e8 47 fb ff ff       	call   c0024f8f <block_size>
c0025448:	83 c4 10             	add    $0x10,%esp
c002544b:	39 c3                	cmp    %eax,%ebx
c002544d:	76 42                	jbe    c0025491 <found_partition+0xb8>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c002544f:	83 ec 0c             	sub    $0xc,%esp
c0025452:	ff 75 08             	push   0x8(%ebp)
c0025455:	e8 35 fb ff ff       	call   c0024f8f <block_size>
c002545a:	83 c4 10             	add    $0x10,%esp
c002545d:	89 c3                	mov    %eax,%ebx
c002545f:	8b 55 10             	mov    0x10(%ebp),%edx
c0025462:	8b 45 14             	mov    0x14(%ebp),%eax
c0025465:	8d 34 02             	lea    (%edx,%eax,1),%esi
c0025468:	83 ec 0c             	sub    $0xc,%esp
c002546b:	ff 75 08             	push   0x8(%ebp)
c002546e:	e8 27 fb ff ff       	call   c0024f9a <block_name>
c0025473:	83 c4 10             	add    $0x10,%esp
c0025476:	83 ec 0c             	sub    $0xc,%esp
c0025479:	53                   	push   %ebx
c002547a:	56                   	push   %esi
c002547b:	ff 75 18             	push   0x18(%ebp)
c002547e:	50                   	push   %eax
c002547f:	68 64 fb 02 c0       	push   $0xc002fb64
c0025484:	e8 f3 1c 00 00       	call   c002717c <printf>
c0025489:	83 c4 20             	add    $0x20,%esp
}
c002548c:	e9 0c 01 00 00       	jmp    c002559d <found_partition+0x1c4>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0025491:	80 bd 54 ff ff ff 20 	cmpb   $0x20,-0xac(%ebp)
c0025498:	74 37                	je     c00254d1 <found_partition+0xf8>
c002549a:	80 bd 54 ff ff ff 21 	cmpb   $0x21,-0xac(%ebp)
c00254a1:	74 27                	je     c00254ca <found_partition+0xf1>
c00254a3:	80 bd 54 ff ff ff 22 	cmpb   $0x22,-0xac(%ebp)
c00254aa:	74 17                	je     c00254c3 <found_partition+0xea>
c00254ac:	80 bd 54 ff ff ff 23 	cmpb   $0x23,-0xac(%ebp)
c00254b3:	75 07                	jne    c00254bc <found_partition+0xe3>
c00254b5:	b8 03 00 00 00       	mov    $0x3,%eax
c00254ba:	eb 1a                	jmp    c00254d6 <found_partition+0xfd>
c00254bc:	b8 05 00 00 00       	mov    $0x5,%eax
c00254c1:	eb 13                	jmp    c00254d6 <found_partition+0xfd>
c00254c3:	b8 02 00 00 00       	mov    $0x2,%eax
c00254c8:	eb 0c                	jmp    c00254d6 <found_partition+0xfd>
c00254ca:	b8 01 00 00 00       	mov    $0x1,%eax
c00254cf:	eb 05                	jmp    c00254d6 <found_partition+0xfd>
c00254d1:	b8 00 00 00 00       	mov    $0x0,%eax
      enum block_type type = (part_type == 0x20 ? BLOCK_KERNEL
c00254d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
      p = malloc (sizeof *p);
c00254d9:	83 ec 0c             	sub    $0xc,%esp
c00254dc:	6a 08                	push   $0x8
c00254de:	e8 80 df ff ff       	call   c0023463 <malloc>
c00254e3:	83 c4 10             	add    $0x10,%esp
c00254e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (p == NULL)
c00254e9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00254ed:	75 19                	jne    c0025508 <found_partition+0x12f>
        PANIC ("Failed to allocate memory for partition descriptor");
c00254ef:	68 98 fb 02 c0       	push   $0xc002fb98
c00254f4:	68 fc fb 02 c0       	push   $0xc002fbfc
c00254f9:	68 b1 00 00 00       	push   $0xb1
c00254fe:	68 8b fa 02 c0       	push   $0xc002fa8b
c0025503:	e8 16 40 00 00       	call   c002951e <debug_panic>
      p->block = block;
c0025508:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002550b:	8b 55 08             	mov    0x8(%ebp),%edx
c002550e:	89 10                	mov    %edx,(%eax)
      p->start = start;
c0025510:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025513:	8b 55 10             	mov    0x10(%ebp),%edx
c0025516:	89 50 04             	mov    %edx,0x4(%eax)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0025519:	83 ec 0c             	sub    $0xc,%esp
c002551c:	ff 75 08             	push   0x8(%ebp)
c002551f:	e8 76 fa ff ff       	call   c0024f9a <block_name>
c0025524:	83 c4 10             	add    $0x10,%esp
c0025527:	83 ec 0c             	sub    $0xc,%esp
c002552a:	ff 75 18             	push   0x18(%ebp)
c002552d:	50                   	push   %eax
c002552e:	68 cb fb 02 c0       	push   $0xc002fbcb
c0025533:	6a 10                	push   $0x10
c0025535:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0025538:	50                   	push   %eax
c0025539:	e8 15 1c 00 00       	call   c0027153 <snprintf>
c002553e:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0025541:	0f b6 9d 54 ff ff ff 	movzbl -0xac(%ebp),%ebx
c0025548:	0f b6 85 54 ff ff ff 	movzbl -0xac(%ebp),%eax
c002554f:	83 ec 0c             	sub    $0xc,%esp
c0025552:	50                   	push   %eax
c0025553:	e8 4d 00 00 00       	call   c00255a5 <partition_type_name>
c0025558:	83 c4 10             	add    $0x10,%esp
c002555b:	83 ec 0c             	sub    $0xc,%esp
c002555e:	53                   	push   %ebx
c002555f:	50                   	push   %eax
c0025560:	68 d0 fb 02 c0       	push   $0xc002fbd0
c0025565:	68 80 00 00 00       	push   $0x80
c002556a:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c0025570:	50                   	push   %eax
c0025571:	e8 dd 1b 00 00       	call   c0027153 <snprintf>
c0025576:	83 c4 20             	add    $0x20,%esp
      block_register (name, type, extra_info, size, &partition_operations, p);
c0025579:	83 ec 08             	sub    $0x8,%esp
c002557c:	ff 75 f0             	push   -0x10(%ebp)
c002557f:	68 40 34 03 c0       	push   $0xc0033440
c0025584:	ff 75 14             	push   0x14(%ebp)
c0025587:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c002558d:	50                   	push   %eax
c002558e:	ff 75 f4             	push   -0xc(%ebp)
c0025591:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0025594:	50                   	push   %eax
c0025595:	e8 96 fa ff ff       	call   c0025030 <block_register>
c002559a:	83 c4 20             	add    $0x20,%esp
}
c002559d:	90                   	nop
c002559e:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00255a1:	5b                   	pop    %ebx
c00255a2:	5e                   	pop    %esi
c00255a3:	5d                   	pop    %ebp
c00255a4:	c3                   	ret    

c00255a5 <partition_type_name>:

/* Returns a human-readable name for the given partition TYPE. */
static const char *
partition_type_name (uint8_t type)
{
c00255a5:	55                   	push   %ebp
c00255a6:	89 e5                	mov    %esp,%ebp
c00255a8:	83 ec 04             	sub    $0x4,%esp
c00255ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00255ae:	88 45 fc             	mov    %al,-0x4(%ebp)
      [0xfd] = "Linux raid autodetect",
      [0xfe] = "LANstep",
      [0xff] = "BBT",
    };

  return type_names[type] != NULL ? type_names[type] : "Unknown";
c00255b1:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c00255b5:	8b 04 85 60 34 03 c0 	mov    -0x3ffccba0(,%eax,4),%eax
c00255bc:	85 c0                	test   %eax,%eax
c00255be:	74 0d                	je     c00255cd <partition_type_name+0x28>
c00255c0:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c00255c4:	8b 04 85 60 34 03 c0 	mov    -0x3ffccba0(,%eax,4),%eax
c00255cb:	eb 05                	jmp    c00255d2 <partition_type_name+0x2d>
c00255cd:	b8 da fb 02 c0       	mov    $0xc002fbda,%eax
}
c00255d2:	c9                   	leave  
c00255d3:	c3                   	ret    

c00255d4 <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c00255d4:	55                   	push   %ebp
c00255d5:	89 e5                	mov    %esp,%ebp
c00255d7:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c00255da:	8b 45 08             	mov    0x8(%ebp),%eax
c00255dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_read (p->block, p->start + sector, buffer);
c00255e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00255e3:	8b 50 04             	mov    0x4(%eax),%edx
c00255e6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00255e9:	01 c2                	add    %eax,%edx
c00255eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00255ee:	8b 00                	mov    (%eax),%eax
c00255f0:	83 ec 04             	sub    $0x4,%esp
c00255f3:	ff 75 10             	push   0x10(%ebp)
c00255f6:	52                   	push   %edx
c00255f7:	50                   	push   %eax
c00255f8:	e8 c7 f8 ff ff       	call   c0024ec4 <block_read>
c00255fd:	83 c4 10             	add    $0x10,%esp
}
c0025600:	90                   	nop
c0025601:	c9                   	leave  
c0025602:	c3                   	ret    

c0025603 <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c0025603:	55                   	push   %ebp
c0025604:	89 e5                	mov    %esp,%ebp
c0025606:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c0025609:	8b 45 08             	mov    0x8(%ebp),%eax
c002560c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_write (p->block, p->start + sector, buffer);
c002560f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025612:	8b 50 04             	mov    0x4(%eax),%edx
c0025615:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025618:	01 c2                	add    %eax,%edx
c002561a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002561d:	8b 00                	mov    (%eax),%eax
c002561f:	83 ec 04             	sub    $0x4,%esp
c0025622:	ff 75 10             	push   0x10(%ebp)
c0025625:	52                   	push   %edx
c0025626:	50                   	push   %eax
c0025627:	e8 e7 f8 ff ff       	call   c0024f13 <block_write>
c002562c:	83 c4 10             	add    $0x10,%esp
}
c002562f:	90                   	nop
c0025630:	c9                   	leave  
c0025631:	c3                   	ret    

c0025632 <isspace>:
static inline int isspace (int c) {
c0025632:	55                   	push   %ebp
c0025633:	89 e5                	mov    %esp,%ebp
          || c == '\r' || c == '\t' || c == '\v');
c0025635:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0025639:	74 1e                	je     c0025659 <isspace+0x27>
  return (c == ' ' || c == '\f' || c == '\n'
c002563b:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c002563f:	74 18                	je     c0025659 <isspace+0x27>
c0025641:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c0025645:	74 12                	je     c0025659 <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c0025647:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c002564b:	74 0c                	je     c0025659 <isspace+0x27>
c002564d:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0025651:	74 06                	je     c0025659 <isspace+0x27>
c0025653:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0025657:	75 07                	jne    c0025660 <isspace+0x2e>
c0025659:	b8 01 00 00 00       	mov    $0x1,%eax
c002565e:	eb 05                	jmp    c0025665 <isspace+0x33>
c0025660:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0025665:	5d                   	pop    %ebp
c0025666:	c3                   	ret    

c0025667 <inb>:
{
c0025667:	55                   	push   %ebp
c0025668:	89 e5                	mov    %esp,%ebp
c002566a:	83 ec 14             	sub    $0x14,%esp
c002566d:	8b 45 08             	mov    0x8(%ebp),%eax
c0025670:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025674:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025677:	89 c2                	mov    %eax,%edx
c0025679:	ec                   	in     (%dx),%al
c002567a:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c002567d:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0025680:	c9                   	leave  
c0025681:	c3                   	ret    

c0025682 <insw>:
{
c0025682:	55                   	push   %ebp
c0025683:	89 e5                	mov    %esp,%ebp
c0025685:	57                   	push   %edi
c0025686:	53                   	push   %ebx
c0025687:	83 ec 04             	sub    $0x4,%esp
c002568a:	8b 45 08             	mov    0x8(%ebp),%eax
c002568d:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c0025691:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025694:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0025697:	8b 45 10             	mov    0x10(%ebp),%eax
c002569a:	89 cb                	mov    %ecx,%ebx
c002569c:	89 df                	mov    %ebx,%edi
c002569e:	89 c1                	mov    %eax,%ecx
c00256a0:	66 f3 6d             	rep insw (%dx),%es:(%edi)
c00256a3:	89 c8                	mov    %ecx,%eax
c00256a5:	89 fb                	mov    %edi,%ebx
c00256a7:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c00256aa:	89 45 10             	mov    %eax,0x10(%ebp)
}
c00256ad:	90                   	nop
c00256ae:	83 c4 04             	add    $0x4,%esp
c00256b1:	5b                   	pop    %ebx
c00256b2:	5f                   	pop    %edi
c00256b3:	5d                   	pop    %ebp
c00256b4:	c3                   	ret    

c00256b5 <outb>:
{
c00256b5:	55                   	push   %ebp
c00256b6:	89 e5                	mov    %esp,%ebp
c00256b8:	83 ec 08             	sub    $0x8,%esp
c00256bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00256be:	8b 55 0c             	mov    0xc(%ebp),%edx
c00256c1:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c00256c5:	88 d0                	mov    %dl,%al
c00256c7:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00256ca:	8a 45 f8             	mov    -0x8(%ebp),%al
c00256cd:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00256d0:	ee                   	out    %al,(%dx)
}
c00256d1:	90                   	nop
c00256d2:	c9                   	leave  
c00256d3:	c3                   	ret    

c00256d4 <outsw>:

/* Writes to PORT each 16-bit unit (halfword) of data in the
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
c00256d4:	55                   	push   %ebp
c00256d5:	89 e5                	mov    %esp,%ebp
c00256d7:	56                   	push   %esi
c00256d8:	53                   	push   %ebx
c00256d9:	83 ec 04             	sub    $0x4,%esp
c00256dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00256df:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c00256e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00256e6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c00256e9:	8b 45 10             	mov    0x10(%ebp),%eax
c00256ec:	89 cb                	mov    %ecx,%ebx
c00256ee:	89 de                	mov    %ebx,%esi
c00256f0:	89 c1                	mov    %eax,%ecx
c00256f2:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
c00256f5:	89 c8                	mov    %ecx,%eax
c00256f7:	89 f3                	mov    %esi,%ebx
c00256f9:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c00256fc:	89 45 10             	mov    %eax,0x10(%ebp)
}
c00256ff:	90                   	nop
c0025700:	83 c4 04             	add    $0x4,%esp
c0025703:	5b                   	pop    %ebx
c0025704:	5e                   	pop    %esi
c0025705:	5d                   	pop    %ebp
c0025706:	c3                   	ret    

c0025707 <ide_init>:
static void interrupt_handler (struct intr_frame *);

/* Initialize the disk subsystem and detect disks. */
void
ide_init (void) 
{
c0025707:	55                   	push   %ebp
c0025708:	89 e5                	mov    %esp,%ebp
c002570a:	83 ec 18             	sub    $0x18,%esp
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c002570d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025714:	e9 ba 01 00 00       	jmp    c00258d3 <ide_init+0x1cc>
    {
      struct channel *c = &channels[chan_no];
c0025719:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002571c:	89 d0                	mov    %edx,%eax
c002571e:	c1 e0 02             	shl    $0x2,%eax
c0025721:	01 d0                	add    %edx,%eax
c0025723:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002572a:	01 d0                	add    %edx,%eax
c002572c:	c1 e0 02             	shl    $0x2,%eax
c002572f:	05 60 51 03 c0       	add    $0xc0035160,%eax
c0025734:	89 45 ec             	mov    %eax,-0x14(%ebp)
      int dev_no;

      /* Initialize channel. */
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c0025737:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002573a:	ff 75 f4             	push   -0xc(%ebp)
c002573d:	68 d0 00 03 c0       	push   $0xc00300d0
c0025742:	6a 08                	push   $0x8
c0025744:	50                   	push   %eax
c0025745:	e8 09 1a 00 00       	call   c0027153 <snprintf>
c002574a:	83 c4 10             	add    $0x10,%esp
      switch (chan_no) 
c002574d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0025751:	74 08                	je     c002575b <ide_init+0x54>
c0025753:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0025757:	74 14                	je     c002576d <ide_init+0x66>
c0025759:	eb 24                	jmp    c002577f <ide_init+0x78>
        {
        case 0:
          c->reg_base = 0x1f0;
c002575b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002575e:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
          c->irq = 14 + 0x20;
c0025764:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025767:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
          break;
c002576b:	eb 28                	jmp    c0025795 <ide_init+0x8e>
        case 1:
          c->reg_base = 0x170;
c002576d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025770:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
          c->irq = 15 + 0x20;
c0025776:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025779:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
          break;
c002577d:	eb 16                	jmp    c0025795 <ide_init+0x8e>
        default:
          NOT_REACHED ();
c002577f:	68 d8 00 03 c0       	push   $0xc00300d8
c0025784:	68 2c 02 03 c0       	push   $0xc003022c
c0025789:	6a 7c                	push   $0x7c
c002578b:	68 fa 00 03 c0       	push   $0xc00300fa
c0025790:	e8 89 3d 00 00       	call   c002951e <debug_panic>
        }
      lock_init (&c->lock);
c0025795:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025798:	83 c0 0c             	add    $0xc,%eax
c002579b:	83 ec 0c             	sub    $0xc,%esp
c002579e:	50                   	push   %eax
c002579f:	e8 b1 d2 ff ff       	call   c0022a55 <lock_init>
c00257a4:	83 c4 10             	add    $0x10,%esp
      c->expecting_interrupt = false;
c00257a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00257aa:	c6 40 24 00          	movb   $0x0,0x24(%eax)
      sema_init (&c->completion_wait, 0);
c00257ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00257b1:	83 c0 28             	add    $0x28,%eax
c00257b4:	83 ec 08             	sub    $0x8,%esp
c00257b7:	6a 00                	push   $0x0
c00257b9:	50                   	push   %eax
c00257ba:	e8 dd cf ff ff       	call   c002279c <sema_init>
c00257bf:	83 c4 10             	add    $0x10,%esp
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c00257c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00257c9:	eb 5a                	jmp    c0025825 <ide_init+0x11e>
        {
          struct ata_disk *d = &c->devices[dev_no];
c00257cb:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00257ce:	89 d0                	mov    %edx,%eax
c00257d0:	c1 e0 02             	shl    $0x2,%eax
c00257d3:	01 d0                	add    %edx,%eax
c00257d5:	c1 e0 02             	shl    $0x2,%eax
c00257d8:	8d 50 30             	lea    0x30(%eax),%edx
c00257db:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00257de:	01 d0                	add    %edx,%eax
c00257e0:	83 c0 0c             	add    $0xc,%eax
c00257e3:	89 45 e8             	mov    %eax,-0x18(%ebp)
          snprintf (d->name, sizeof d->name,
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
c00257e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00257e9:	01 c0                	add    %eax,%eax
c00257eb:	89 c2                	mov    %eax,%edx
c00257ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00257f0:	01 d0                	add    %edx,%eax
          snprintf (d->name, sizeof d->name,
c00257f2:	8d 50 61             	lea    0x61(%eax),%edx
c00257f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00257f8:	52                   	push   %edx
c00257f9:	68 0e 01 03 c0       	push   $0xc003010e
c00257fe:	6a 08                	push   $0x8
c0025800:	50                   	push   %eax
c0025801:	e8 4d 19 00 00       	call   c0027153 <snprintf>
c0025806:	83 c4 10             	add    $0x10,%esp
          d->channel = c;
c0025809:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002580c:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002580f:	89 50 08             	mov    %edx,0x8(%eax)
          d->dev_no = dev_no;
c0025812:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025815:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025818:	89 50 0c             	mov    %edx,0xc(%eax)
          d->is_ata = false;
c002581b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002581e:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025822:	ff 45 f0             	incl   -0x10(%ebp)
c0025825:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c0025829:	7e a0                	jle    c00257cb <ide_init+0xc4>
        }

      /* Register interrupt handler. */
      intr_register_ext (c->irq, interrupt_handler, c->name);
c002582b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002582e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025831:	8a 40 0a             	mov    0xa(%eax),%al
c0025834:	0f b6 c0             	movzbl %al,%eax
c0025837:	83 ec 04             	sub    $0x4,%esp
c002583a:	52                   	push   %edx
c002583b:	68 4c 63 02 c0       	push   $0xc002634c
c0025840:	50                   	push   %eax
c0025841:	e8 76 bd ff ff       	call   c00215bc <intr_register_ext>
c0025846:	83 c4 10             	add    $0x10,%esp

      /* Reset hardware. */
      reset_channel (c);
c0025849:	83 ec 0c             	sub    $0xc,%esp
c002584c:	ff 75 ec             	push   -0x14(%ebp)
c002584f:	e8 8d 00 00 00       	call   c00258e1 <reset_channel>
c0025854:	83 c4 10             	add    $0x10,%esp

      /* Distinguish ATA hard disks from other devices. */
      if (check_device_type (&c->devices[0]))
c0025857:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002585a:	83 c0 3c             	add    $0x3c,%eax
c002585d:	83 ec 0c             	sub    $0xc,%esp
c0025860:	50                   	push   %eax
c0025861:	e8 f9 02 00 00       	call   c0025b5f <check_device_type>
c0025866:	83 c4 10             	add    $0x10,%esp
c0025869:	84 c0                	test   %al,%al
c002586b:	74 12                	je     c002587f <ide_init+0x178>
        check_device_type (&c->devices[1]);
c002586d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025870:	83 c0 50             	add    $0x50,%eax
c0025873:	83 ec 0c             	sub    $0xc,%esp
c0025876:	50                   	push   %eax
c0025877:	e8 e3 02 00 00       	call   c0025b5f <check_device_type>
c002587c:	83 c4 10             	add    $0x10,%esp

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c002587f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025886:	eb 42                	jmp    c00258ca <ide_init+0x1c3>
        if (c->devices[dev_no].is_ata)
c0025888:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c002588b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002588e:	89 d0                	mov    %edx,%eax
c0025890:	c1 e0 02             	shl    $0x2,%eax
c0025893:	01 d0                	add    %edx,%eax
c0025895:	c1 e0 02             	shl    $0x2,%eax
c0025898:	01 c8                	add    %ecx,%eax
c002589a:	83 c0 4c             	add    $0x4c,%eax
c002589d:	8a 00                	mov    (%eax),%al
c002589f:	84 c0                	test   %al,%al
c00258a1:	74 24                	je     c00258c7 <ide_init+0x1c0>
          identify_ata_device (&c->devices[dev_no]);
c00258a3:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00258a6:	89 d0                	mov    %edx,%eax
c00258a8:	c1 e0 02             	shl    $0x2,%eax
c00258ab:	01 d0                	add    %edx,%eax
c00258ad:	c1 e0 02             	shl    $0x2,%eax
c00258b0:	8d 50 30             	lea    0x30(%eax),%edx
c00258b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00258b6:	01 d0                	add    %edx,%eax
c00258b8:	83 c0 0c             	add    $0xc,%eax
c00258bb:	83 ec 0c             	sub    $0xc,%esp
c00258be:	50                   	push   %eax
c00258bf:	e8 8c 03 00 00       	call   c0025c50 <identify_ata_device>
c00258c4:	83 c4 10             	add    $0x10,%esp
      for (dev_no = 0; dev_no < 2; dev_no++)
c00258c7:	ff 45 f0             	incl   -0x10(%ebp)
c00258ca:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c00258ce:	7e b8                	jle    c0025888 <ide_init+0x181>
  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c00258d0:	ff 45 f4             	incl   -0xc(%ebp)
c00258d3:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c00258d7:	0f 86 3c fe ff ff    	jbe    c0025719 <ide_init+0x12>
    }
}
c00258dd:	90                   	nop
c00258de:	90                   	nop
c00258df:	c9                   	leave  
c00258e0:	c3                   	ret    

c00258e1 <reset_channel>:

/* Resets an ATA channel and waits for any devices present on it
   to finish the reset. */
static void
reset_channel (struct channel *c) 
{
c00258e1:	55                   	push   %ebp
c00258e2:	89 e5                	mov    %esp,%ebp
c00258e4:	83 ec 18             	sub    $0x18,%esp
  bool present[2];
  int dev_no;

  /* The ATA reset sequence depends on which devices are present,
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
c00258e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00258ee:	e9 22 01 00 00       	jmp    c0025a15 <reset_channel+0x134>
    {
      struct ata_disk *d = &c->devices[dev_no];
c00258f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00258f6:	89 d0                	mov    %edx,%eax
c00258f8:	c1 e0 02             	shl    $0x2,%eax
c00258fb:	01 d0                	add    %edx,%eax
c00258fd:	c1 e0 02             	shl    $0x2,%eax
c0025900:	8d 50 30             	lea    0x30(%eax),%edx
c0025903:	8b 45 08             	mov    0x8(%ebp),%eax
c0025906:	01 d0                	add    %edx,%eax
c0025908:	83 c0 0c             	add    $0xc,%eax
c002590b:	89 45 ec             	mov    %eax,-0x14(%ebp)

      select_device (d);
c002590e:	83 ec 0c             	sub    $0xc,%esp
c0025911:	ff 75 ec             	push   -0x14(%ebp)
c0025914:	e8 98 09 00 00       	call   c00262b1 <select_device>
c0025919:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c002591c:	8b 45 08             	mov    0x8(%ebp),%eax
c002591f:	8b 40 08             	mov    0x8(%eax),%eax
c0025922:	83 c0 02             	add    $0x2,%eax
c0025925:	0f b7 c0             	movzwl %ax,%eax
c0025928:	83 ec 08             	sub    $0x8,%esp
c002592b:	6a 55                	push   $0x55
c002592d:	50                   	push   %eax
c002592e:	e8 82 fd ff ff       	call   c00256b5 <outb>
c0025933:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0025936:	8b 45 08             	mov    0x8(%ebp),%eax
c0025939:	8b 40 08             	mov    0x8(%eax),%eax
c002593c:	83 c0 03             	add    $0x3,%eax
c002593f:	0f b7 c0             	movzwl %ax,%eax
c0025942:	83 ec 08             	sub    $0x8,%esp
c0025945:	68 aa 00 00 00       	push   $0xaa
c002594a:	50                   	push   %eax
c002594b:	e8 65 fd ff ff       	call   c00256b5 <outb>
c0025950:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0xaa);
c0025953:	8b 45 08             	mov    0x8(%ebp),%eax
c0025956:	8b 40 08             	mov    0x8(%eax),%eax
c0025959:	83 c0 02             	add    $0x2,%eax
c002595c:	0f b7 c0             	movzwl %ax,%eax
c002595f:	83 ec 08             	sub    $0x8,%esp
c0025962:	68 aa 00 00 00       	push   $0xaa
c0025967:	50                   	push   %eax
c0025968:	e8 48 fd ff ff       	call   c00256b5 <outb>
c002596d:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0x55);
c0025970:	8b 45 08             	mov    0x8(%ebp),%eax
c0025973:	8b 40 08             	mov    0x8(%eax),%eax
c0025976:	83 c0 03             	add    $0x3,%eax
c0025979:	0f b7 c0             	movzwl %ax,%eax
c002597c:	83 ec 08             	sub    $0x8,%esp
c002597f:	6a 55                	push   $0x55
c0025981:	50                   	push   %eax
c0025982:	e8 2e fd ff ff       	call   c00256b5 <outb>
c0025987:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c002598a:	8b 45 08             	mov    0x8(%ebp),%eax
c002598d:	8b 40 08             	mov    0x8(%eax),%eax
c0025990:	83 c0 02             	add    $0x2,%eax
c0025993:	0f b7 c0             	movzwl %ax,%eax
c0025996:	83 ec 08             	sub    $0x8,%esp
c0025999:	6a 55                	push   $0x55
c002599b:	50                   	push   %eax
c002599c:	e8 14 fd ff ff       	call   c00256b5 <outb>
c00259a1:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c00259a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00259a7:	8b 40 08             	mov    0x8(%eax),%eax
c00259aa:	83 c0 03             	add    $0x3,%eax
c00259ad:	0f b7 c0             	movzwl %ax,%eax
c00259b0:	83 ec 08             	sub    $0x8,%esp
c00259b3:	68 aa 00 00 00       	push   $0xaa
c00259b8:	50                   	push   %eax
c00259b9:	e8 f7 fc ff ff       	call   c00256b5 <outb>
c00259be:	83 c4 10             	add    $0x10,%esp

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c00259c1:	8b 45 08             	mov    0x8(%ebp),%eax
c00259c4:	8b 40 08             	mov    0x8(%eax),%eax
c00259c7:	83 c0 02             	add    $0x2,%eax
c00259ca:	0f b7 c0             	movzwl %ax,%eax
c00259cd:	83 ec 0c             	sub    $0xc,%esp
c00259d0:	50                   	push   %eax
c00259d1:	e8 91 fc ff ff       	call   c0025667 <inb>
c00259d6:	83 c4 10             	add    $0x10,%esp
                         && inb (reg_lbal (c)) == 0xaa);
c00259d9:	3c 55                	cmp    $0x55,%al
c00259db:	75 23                	jne    c0025a00 <reset_channel+0x11f>
c00259dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00259e0:	8b 40 08             	mov    0x8(%eax),%eax
c00259e3:	83 c0 03             	add    $0x3,%eax
c00259e6:	0f b7 c0             	movzwl %ax,%eax
c00259e9:	83 ec 0c             	sub    $0xc,%esp
c00259ec:	50                   	push   %eax
c00259ed:	e8 75 fc ff ff       	call   c0025667 <inb>
c00259f2:	83 c4 10             	add    $0x10,%esp
c00259f5:	3c aa                	cmp    $0xaa,%al
c00259f7:	75 07                	jne    c0025a00 <reset_channel+0x11f>
c00259f9:	b8 01 00 00 00       	mov    $0x1,%eax
c00259fe:	eb 05                	jmp    c0025a05 <reset_channel+0x124>
c0025a00:	b8 00 00 00 00       	mov    $0x0,%eax
c0025a05:	83 e0 01             	and    $0x1,%eax
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0025a08:	8d 4d ea             	lea    -0x16(%ebp),%ecx
c0025a0b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025a0e:	01 ca                	add    %ecx,%edx
c0025a10:	88 02                	mov    %al,(%edx)
  for (dev_no = 0; dev_no < 2; dev_no++)
c0025a12:	ff 45 f4             	incl   -0xc(%ebp)
c0025a15:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0025a19:	0f 8e d4 fe ff ff    	jle    c00258f3 <reset_channel+0x12>
    }

  /* Issue soft reset sequence, which selects device 0 as a side effect.
     Also enable interrupts. */
  outb (reg_ctl (c), 0);
c0025a1f:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a22:	8b 40 08             	mov    0x8(%eax),%eax
c0025a25:	05 06 02 00 00       	add    $0x206,%eax
c0025a2a:	0f b7 c0             	movzwl %ax,%eax
c0025a2d:	83 ec 08             	sub    $0x8,%esp
c0025a30:	6a 00                	push   $0x0
c0025a32:	50                   	push   %eax
c0025a33:	e8 7d fc ff ff       	call   c00256b5 <outb>
c0025a38:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c0025a3b:	83 ec 08             	sub    $0x8,%esp
c0025a3e:	6a 00                	push   $0x0
c0025a40:	6a 0a                	push   $0xa
c0025a42:	e8 4b e3 ff ff       	call   c0023d92 <timer_usleep>
c0025a47:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), CTL_SRST);
c0025a4a:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a4d:	8b 40 08             	mov    0x8(%eax),%eax
c0025a50:	05 06 02 00 00       	add    $0x206,%eax
c0025a55:	0f b7 c0             	movzwl %ax,%eax
c0025a58:	83 ec 08             	sub    $0x8,%esp
c0025a5b:	6a 04                	push   $0x4
c0025a5d:	50                   	push   %eax
c0025a5e:	e8 52 fc ff ff       	call   c00256b5 <outb>
c0025a63:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c0025a66:	83 ec 08             	sub    $0x8,%esp
c0025a69:	6a 00                	push   $0x0
c0025a6b:	6a 0a                	push   $0xa
c0025a6d:	e8 20 e3 ff ff       	call   c0023d92 <timer_usleep>
c0025a72:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), 0);
c0025a75:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a78:	8b 40 08             	mov    0x8(%eax),%eax
c0025a7b:	05 06 02 00 00       	add    $0x206,%eax
c0025a80:	0f b7 c0             	movzwl %ax,%eax
c0025a83:	83 ec 08             	sub    $0x8,%esp
c0025a86:	6a 00                	push   $0x0
c0025a88:	50                   	push   %eax
c0025a89:	e8 27 fc ff ff       	call   c00256b5 <outb>
c0025a8e:	83 c4 10             	add    $0x10,%esp

  timer_msleep (150);
c0025a91:	83 ec 08             	sub    $0x8,%esp
c0025a94:	6a 00                	push   $0x0
c0025a96:	68 96 00 00 00       	push   $0x96
c0025a9b:	e8 c7 e2 ff ff       	call   c0023d67 <timer_msleep>
c0025aa0:	83 c4 10             	add    $0x10,%esp

  /* Wait for device 0 to clear BSY. */
  if (present[0]) 
c0025aa3:	8a 45 ea             	mov    -0x16(%ebp),%al
c0025aa6:	84 c0                	test   %al,%al
c0025aa8:	74 24                	je     c0025ace <reset_channel+0x1ed>
    {
      select_device (&c->devices[0]);
c0025aaa:	8b 45 08             	mov    0x8(%ebp),%eax
c0025aad:	83 c0 3c             	add    $0x3c,%eax
c0025ab0:	83 ec 0c             	sub    $0xc,%esp
c0025ab3:	50                   	push   %eax
c0025ab4:	e8 f8 07 00 00       	call   c00262b1 <select_device>
c0025ab9:	83 c4 10             	add    $0x10,%esp
      wait_while_busy (&c->devices[0]); 
c0025abc:	8b 45 08             	mov    0x8(%ebp),%eax
c0025abf:	83 c0 3c             	add    $0x3c,%eax
c0025ac2:	83 ec 0c             	sub    $0xc,%esp
c0025ac5:	50                   	push   %eax
c0025ac6:	e8 1d 07 00 00       	call   c00261e8 <wait_while_busy>
c0025acb:	83 c4 10             	add    $0x10,%esp
    }

  /* Wait for device 1 to clear BSY. */
  if (present[1])
c0025ace:	8a 45 eb             	mov    -0x15(%ebp),%al
c0025ad1:	84 c0                	test   %al,%al
c0025ad3:	0f 84 83 00 00 00    	je     c0025b5c <reset_channel+0x27b>
    {
      int i;

      select_device (&c->devices[1]);
c0025ad9:	8b 45 08             	mov    0x8(%ebp),%eax
c0025adc:	83 c0 50             	add    $0x50,%eax
c0025adf:	83 ec 0c             	sub    $0xc,%esp
c0025ae2:	50                   	push   %eax
c0025ae3:	e8 c9 07 00 00       	call   c00262b1 <select_device>
c0025ae8:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c0025aeb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025af2:	eb 4a                	jmp    c0025b3e <reset_channel+0x25d>
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c0025af4:	8b 45 08             	mov    0x8(%ebp),%eax
c0025af7:	8b 40 08             	mov    0x8(%eax),%eax
c0025afa:	83 c0 02             	add    $0x2,%eax
c0025afd:	0f b7 c0             	movzwl %ax,%eax
c0025b00:	83 ec 0c             	sub    $0xc,%esp
c0025b03:	50                   	push   %eax
c0025b04:	e8 5e fb ff ff       	call   c0025667 <inb>
c0025b09:	83 c4 10             	add    $0x10,%esp
c0025b0c:	3c 01                	cmp    $0x1,%al
c0025b0e:	75 1c                	jne    c0025b2c <reset_channel+0x24b>
c0025b10:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b13:	8b 40 08             	mov    0x8(%eax),%eax
c0025b16:	83 c0 03             	add    $0x3,%eax
c0025b19:	0f b7 c0             	movzwl %ax,%eax
c0025b1c:	83 ec 0c             	sub    $0xc,%esp
c0025b1f:	50                   	push   %eax
c0025b20:	e8 42 fb ff ff       	call   c0025667 <inb>
c0025b25:	83 c4 10             	add    $0x10,%esp
c0025b28:	3c 01                	cmp    $0x1,%al
c0025b2a:	74 1d                	je     c0025b49 <reset_channel+0x268>
            break;
          timer_msleep (10);
c0025b2c:	83 ec 08             	sub    $0x8,%esp
c0025b2f:	6a 00                	push   $0x0
c0025b31:	6a 0a                	push   $0xa
c0025b33:	e8 2f e2 ff ff       	call   c0023d67 <timer_msleep>
c0025b38:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c0025b3b:	ff 45 f0             	incl   -0x10(%ebp)
c0025b3e:	81 7d f0 b7 0b 00 00 	cmpl   $0xbb7,-0x10(%ebp)
c0025b45:	7e ad                	jle    c0025af4 <reset_channel+0x213>
c0025b47:	eb 01                	jmp    c0025b4a <reset_channel+0x269>
            break;
c0025b49:	90                   	nop
        }
      wait_while_busy (&c->devices[1]);
c0025b4a:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b4d:	83 c0 50             	add    $0x50,%eax
c0025b50:	83 ec 0c             	sub    $0xc,%esp
c0025b53:	50                   	push   %eax
c0025b54:	e8 8f 06 00 00       	call   c00261e8 <wait_while_busy>
c0025b59:	83 c4 10             	add    $0x10,%esp
    }
}
c0025b5c:	90                   	nop
c0025b5d:	c9                   	leave  
c0025b5e:	c3                   	ret    

c0025b5f <check_device_type>:
   if it's possible that a slave (device 1) exists on this
   channel.  If D is device 1 (slave), the return value is not
   meaningful. */
static bool
check_device_type (struct ata_disk *d) 
{
c0025b5f:	55                   	push   %ebp
c0025b60:	89 e5                	mov    %esp,%ebp
c0025b62:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0025b65:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b68:	8b 40 08             	mov    0x8(%eax),%eax
c0025b6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  uint8_t error, lbam, lbah, status;

  select_device (d);
c0025b6e:	83 ec 0c             	sub    $0xc,%esp
c0025b71:	ff 75 08             	push   0x8(%ebp)
c0025b74:	e8 38 07 00 00       	call   c00262b1 <select_device>
c0025b79:	83 c4 10             	add    $0x10,%esp

  error = inb (reg_error (c));
c0025b7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025b7f:	8b 40 08             	mov    0x8(%eax),%eax
c0025b82:	40                   	inc    %eax
c0025b83:	0f b7 c0             	movzwl %ax,%eax
c0025b86:	83 ec 0c             	sub    $0xc,%esp
c0025b89:	50                   	push   %eax
c0025b8a:	e8 d8 fa ff ff       	call   c0025667 <inb>
c0025b8f:	83 c4 10             	add    $0x10,%esp
c0025b92:	88 45 f3             	mov    %al,-0xd(%ebp)
  lbam = inb (reg_lbam (c));
c0025b95:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025b98:	8b 40 08             	mov    0x8(%eax),%eax
c0025b9b:	83 c0 04             	add    $0x4,%eax
c0025b9e:	0f b7 c0             	movzwl %ax,%eax
c0025ba1:	83 ec 0c             	sub    $0xc,%esp
c0025ba4:	50                   	push   %eax
c0025ba5:	e8 bd fa ff ff       	call   c0025667 <inb>
c0025baa:	83 c4 10             	add    $0x10,%esp
c0025bad:	88 45 f2             	mov    %al,-0xe(%ebp)
  lbah = inb (reg_lbah (c));
c0025bb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025bb3:	8b 40 08             	mov    0x8(%eax),%eax
c0025bb6:	83 c0 05             	add    $0x5,%eax
c0025bb9:	0f b7 c0             	movzwl %ax,%eax
c0025bbc:	83 ec 0c             	sub    $0xc,%esp
c0025bbf:	50                   	push   %eax
c0025bc0:	e8 a2 fa ff ff       	call   c0025667 <inb>
c0025bc5:	83 c4 10             	add    $0x10,%esp
c0025bc8:	88 45 f1             	mov    %al,-0xf(%ebp)
  status = inb (reg_status (c));
c0025bcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025bce:	8b 40 08             	mov    0x8(%eax),%eax
c0025bd1:	83 c0 07             	add    $0x7,%eax
c0025bd4:	0f b7 c0             	movzwl %ax,%eax
c0025bd7:	83 ec 0c             	sub    $0xc,%esp
c0025bda:	50                   	push   %eax
c0025bdb:	e8 87 fa ff ff       	call   c0025667 <inb>
c0025be0:	83 c4 10             	add    $0x10,%esp
c0025be3:	88 45 f0             	mov    %al,-0x10(%ebp)

  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0025be6:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
c0025bea:	74 11                	je     c0025bfd <check_device_type+0x9e>
c0025bec:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c0025bf0:	75 1d                	jne    c0025c0f <check_device_type+0xb0>
c0025bf2:	8b 45 08             	mov    0x8(%ebp),%eax
c0025bf5:	8b 40 0c             	mov    0xc(%eax),%eax
c0025bf8:	83 f8 01             	cmp    $0x1,%eax
c0025bfb:	74 12                	je     c0025c0f <check_device_type+0xb0>
      || (status & STA_DRDY) == 0
c0025bfd:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0025c01:	83 e0 40             	and    $0x40,%eax
c0025c04:	85 c0                	test   %eax,%eax
c0025c06:	74 07                	je     c0025c0f <check_device_type+0xb0>
      || (status & STA_BSY) != 0)
c0025c08:	8a 45 f0             	mov    -0x10(%ebp),%al
c0025c0b:	84 c0                	test   %al,%al
c0025c0d:	79 10                	jns    c0025c1f <check_device_type+0xc0>
    {
      d->is_ata = false;
c0025c0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c12:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return error != 0x81;      
c0025c16:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c0025c1a:	0f 95 c0             	setne  %al
c0025c1d:	eb 2f                	jmp    c0025c4e <check_device_type+0xef>
    }
  else 
    {
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0025c1f:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c0025c23:	75 06                	jne    c0025c2b <check_device_type+0xcc>
c0025c25:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c0025c29:	74 0c                	je     c0025c37 <check_device_type+0xd8>
c0025c2b:	80 7d f2 3c          	cmpb   $0x3c,-0xe(%ebp)
c0025c2f:	75 0d                	jne    c0025c3e <check_device_type+0xdf>
c0025c31:	80 7d f1 c3          	cmpb   $0xc3,-0xf(%ebp)
c0025c35:	75 07                	jne    c0025c3e <check_device_type+0xdf>
c0025c37:	b8 01 00 00 00       	mov    $0x1,%eax
c0025c3c:	eb 05                	jmp    c0025c43 <check_device_type+0xe4>
c0025c3e:	b8 00 00 00 00       	mov    $0x0,%eax
c0025c43:	83 e0 01             	and    $0x1,%eax
c0025c46:	8b 55 08             	mov    0x8(%ebp),%edx
c0025c49:	88 42 10             	mov    %al,0x10(%edx)
      return true; 
c0025c4c:	b0 01                	mov    $0x1,%al
    }
}
c0025c4e:	c9                   	leave  
c0025c4f:	c3                   	ret    

c0025c50 <identify_ata_device>:
/* Sends an IDENTIFY DEVICE command to disk D and reads the
   response.  Registers the disk with the block device
   layer. */
static void
identify_ata_device (struct ata_disk *d) 
{
c0025c50:	55                   	push   %ebp
c0025c51:	89 e5                	mov    %esp,%ebp
c0025c53:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
  struct channel *c = d->channel;
c0025c59:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c5c:	8b 40 08             	mov    0x8(%eax),%eax
c0025c5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_sector_t capacity;
  char *model, *serial;
  char extra_info[128];
  struct block *block;

  ASSERT (d->is_ata);
c0025c62:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c65:	8a 40 10             	mov    0x10(%eax),%al
c0025c68:	84 c0                	test   %al,%al
c0025c6a:	75 21                	jne    c0025c8d <identify_ata_device+0x3d>
c0025c6c:	83 ec 0c             	sub    $0xc,%esp
c0025c6f:	68 13 01 03 c0       	push   $0xc0030113
c0025c74:	68 1d 01 03 c0       	push   $0xc003011d
c0025c79:	68 38 02 03 c0       	push   $0xc0030238
c0025c7e:	68 0d 01 00 00       	push   $0x10d
c0025c83:	68 fa 00 03 c0       	push   $0xc00300fa
c0025c88:	e8 91 38 00 00       	call   c002951e <debug_panic>

  /* Send the IDENTIFY DEVICE command, wait for an interrupt
     indicating the device's response is ready, and read the data
     into our buffer. */
  select_device_wait (d);
c0025c8d:	83 ec 0c             	sub    $0xc,%esp
c0025c90:	ff 75 08             	push   0x8(%ebp)
c0025c93:	e8 81 06 00 00       	call   c0026319 <select_device_wait>
c0025c98:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c0025c9b:	83 ec 08             	sub    $0x8,%esp
c0025c9e:	68 ec 00 00 00       	push   $0xec
c0025ca3:	ff 75 f4             	push   -0xc(%ebp)
c0025ca6:	e8 38 04 00 00       	call   c00260e3 <issue_pio_command>
c0025cab:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0025cae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025cb1:	83 c0 28             	add    $0x28,%eax
c0025cb4:	83 ec 0c             	sub    $0xc,%esp
c0025cb7:	50                   	push   %eax
c0025cb8:	e8 26 cb ff ff       	call   c00227e3 <sema_down>
c0025cbd:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0025cc0:	83 ec 0c             	sub    $0xc,%esp
c0025cc3:	ff 75 08             	push   0x8(%ebp)
c0025cc6:	e8 1d 05 00 00       	call   c00261e8 <wait_while_busy>
c0025ccb:	83 c4 10             	add    $0x10,%esp
c0025cce:	83 f0 01             	xor    $0x1,%eax
c0025cd1:	84 c0                	test   %al,%al
c0025cd3:	74 0c                	je     c0025ce1 <identify_ata_device+0x91>
    {
      d->is_ata = false;
c0025cd5:	8b 45 08             	mov    0x8(%ebp),%eax
c0025cd8:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c0025cdc:	e9 fb 00 00 00       	jmp    c0025ddc <identify_ata_device+0x18c>
    }
  input_sector (c, id);
c0025ce1:	83 ec 08             	sub    $0x8,%esp
c0025ce4:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025cea:	50                   	push   %eax
c0025ceb:	ff 75 f4             	push   -0xc(%ebp)
c0025cee:	e8 4e 04 00 00       	call   c0026141 <input_sector>
c0025cf3:	83 c4 10             	add    $0x10,%esp

  /* Calculate capacity.
     Read model name and serial number. */
  capacity = *(uint32_t *) &id[60 * 2];
c0025cf6:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025cfc:	83 c0 78             	add    $0x78,%eax
c0025cff:	8b 00                	mov    (%eax),%eax
c0025d01:	89 45 f0             	mov    %eax,-0x10(%ebp)
  model = descramble_ata_string (&id[10 * 2], 20);
c0025d04:	83 ec 08             	sub    $0x8,%esp
c0025d07:	6a 14                	push   $0x14
c0025d09:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025d0f:	83 c0 14             	add    $0x14,%eax
c0025d12:	50                   	push   %eax
c0025d13:	e8 c6 00 00 00       	call   c0025dde <descramble_ata_string>
c0025d18:	83 c4 10             	add    $0x10,%esp
c0025d1b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  serial = descramble_ata_string (&id[27 * 2], 40);
c0025d1e:	83 ec 08             	sub    $0x8,%esp
c0025d21:	6a 28                	push   $0x28
c0025d23:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025d29:	83 c0 36             	add    $0x36,%eax
c0025d2c:	50                   	push   %eax
c0025d2d:	e8 ac 00 00 00       	call   c0025dde <descramble_ata_string>
c0025d32:	83 c4 10             	add    $0x10,%esp
c0025d35:	89 45 e8             	mov    %eax,-0x18(%ebp)
  snprintf (extra_info, sizeof extra_info,
c0025d38:	83 ec 0c             	sub    $0xc,%esp
c0025d3b:	ff 75 e8             	push   -0x18(%ebp)
c0025d3e:	ff 75 ec             	push   -0x14(%ebp)
c0025d41:	68 34 01 03 c0       	push   $0xc0030134
c0025d46:	68 80 00 00 00       	push   $0x80
c0025d4b:	8d 85 64 fd ff ff    	lea    -0x29c(%ebp),%eax
c0025d51:	50                   	push   %eax
c0025d52:	e8 fc 13 00 00       	call   c0027153 <snprintf>
c0025d57:	83 c4 20             	add    $0x20,%esp
  /* Disable access to IDE disks over 1 GB, which are likely
     physical IDE disks rather than virtual ones.  If we don't
     allow access to those, we're less likely to scribble on
     someone's important data.  You can disable this check by
     hand if you really want to do so. */
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c0025d5a:	81 7d f0 ff ff 1f 00 	cmpl   $0x1fffff,-0x10(%ebp)
c0025d61:	76 45                	jbe    c0025da8 <identify_ata_device+0x158>
    {
      printf ("%s: ignoring ", d->name);
c0025d63:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d66:	83 ec 08             	sub    $0x8,%esp
c0025d69:	50                   	push   %eax
c0025d6a:	68 4c 01 03 c0       	push   $0xc003014c
c0025d6f:	e8 08 14 00 00       	call   c002717c <printf>
c0025d74:	83 c4 10             	add    $0x10,%esp
      print_human_readable_size (capacity * 512);
c0025d77:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025d7a:	c1 e0 09             	shl    $0x9,%eax
c0025d7d:	ba 00 00 00 00       	mov    $0x0,%edx
c0025d82:	83 ec 08             	sub    $0x8,%esp
c0025d85:	52                   	push   %edx
c0025d86:	50                   	push   %eax
c0025d87:	e8 00 21 00 00       	call   c0027e8c <print_human_readable_size>
c0025d8c:	83 c4 10             	add    $0x10,%esp
      printf ("disk for safety\n");
c0025d8f:	83 ec 0c             	sub    $0xc,%esp
c0025d92:	68 5a 01 03 c0       	push   $0xc003015a
c0025d97:	e8 47 59 00 00       	call   c002b6e3 <puts>
c0025d9c:	83 c4 10             	add    $0x10,%esp
      d->is_ata = false;
c0025d9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0025da2:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c0025da6:	eb 34                	jmp    c0025ddc <identify_ata_device+0x18c>
    }

  /* Register. */
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c0025da8:	8b 45 08             	mov    0x8(%ebp),%eax
c0025dab:	83 ec 08             	sub    $0x8,%esp
c0025dae:	ff 75 08             	push   0x8(%ebp)
c0025db1:	68 60 38 03 c0       	push   $0xc0033860
c0025db6:	ff 75 f0             	push   -0x10(%ebp)
c0025db9:	8d 95 64 fd ff ff    	lea    -0x29c(%ebp),%edx
c0025dbf:	52                   	push   %edx
c0025dc0:	6a 04                	push   $0x4
c0025dc2:	50                   	push   %eax
c0025dc3:	e8 68 f2 ff ff       	call   c0025030 <block_register>
c0025dc8:	83 c4 20             	add    $0x20,%esp
c0025dcb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                          &ide_operations, d);
  partition_scan (block);
c0025dce:	83 ec 0c             	sub    $0xc,%esp
c0025dd1:	ff 75 e4             	push   -0x1c(%ebp)
c0025dd4:	e8 9f f3 ff ff       	call   c0025178 <partition_scan>
c0025dd9:	83 c4 10             	add    $0x10,%esp
}
c0025ddc:	c9                   	leave  
c0025ddd:	c3                   	ret    

c0025dde <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c0025dde:	55                   	push   %ebp
c0025ddf:	89 e5                	mov    %esp,%ebp
c0025de1:	83 ec 10             	sub    $0x10,%esp
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0025de4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0025deb:	eb 38                	jmp    c0025e25 <descramble_ata_string+0x47>
    {
      char tmp = string[i];
c0025ded:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0025df0:	8b 45 08             	mov    0x8(%ebp),%eax
c0025df3:	01 d0                	add    %edx,%eax
c0025df5:	8a 00                	mov    (%eax),%al
c0025df7:	88 45 f7             	mov    %al,-0x9(%ebp)
      string[i] = string[i + 1];
c0025dfa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0025dfd:	8d 50 01             	lea    0x1(%eax),%edx
c0025e00:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e03:	01 d0                	add    %edx,%eax
c0025e05:	8b 4d fc             	mov    -0x4(%ebp),%ecx
c0025e08:	8b 55 08             	mov    0x8(%ebp),%edx
c0025e0b:	01 ca                	add    %ecx,%edx
c0025e0d:	8a 00                	mov    (%eax),%al
c0025e0f:	88 02                	mov    %al,(%edx)
      string[i + 1] = tmp;
c0025e11:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0025e14:	8d 50 01             	lea    0x1(%eax),%edx
c0025e17:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e1a:	01 c2                	add    %eax,%edx
c0025e1c:	8a 45 f7             	mov    -0x9(%ebp),%al
c0025e1f:	88 02                	mov    %al,(%edx)
  for (i = 0; i + 1 < size; i += 2)
c0025e21:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
c0025e25:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0025e28:	40                   	inc    %eax
c0025e29:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0025e2c:	7f bf                	jg     c0025ded <descramble_ata_string+0xf>
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0025e2e:	ff 4d 0c             	decl   0xc(%ebp)
c0025e31:	eb 2b                	jmp    c0025e5e <descramble_ata_string+0x80>
    {
      int c = string[size - 1];
c0025e33:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025e36:	8d 50 ff             	lea    -0x1(%eax),%edx
c0025e39:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e3c:	01 d0                	add    %edx,%eax
c0025e3e:	8a 00                	mov    (%eax),%al
c0025e40:	0f be c0             	movsbl %al,%eax
c0025e43:	89 45 f8             	mov    %eax,-0x8(%ebp)
      if (c != '\0' && !isspace (c))
c0025e46:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0025e4a:	74 0f                	je     c0025e5b <descramble_ata_string+0x7d>
c0025e4c:	ff 75 f8             	push   -0x8(%ebp)
c0025e4f:	e8 de f7 ff ff       	call   c0025632 <isspace>
c0025e54:	83 c4 04             	add    $0x4,%esp
c0025e57:	85 c0                	test   %eax,%eax
c0025e59:	74 0b                	je     c0025e66 <descramble_ata_string+0x88>
  for (size--; size > 0; size--)
c0025e5b:	ff 4d 0c             	decl   0xc(%ebp)
c0025e5e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0025e62:	7f cf                	jg     c0025e33 <descramble_ata_string+0x55>
c0025e64:	eb 01                	jmp    c0025e67 <descramble_ata_string+0x89>
        break; 
c0025e66:	90                   	nop
    }
  string[size] = '\0';
c0025e67:	8b 55 0c             	mov    0xc(%ebp),%edx
c0025e6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e6d:	01 d0                	add    %edx,%eax
c0025e6f:	c6 00 00             	movb   $0x0,(%eax)

  return string;
c0025e72:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0025e75:	c9                   	leave  
c0025e76:	c3                   	ret    

c0025e77 <ide_read>:
   room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_read (void *d_, block_sector_t sec_no, void *buffer)
{
c0025e77:	55                   	push   %ebp
c0025e78:	89 e5                	mov    %esp,%ebp
c0025e7a:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c0025e7d:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e80:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c0025e83:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025e86:	8b 40 08             	mov    0x8(%eax),%eax
c0025e89:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c0025e8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025e8f:	83 c0 0c             	add    $0xc,%eax
c0025e92:	83 ec 0c             	sub    $0xc,%esp
c0025e95:	50                   	push   %eax
c0025e96:	e8 07 cc ff ff       	call   c0022aa2 <lock_acquire>
c0025e9b:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c0025e9e:	83 ec 08             	sub    $0x8,%esp
c0025ea1:	ff 75 0c             	push   0xc(%ebp)
c0025ea4:	ff 75 f4             	push   -0xc(%ebp)
c0025ea7:	e8 3b 01 00 00       	call   c0025fe7 <select_sector>
c0025eac:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c0025eaf:	83 ec 08             	sub    $0x8,%esp
c0025eb2:	6a 20                	push   $0x20
c0025eb4:	ff 75 f0             	push   -0x10(%ebp)
c0025eb7:	e8 27 02 00 00       	call   c00260e3 <issue_pio_command>
c0025ebc:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0025ebf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025ec2:	83 c0 28             	add    $0x28,%eax
c0025ec5:	83 ec 0c             	sub    $0xc,%esp
c0025ec8:	50                   	push   %eax
c0025ec9:	e8 15 c9 ff ff       	call   c00227e3 <sema_down>
c0025ece:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0025ed1:	83 ec 0c             	sub    $0xc,%esp
c0025ed4:	ff 75 f4             	push   -0xc(%ebp)
c0025ed7:	e8 0c 03 00 00       	call   c00261e8 <wait_while_busy>
c0025edc:	83 c4 10             	add    $0x10,%esp
c0025edf:	83 f0 01             	xor    $0x1,%eax
c0025ee2:	84 c0                	test   %al,%al
c0025ee4:	74 23                	je     c0025f09 <ide_read+0x92>
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c0025ee6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025ee9:	83 ec 08             	sub    $0x8,%esp
c0025eec:	ff 75 0c             	push   0xc(%ebp)
c0025eef:	50                   	push   %eax
c0025ef0:	68 6c 01 03 c0       	push   $0xc003016c
c0025ef5:	68 4c 02 03 c0       	push   $0xc003024c
c0025efa:	68 62 01 00 00       	push   $0x162
c0025eff:	68 fa 00 03 c0       	push   $0xc00300fa
c0025f04:	e8 15 36 00 00       	call   c002951e <debug_panic>
  input_sector (c, buffer);
c0025f09:	83 ec 08             	sub    $0x8,%esp
c0025f0c:	ff 75 10             	push   0x10(%ebp)
c0025f0f:	ff 75 f0             	push   -0x10(%ebp)
c0025f12:	e8 2a 02 00 00       	call   c0026141 <input_sector>
c0025f17:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c0025f1a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025f1d:	83 c0 0c             	add    $0xc,%eax
c0025f20:	83 ec 0c             	sub    $0xc,%esp
c0025f23:	50                   	push   %eax
c0025f24:	e8 b5 cc ff ff       	call   c0022bde <lock_release>
c0025f29:	83 c4 10             	add    $0x10,%esp
}
c0025f2c:	90                   	nop
c0025f2d:	c9                   	leave  
c0025f2e:	c3                   	ret    

c0025f2f <ide_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_write (void *d_, block_sector_t sec_no, const void *buffer)
{
c0025f2f:	55                   	push   %ebp
c0025f30:	89 e5                	mov    %esp,%ebp
c0025f32:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c0025f35:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f38:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c0025f3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025f3e:	8b 40 08             	mov    0x8(%eax),%eax
c0025f41:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c0025f44:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025f47:	83 c0 0c             	add    $0xc,%eax
c0025f4a:	83 ec 0c             	sub    $0xc,%esp
c0025f4d:	50                   	push   %eax
c0025f4e:	e8 4f cb ff ff       	call   c0022aa2 <lock_acquire>
c0025f53:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c0025f56:	83 ec 08             	sub    $0x8,%esp
c0025f59:	ff 75 0c             	push   0xc(%ebp)
c0025f5c:	ff 75 f4             	push   -0xc(%ebp)
c0025f5f:	e8 83 00 00 00       	call   c0025fe7 <select_sector>
c0025f64:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c0025f67:	83 ec 08             	sub    $0x8,%esp
c0025f6a:	6a 30                	push   $0x30
c0025f6c:	ff 75 f0             	push   -0x10(%ebp)
c0025f6f:	e8 6f 01 00 00       	call   c00260e3 <issue_pio_command>
c0025f74:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0025f77:	83 ec 0c             	sub    $0xc,%esp
c0025f7a:	ff 75 f4             	push   -0xc(%ebp)
c0025f7d:	e8 66 02 00 00       	call   c00261e8 <wait_while_busy>
c0025f82:	83 c4 10             	add    $0x10,%esp
c0025f85:	83 f0 01             	xor    $0x1,%eax
c0025f88:	84 c0                	test   %al,%al
c0025f8a:	74 23                	je     c0025faf <ide_write+0x80>
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c0025f8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025f8f:	83 ec 08             	sub    $0x8,%esp
c0025f92:	ff 75 0c             	push   0xc(%ebp)
c0025f95:	50                   	push   %eax
c0025f96:	68 8c 01 03 c0       	push   $0xc003018c
c0025f9b:	68 58 02 03 c0       	push   $0xc0030258
c0025fa0:	68 75 01 00 00       	push   $0x175
c0025fa5:	68 fa 00 03 c0       	push   $0xc00300fa
c0025faa:	e8 6f 35 00 00       	call   c002951e <debug_panic>
  output_sector (c, buffer);
c0025faf:	83 ec 08             	sub    $0x8,%esp
c0025fb2:	ff 75 10             	push   0x10(%ebp)
c0025fb5:	ff 75 f0             	push   -0x10(%ebp)
c0025fb8:	e8 a4 01 00 00       	call   c0026161 <output_sector>
c0025fbd:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0025fc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025fc3:	83 c0 28             	add    $0x28,%eax
c0025fc6:	83 ec 0c             	sub    $0xc,%esp
c0025fc9:	50                   	push   %eax
c0025fca:	e8 14 c8 ff ff       	call   c00227e3 <sema_down>
c0025fcf:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c0025fd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025fd5:	83 c0 0c             	add    $0xc,%eax
c0025fd8:	83 ec 0c             	sub    $0xc,%esp
c0025fdb:	50                   	push   %eax
c0025fdc:	e8 fd cb ff ff       	call   c0022bde <lock_release>
c0025fe1:	83 c4 10             	add    $0x10,%esp
}
c0025fe4:	90                   	nop
c0025fe5:	c9                   	leave  
c0025fe6:	c3                   	ret    

c0025fe7 <select_sector>:
/* Selects device D, waiting for it to become ready, and then
   writes SEC_NO to the disk's sector selection registers.  (We
   use LBA mode.) */
static void
select_sector (struct ata_disk *d, block_sector_t sec_no)
{
c0025fe7:	55                   	push   %ebp
c0025fe8:	89 e5                	mov    %esp,%ebp
c0025fea:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0025fed:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ff0:	8b 40 08             	mov    0x8(%eax),%eax
c0025ff3:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sec_no < (1UL << 28));
c0025ff6:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
c0025ffd:	76 21                	jbe    c0026020 <select_sector+0x39>
c0025fff:	83 ec 0c             	sub    $0xc,%esp
c0026002:	68 ad 01 03 c0       	push   $0xc00301ad
c0026007:	68 1d 01 03 c0       	push   $0xc003011d
c002600c:	68 64 02 03 c0       	push   $0xc0030264
c0026011:	68 89 01 00 00       	push   $0x189
c0026016:	68 fa 00 03 c0       	push   $0xc00300fa
c002601b:	e8 fe 34 00 00       	call   c002951e <debug_panic>
  
  select_device_wait (d);
c0026020:	83 ec 0c             	sub    $0xc,%esp
c0026023:	ff 75 08             	push   0x8(%ebp)
c0026026:	e8 ee 02 00 00       	call   c0026319 <select_device_wait>
c002602b:	83 c4 10             	add    $0x10,%esp
  outb (reg_nsect (c), 1);
c002602e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026031:	8b 40 08             	mov    0x8(%eax),%eax
c0026034:	83 c0 02             	add    $0x2,%eax
c0026037:	0f b7 c0             	movzwl %ax,%eax
c002603a:	83 ec 08             	sub    $0x8,%esp
c002603d:	6a 01                	push   $0x1
c002603f:	50                   	push   %eax
c0026040:	e8 70 f6 ff ff       	call   c00256b5 <outb>
c0026045:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbal (c), sec_no);
c0026048:	8b 45 0c             	mov    0xc(%ebp),%eax
c002604b:	0f b6 d0             	movzbl %al,%edx
c002604e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026051:	8b 40 08             	mov    0x8(%eax),%eax
c0026054:	83 c0 03             	add    $0x3,%eax
c0026057:	0f b7 c0             	movzwl %ax,%eax
c002605a:	83 ec 08             	sub    $0x8,%esp
c002605d:	52                   	push   %edx
c002605e:	50                   	push   %eax
c002605f:	e8 51 f6 ff ff       	call   c00256b5 <outb>
c0026064:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbam (c), sec_no >> 8);
c0026067:	8b 45 0c             	mov    0xc(%ebp),%eax
c002606a:	c1 e8 08             	shr    $0x8,%eax
c002606d:	0f b6 d0             	movzbl %al,%edx
c0026070:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026073:	8b 40 08             	mov    0x8(%eax),%eax
c0026076:	83 c0 04             	add    $0x4,%eax
c0026079:	0f b7 c0             	movzwl %ax,%eax
c002607c:	83 ec 08             	sub    $0x8,%esp
c002607f:	52                   	push   %edx
c0026080:	50                   	push   %eax
c0026081:	e8 2f f6 ff ff       	call   c00256b5 <outb>
c0026086:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbah (c), (sec_no >> 16));
c0026089:	8b 45 0c             	mov    0xc(%ebp),%eax
c002608c:	c1 e8 10             	shr    $0x10,%eax
c002608f:	0f b6 d0             	movzbl %al,%edx
c0026092:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026095:	8b 40 08             	mov    0x8(%eax),%eax
c0026098:	83 c0 05             	add    $0x5,%eax
c002609b:	0f b7 c0             	movzwl %ax,%eax
c002609e:	83 ec 08             	sub    $0x8,%esp
c00260a1:	52                   	push   %edx
c00260a2:	50                   	push   %eax
c00260a3:	e8 0d f6 ff ff       	call   c00256b5 <outb>
c00260a8:	83 c4 10             	add    $0x10,%esp
  outb (reg_device (c),
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c00260ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00260ae:	8b 40 0c             	mov    0xc(%eax),%eax
c00260b1:	83 f8 01             	cmp    $0x1,%eax
c00260b4:	75 04                	jne    c00260ba <select_sector+0xd3>
c00260b6:	b0 f0                	mov    $0xf0,%al
c00260b8:	eb 02                	jmp    c00260bc <select_sector+0xd5>
c00260ba:	b0 e0                	mov    $0xe0,%al
c00260bc:	8b 55 0c             	mov    0xc(%ebp),%edx
c00260bf:	c1 ea 18             	shr    $0x18,%edx
c00260c2:	09 d0                	or     %edx,%eax
  outb (reg_device (c),
c00260c4:	0f b6 d0             	movzbl %al,%edx
c00260c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00260ca:	8b 40 08             	mov    0x8(%eax),%eax
c00260cd:	83 c0 06             	add    $0x6,%eax
c00260d0:	0f b7 c0             	movzwl %ax,%eax
c00260d3:	83 ec 08             	sub    $0x8,%esp
c00260d6:	52                   	push   %edx
c00260d7:	50                   	push   %eax
c00260d8:	e8 d8 f5 ff ff       	call   c00256b5 <outb>
c00260dd:	83 c4 10             	add    $0x10,%esp
}
c00260e0:	90                   	nop
c00260e1:	c9                   	leave  
c00260e2:	c3                   	ret    

c00260e3 <issue_pio_command>:

/* Writes COMMAND to channel C and prepares for receiving a
   completion interrupt. */
static void
issue_pio_command (struct channel *c, uint8_t command) 
{
c00260e3:	55                   	push   %ebp
c00260e4:	89 e5                	mov    %esp,%ebp
c00260e6:	83 ec 18             	sub    $0x18,%esp
c00260e9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00260ec:	88 45 f4             	mov    %al,-0xc(%ebp)
  /* Interrupts must be enabled or our semaphore will never be
     up'd by the completion handler. */
  ASSERT (intr_get_level () == INTR_ON);
c00260ef:	e8 3b b2 ff ff       	call   c002132f <intr_get_level>
c00260f4:	83 f8 01             	cmp    $0x1,%eax
c00260f7:	74 21                	je     c002611a <issue_pio_command+0x37>
c00260f9:	83 ec 0c             	sub    $0xc,%esp
c00260fc:	68 c2 01 03 c0       	push   $0xc00301c2
c0026101:	68 1d 01 03 c0       	push   $0xc003011d
c0026106:	68 74 02 03 c0       	push   $0xc0030274
c002610b:	68 9b 01 00 00       	push   $0x19b
c0026110:	68 fa 00 03 c0       	push   $0xc00300fa
c0026115:	e8 04 34 00 00       	call   c002951e <debug_panic>

  c->expecting_interrupt = true;
c002611a:	8b 45 08             	mov    0x8(%ebp),%eax
c002611d:	c6 40 24 01          	movb   $0x1,0x24(%eax)
  outb (reg_command (c), command);
c0026121:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0026125:	8b 45 08             	mov    0x8(%ebp),%eax
c0026128:	8b 40 08             	mov    0x8(%eax),%eax
c002612b:	83 c0 07             	add    $0x7,%eax
c002612e:	0f b7 c0             	movzwl %ax,%eax
c0026131:	83 ec 08             	sub    $0x8,%esp
c0026134:	52                   	push   %edx
c0026135:	50                   	push   %eax
c0026136:	e8 7a f5 ff ff       	call   c00256b5 <outb>
c002613b:	83 c4 10             	add    $0x10,%esp
}
c002613e:	90                   	nop
c002613f:	c9                   	leave  
c0026140:	c3                   	ret    

c0026141 <input_sector>:

/* Reads a sector from channel C's data register in PIO mode into
   SECTOR, which must have room for BLOCK_SECTOR_SIZE bytes. */
static void
input_sector (struct channel *c, void *sector) 
{
c0026141:	55                   	push   %ebp
c0026142:	89 e5                	mov    %esp,%ebp
  insw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c0026144:	8b 45 08             	mov    0x8(%ebp),%eax
c0026147:	8b 40 08             	mov    0x8(%eax),%eax
c002614a:	0f b7 c0             	movzwl %ax,%eax
c002614d:	68 00 01 00 00       	push   $0x100
c0026152:	ff 75 0c             	push   0xc(%ebp)
c0026155:	50                   	push   %eax
c0026156:	e8 27 f5 ff ff       	call   c0025682 <insw>
c002615b:	83 c4 0c             	add    $0xc,%esp
}
c002615e:	90                   	nop
c002615f:	c9                   	leave  
c0026160:	c3                   	ret    

c0026161 <output_sector>:

/* Writes SECTOR to channel C's data register in PIO mode.
   SECTOR must contain BLOCK_SECTOR_SIZE bytes. */
static void
output_sector (struct channel *c, const void *sector) 
{
c0026161:	55                   	push   %ebp
c0026162:	89 e5                	mov    %esp,%ebp
  outsw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c0026164:	8b 45 08             	mov    0x8(%ebp),%eax
c0026167:	8b 40 08             	mov    0x8(%eax),%eax
c002616a:	0f b7 c0             	movzwl %ax,%eax
c002616d:	68 00 01 00 00       	push   $0x100
c0026172:	ff 75 0c             	push   0xc(%ebp)
c0026175:	50                   	push   %eax
c0026176:	e8 59 f5 ff ff       	call   c00256d4 <outsw>
c002617b:	83 c4 0c             	add    $0xc,%esp
}
c002617e:	90                   	nop
c002617f:	c9                   	leave  
c0026180:	c3                   	ret    

c0026181 <wait_until_idle>:

   As a side effect, reading the status register clears any
   pending interrupt. */
static void
wait_until_idle (const struct ata_disk *d) 
{
c0026181:	55                   	push   %ebp
c0026182:	89 e5                	mov    %esp,%ebp
c0026184:	83 ec 18             	sub    $0x18,%esp
  int i;

  for (i = 0; i < 1000; i++) 
c0026187:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002618e:	eb 36                	jmp    c00261c6 <wait_until_idle+0x45>
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0026190:	8b 45 08             	mov    0x8(%ebp),%eax
c0026193:	8b 40 08             	mov    0x8(%eax),%eax
c0026196:	8b 40 08             	mov    0x8(%eax),%eax
c0026199:	83 c0 07             	add    $0x7,%eax
c002619c:	0f b7 c0             	movzwl %ax,%eax
c002619f:	50                   	push   %eax
c00261a0:	e8 c2 f4 ff ff       	call   c0025667 <inb>
c00261a5:	83 c4 04             	add    $0x4,%esp
c00261a8:	0f b6 c0             	movzbl %al,%eax
c00261ab:	25 88 00 00 00       	and    $0x88,%eax
c00261b0:	85 c0                	test   %eax,%eax
c00261b2:	74 31                	je     c00261e5 <wait_until_idle+0x64>
        return;
      timer_usleep (10);
c00261b4:	83 ec 08             	sub    $0x8,%esp
c00261b7:	6a 00                	push   $0x0
c00261b9:	6a 0a                	push   $0xa
c00261bb:	e8 d2 db ff ff       	call   c0023d92 <timer_usleep>
c00261c0:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 1000; i++) 
c00261c3:	ff 45 f4             	incl   -0xc(%ebp)
c00261c6:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
c00261cd:	7e c1                	jle    c0026190 <wait_until_idle+0xf>
    }

  printf ("%s: idle timeout\n", d->name);
c00261cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00261d2:	83 ec 08             	sub    $0x8,%esp
c00261d5:	50                   	push   %eax
c00261d6:	68 df 01 03 c0       	push   $0xc00301df
c00261db:	e8 9c 0f 00 00       	call   c002717c <printf>
c00261e0:	83 c4 10             	add    $0x10,%esp
c00261e3:	eb 01                	jmp    c00261e6 <wait_until_idle+0x65>
        return;
c00261e5:	90                   	nop
}
c00261e6:	c9                   	leave  
c00261e7:	c3                   	ret    

c00261e8 <wait_while_busy>:
   and then return the status of the DRQ bit.
   The ATA standards say that a disk may take as long as that to
   complete its reset. */
static bool
wait_while_busy (const struct ata_disk *d) 
{
c00261e8:	55                   	push   %ebp
c00261e9:	89 e5                	mov    %esp,%ebp
c00261eb:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c00261ee:	8b 45 08             	mov    0x8(%ebp),%eax
c00261f1:	8b 40 08             	mov    0x8(%eax),%eax
c00261f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < 3000; i++)
c00261f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00261fe:	e9 8d 00 00 00       	jmp    c0026290 <wait_while_busy+0xa8>
    {
      if (i == 700)
c0026203:	81 7d f4 bc 02 00 00 	cmpl   $0x2bc,-0xc(%ebp)
c002620a:	75 14                	jne    c0026220 <wait_while_busy+0x38>
        printf ("%s: busy, waiting...", d->name);
c002620c:	8b 45 08             	mov    0x8(%ebp),%eax
c002620f:	83 ec 08             	sub    $0x8,%esp
c0026212:	50                   	push   %eax
c0026213:	68 f1 01 03 c0       	push   $0xc00301f1
c0026218:	e8 5f 0f 00 00       	call   c002717c <printf>
c002621d:	83 c4 10             	add    $0x10,%esp
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c0026220:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026223:	8b 40 08             	mov    0x8(%eax),%eax
c0026226:	05 06 02 00 00       	add    $0x206,%eax
c002622b:	0f b7 c0             	movzwl %ax,%eax
c002622e:	83 ec 0c             	sub    $0xc,%esp
c0026231:	50                   	push   %eax
c0026232:	e8 30 f4 ff ff       	call   c0025667 <inb>
c0026237:	83 c4 10             	add    $0x10,%esp
c002623a:	84 c0                	test   %al,%al
c002623c:	78 40                	js     c002627e <wait_while_busy+0x96>
        {
          if (i >= 700)
c002623e:	81 7d f4 bb 02 00 00 	cmpl   $0x2bb,-0xc(%ebp)
c0026245:	7e 10                	jle    c0026257 <wait_while_busy+0x6f>
            printf ("ok\n");
c0026247:	83 ec 0c             	sub    $0xc,%esp
c002624a:	68 06 02 03 c0       	push   $0xc0030206
c002624f:	e8 8f 54 00 00       	call   c002b6e3 <puts>
c0026254:	83 c4 10             	add    $0x10,%esp
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c0026257:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002625a:	8b 40 08             	mov    0x8(%eax),%eax
c002625d:	05 06 02 00 00       	add    $0x206,%eax
c0026262:	0f b7 c0             	movzwl %ax,%eax
c0026265:	83 ec 0c             	sub    $0xc,%esp
c0026268:	50                   	push   %eax
c0026269:	e8 f9 f3 ff ff       	call   c0025667 <inb>
c002626e:	83 c4 10             	add    $0x10,%esp
c0026271:	0f b6 c0             	movzbl %al,%eax
c0026274:	83 e0 08             	and    $0x8,%eax
c0026277:	85 c0                	test   %eax,%eax
c0026279:	0f 95 c0             	setne  %al
c002627c:	eb 31                	jmp    c00262af <wait_while_busy+0xc7>
        }
      timer_msleep (10);
c002627e:	83 ec 08             	sub    $0x8,%esp
c0026281:	6a 00                	push   $0x0
c0026283:	6a 0a                	push   $0xa
c0026285:	e8 dd da ff ff       	call   c0023d67 <timer_msleep>
c002628a:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 3000; i++)
c002628d:	ff 45 f4             	incl   -0xc(%ebp)
c0026290:	81 7d f4 b7 0b 00 00 	cmpl   $0xbb7,-0xc(%ebp)
c0026297:	0f 8e 66 ff ff ff    	jle    c0026203 <wait_while_busy+0x1b>
    }

  printf ("failed\n");
c002629d:	83 ec 0c             	sub    $0xc,%esp
c00262a0:	68 09 02 03 c0       	push   $0xc0030209
c00262a5:	e8 39 54 00 00       	call   c002b6e3 <puts>
c00262aa:	83 c4 10             	add    $0x10,%esp
  return false;
c00262ad:	b0 00                	mov    $0x0,%al
}
c00262af:	c9                   	leave  
c00262b0:	c3                   	ret    

c00262b1 <select_device>:

/* Program D's channel so that D is now the selected disk. */
static void
select_device (const struct ata_disk *d)
{
c00262b1:	55                   	push   %ebp
c00262b2:	89 e5                	mov    %esp,%ebp
c00262b4:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c00262b7:	8b 45 08             	mov    0x8(%ebp),%eax
c00262ba:	8b 40 08             	mov    0x8(%eax),%eax
c00262bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t dev = DEV_MBS;
c00262c0:	c6 45 f7 a0          	movb   $0xa0,-0x9(%ebp)
  if (d->dev_no == 1)
c00262c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00262c7:	8b 40 0c             	mov    0xc(%eax),%eax
c00262ca:	83 f8 01             	cmp    $0x1,%eax
c00262cd:	75 04                	jne    c00262d3 <select_device+0x22>
    dev |= DEV_DEV;
c00262cf:	80 4d f7 10          	orb    $0x10,-0x9(%ebp)
  outb (reg_device (c), dev);
c00262d3:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c00262d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00262da:	8b 40 08             	mov    0x8(%eax),%eax
c00262dd:	83 c0 06             	add    $0x6,%eax
c00262e0:	0f b7 c0             	movzwl %ax,%eax
c00262e3:	52                   	push   %edx
c00262e4:	50                   	push   %eax
c00262e5:	e8 cb f3 ff ff       	call   c00256b5 <outb>
c00262ea:	83 c4 08             	add    $0x8,%esp
  inb (reg_alt_status (c));
c00262ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00262f0:	8b 40 08             	mov    0x8(%eax),%eax
c00262f3:	05 06 02 00 00       	add    $0x206,%eax
c00262f8:	0f b7 c0             	movzwl %ax,%eax
c00262fb:	50                   	push   %eax
c00262fc:	e8 66 f3 ff ff       	call   c0025667 <inb>
c0026301:	83 c4 04             	add    $0x4,%esp
  timer_nsleep (400);
c0026304:	83 ec 08             	sub    $0x8,%esp
c0026307:	6a 00                	push   $0x0
c0026309:	68 90 01 00 00       	push   $0x190
c002630e:	e8 aa da ff ff       	call   c0023dbd <timer_nsleep>
c0026313:	83 c4 10             	add    $0x10,%esp
}
c0026316:	90                   	nop
c0026317:	c9                   	leave  
c0026318:	c3                   	ret    

c0026319 <select_device_wait>:

/* Select disk D in its channel, as select_device(), but wait for
   the channel to become idle before and after. */
static void
select_device_wait (const struct ata_disk *d) 
{
c0026319:	55                   	push   %ebp
c002631a:	89 e5                	mov    %esp,%ebp
c002631c:	83 ec 08             	sub    $0x8,%esp
  wait_until_idle (d);
c002631f:	83 ec 0c             	sub    $0xc,%esp
c0026322:	ff 75 08             	push   0x8(%ebp)
c0026325:	e8 57 fe ff ff       	call   c0026181 <wait_until_idle>
c002632a:	83 c4 10             	add    $0x10,%esp
  select_device (d);
c002632d:	83 ec 0c             	sub    $0xc,%esp
c0026330:	ff 75 08             	push   0x8(%ebp)
c0026333:	e8 79 ff ff ff       	call   c00262b1 <select_device>
c0026338:	83 c4 10             	add    $0x10,%esp
  wait_until_idle (d);
c002633b:	83 ec 0c             	sub    $0xc,%esp
c002633e:	ff 75 08             	push   0x8(%ebp)
c0026341:	e8 3b fe ff ff       	call   c0026181 <wait_until_idle>
c0026346:	83 c4 10             	add    $0x10,%esp
}
c0026349:	90                   	nop
c002634a:	c9                   	leave  
c002634b:	c3                   	ret    

c002634c <interrupt_handler>:

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c002634c:	55                   	push   %ebp
c002634d:	89 e5                	mov    %esp,%ebp
c002634f:	83 ec 18             	sub    $0x18,%esp
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c0026352:	c7 45 f4 60 51 03 c0 	movl   $0xc0035160,-0xc(%ebp)
c0026359:	eb 60                	jmp    c00263bb <interrupt_handler+0x6f>
    if (f->vec_no == c->irq)
c002635b:	8b 45 08             	mov    0x8(%ebp),%eax
c002635e:	8b 50 30             	mov    0x30(%eax),%edx
c0026361:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026364:	8a 40 0a             	mov    0xa(%eax),%al
c0026367:	0f b6 c0             	movzbl %al,%eax
c002636a:	39 c2                	cmp    %eax,%edx
c002636c:	75 49                	jne    c00263b7 <interrupt_handler+0x6b>
      {
        if (c->expecting_interrupt) 
c002636e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026371:	8a 40 24             	mov    0x24(%eax),%al
c0026374:	84 c0                	test   %al,%al
c0026376:	74 29                	je     c00263a1 <interrupt_handler+0x55>
          {
            inb (reg_status (c));               /* Acknowledge interrupt. */
c0026378:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002637b:	8b 40 08             	mov    0x8(%eax),%eax
c002637e:	83 c0 07             	add    $0x7,%eax
c0026381:	0f b7 c0             	movzwl %ax,%eax
c0026384:	50                   	push   %eax
c0026385:	e8 dd f2 ff ff       	call   c0025667 <inb>
c002638a:	83 c4 04             	add    $0x4,%esp
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c002638d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026390:	83 c0 28             	add    $0x28,%eax
c0026393:	83 ec 0c             	sub    $0xc,%esp
c0026396:	50                   	push   %eax
c0026397:	e8 51 c5 ff ff       	call   c00228ed <sema_up>
c002639c:	83 c4 10             	add    $0x10,%esp
          }
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
c002639f:	eb 3d                	jmp    c00263de <interrupt_handler+0x92>
          printf ("%s: unexpected interrupt\n", c->name);
c00263a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00263a4:	83 ec 08             	sub    $0x8,%esp
c00263a7:	50                   	push   %eax
c00263a8:	68 10 02 03 c0       	push   $0xc0030210
c00263ad:	e8 ca 0d 00 00       	call   c002717c <printf>
c00263b2:	83 c4 10             	add    $0x10,%esp
        return;
c00263b5:	eb 27                	jmp    c00263de <interrupt_handler+0x92>
  for (c = channels; c < channels + CHANNEL_CNT; c++)
c00263b7:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
c00263bb:	b8 28 52 03 c0       	mov    $0xc0035228,%eax
c00263c0:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00263c3:	72 96                	jb     c002635b <interrupt_handler+0xf>
      }

  NOT_REACHED ();
c00263c5:	68 d8 00 03 c0       	push   $0xc00300d8
c00263ca:	68 88 02 03 c0       	push   $0xc0030288
c00263cf:	68 0c 02 00 00       	push   $0x20c
c00263d4:	68 fa 00 03 c0       	push   $0xc00300fa
c00263d9:	e8 40 31 00 00       	call   c002951e <debug_panic>
}
c00263de:	c9                   	leave  
c00263df:	c3                   	ret    

c00263e0 <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c00263e0:	55                   	push   %ebp
c00263e1:	89 e5                	mov    %esp,%ebp
c00263e3:	83 ec 08             	sub    $0x8,%esp
  intq_init (&buffer);
c00263e6:	83 ec 0c             	sub    $0xc,%esp
c00263e9:	68 40 52 03 c0       	push   $0xc0035240
c00263ee:	e8 03 01 00 00       	call   c00264f6 <intq_init>
c00263f3:	83 c4 10             	add    $0x10,%esp
}
c00263f6:	90                   	nop
c00263f7:	c9                   	leave  
c00263f8:	c3                   	ret    

c00263f9 <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c00263f9:	55                   	push   %ebp
c00263fa:	89 e5                	mov    %esp,%ebp
c00263fc:	83 ec 18             	sub    $0x18,%esp
c00263ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0026402:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0026405:	e8 25 af ff ff       	call   c002132f <intr_get_level>
c002640a:	85 c0                	test   %eax,%eax
c002640c:	74 1e                	je     c002642c <input_putc+0x33>
c002640e:	83 ec 0c             	sub    $0xc,%esp
c0026411:	68 9c 02 03 c0       	push   $0xc003029c
c0026416:	68 ba 02 03 c0       	push   $0xc00302ba
c002641b:	68 fc 02 03 c0       	push   $0xc00302fc
c0026420:	6a 15                	push   $0x15
c0026422:	68 d1 02 03 c0       	push   $0xc00302d1
c0026427:	e8 f2 30 00 00       	call   c002951e <debug_panic>
  ASSERT (!intq_full (&buffer));
c002642c:	83 ec 0c             	sub    $0xc,%esp
c002642f:	68 40 52 03 c0       	push   $0xc0035240
c0026434:	e8 41 01 00 00       	call   c002657a <intq_full>
c0026439:	83 c4 10             	add    $0x10,%esp
c002643c:	83 f0 01             	xor    $0x1,%eax
c002643f:	84 c0                	test   %al,%al
c0026441:	75 1e                	jne    c0026461 <input_putc+0x68>
c0026443:	83 ec 0c             	sub    $0xc,%esp
c0026446:	68 e7 02 03 c0       	push   $0xc00302e7
c002644b:	68 ba 02 03 c0       	push   $0xc00302ba
c0026450:	68 fc 02 03 c0       	push   $0xc00302fc
c0026455:	6a 16                	push   $0x16
c0026457:	68 d1 02 03 c0       	push   $0xc00302d1
c002645c:	e8 bd 30 00 00       	call   c002951e <debug_panic>

  intq_putc (&buffer, key);
c0026461:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0026465:	83 ec 08             	sub    $0x8,%esp
c0026468:	50                   	push   %eax
c0026469:	68 40 52 03 c0       	push   $0xc0035240
c002646e:	e8 31 02 00 00       	call   c00266a4 <intq_putc>
c0026473:	83 c4 10             	add    $0x10,%esp
  serial_notify ();
c0026476:	e8 1f e6 ff ff       	call   c0024a9a <serial_notify>
}
c002647b:	90                   	nop
c002647c:	c9                   	leave  
c002647d:	c3                   	ret    

c002647e <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c002647e:	55                   	push   %ebp
c002647f:	89 e5                	mov    %esp,%ebp
c0026481:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c0026484:	e8 14 af ff ff       	call   c002139d <intr_disable>
c0026489:	89 45 f4             	mov    %eax,-0xc(%ebp)
  key = intq_getc (&buffer);
c002648c:	83 ec 0c             	sub    $0xc,%esp
c002648f:	68 40 52 03 c0       	push   $0xc0035240
c0026494:	e8 2d 01 00 00       	call   c00265c6 <intq_getc>
c0026499:	83 c4 10             	add    $0x10,%esp
c002649c:	88 45 f3             	mov    %al,-0xd(%ebp)
  serial_notify ();
c002649f:	e8 f6 e5 ff ff       	call   c0024a9a <serial_notify>
  intr_set_level (old_level);
c00264a4:	83 ec 0c             	sub    $0xc,%esp
c00264a7:	ff 75 f4             	push   -0xc(%ebp)
c00264aa:	e8 96 ae ff ff       	call   c0021345 <intr_set_level>
c00264af:	83 c4 10             	add    $0x10,%esp
  
  return key;
c00264b2:	8a 45 f3             	mov    -0xd(%ebp),%al
}
c00264b5:	c9                   	leave  
c00264b6:	c3                   	ret    

c00264b7 <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c00264b7:	55                   	push   %ebp
c00264b8:	89 e5                	mov    %esp,%ebp
c00264ba:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00264bd:	e8 6d ae ff ff       	call   c002132f <intr_get_level>
c00264c2:	85 c0                	test   %eax,%eax
c00264c4:	74 1e                	je     c00264e4 <input_full+0x2d>
c00264c6:	83 ec 0c             	sub    $0xc,%esp
c00264c9:	68 9c 02 03 c0       	push   $0xc003029c
c00264ce:	68 ba 02 03 c0       	push   $0xc00302ba
c00264d3:	68 08 03 03 c0       	push   $0xc0030308
c00264d8:	6a 32                	push   $0x32
c00264da:	68 d1 02 03 c0       	push   $0xc00302d1
c00264df:	e8 3a 30 00 00       	call   c002951e <debug_panic>
  return intq_full (&buffer);
c00264e4:	83 ec 0c             	sub    $0xc,%esp
c00264e7:	68 40 52 03 c0       	push   $0xc0035240
c00264ec:	e8 89 00 00 00       	call   c002657a <intq_full>
c00264f1:	83 c4 10             	add    $0x10,%esp
}
c00264f4:	c9                   	leave  
c00264f5:	c3                   	ret    

c00264f6 <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c00264f6:	55                   	push   %ebp
c00264f7:	89 e5                	mov    %esp,%ebp
c00264f9:	83 ec 08             	sub    $0x8,%esp
  lock_init (&q->lock);
c00264fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00264ff:	83 ec 0c             	sub    $0xc,%esp
c0026502:	50                   	push   %eax
c0026503:	e8 4d c5 ff ff       	call   c0022a55 <lock_init>
c0026508:	83 c4 10             	add    $0x10,%esp
  q->not_full = q->not_empty = NULL;
c002650b:	8b 45 08             	mov    0x8(%ebp),%eax
c002650e:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
c0026515:	8b 45 08             	mov    0x8(%ebp),%eax
c0026518:	8b 50 1c             	mov    0x1c(%eax),%edx
c002651b:	8b 45 08             	mov    0x8(%ebp),%eax
c002651e:	89 50 18             	mov    %edx,0x18(%eax)
  q->head = q->tail = 0;
c0026521:	8b 45 08             	mov    0x8(%ebp),%eax
c0026524:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
c002652b:	8b 45 08             	mov    0x8(%ebp),%eax
c002652e:	8b 50 64             	mov    0x64(%eax),%edx
c0026531:	8b 45 08             	mov    0x8(%ebp),%eax
c0026534:	89 50 60             	mov    %edx,0x60(%eax)
}
c0026537:	90                   	nop
c0026538:	c9                   	leave  
c0026539:	c3                   	ret    

c002653a <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c002653a:	55                   	push   %ebp
c002653b:	89 e5                	mov    %esp,%ebp
c002653d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026540:	e8 ea ad ff ff       	call   c002132f <intr_get_level>
c0026545:	85 c0                	test   %eax,%eax
c0026547:	74 1e                	je     c0026567 <intq_empty+0x2d>
c0026549:	83 ec 0c             	sub    $0xc,%esp
c002654c:	68 14 03 03 c0       	push   $0xc0030314
c0026551:	68 32 03 03 c0       	push   $0xc0030332
c0026556:	68 28 04 03 c0       	push   $0xc0030428
c002655b:	6a 16                	push   $0x16
c002655d:	68 49 03 03 c0       	push   $0xc0030349
c0026562:	e8 b7 2f 00 00       	call   c002951e <debug_panic>
  return q->head == q->tail;
c0026567:	8b 45 08             	mov    0x8(%ebp),%eax
c002656a:	8b 50 60             	mov    0x60(%eax),%edx
c002656d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026570:	8b 40 64             	mov    0x64(%eax),%eax
c0026573:	39 c2                	cmp    %eax,%edx
c0026575:	0f 94 c0             	sete   %al
}
c0026578:	c9                   	leave  
c0026579:	c3                   	ret    

c002657a <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c002657a:	55                   	push   %ebp
c002657b:	89 e5                	mov    %esp,%ebp
c002657d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026580:	e8 aa ad ff ff       	call   c002132f <intr_get_level>
c0026585:	85 c0                	test   %eax,%eax
c0026587:	74 1e                	je     c00265a7 <intq_full+0x2d>
c0026589:	83 ec 0c             	sub    $0xc,%esp
c002658c:	68 14 03 03 c0       	push   $0xc0030314
c0026591:	68 32 03 03 c0       	push   $0xc0030332
c0026596:	68 34 04 03 c0       	push   $0xc0030434
c002659b:	6a 1e                	push   $0x1e
c002659d:	68 49 03 03 c0       	push   $0xc0030349
c00265a2:	e8 77 2f 00 00       	call   c002951e <debug_panic>
  return next (q->head) == q->tail;
c00265a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00265aa:	8b 40 60             	mov    0x60(%eax),%eax
c00265ad:	83 ec 0c             	sub    $0xc,%esp
c00265b0:	50                   	push   %eax
c00265b1:	e8 d0 01 00 00       	call   c0026786 <next>
c00265b6:	83 c4 10             	add    $0x10,%esp
c00265b9:	8b 55 08             	mov    0x8(%ebp),%edx
c00265bc:	8b 52 64             	mov    0x64(%edx),%edx
c00265bf:	39 d0                	cmp    %edx,%eax
c00265c1:	0f 94 c0             	sete   %al
}
c00265c4:	c9                   	leave  
c00265c5:	c3                   	ret    

c00265c6 <intq_getc>:
/* Removes a byte from Q and returns it.
   If Q is empty, sleeps until a byte is added.
   When called from an interrupt handler, Q must not be empty. */
uint8_t
intq_getc (struct intq *q) 
{
c00265c6:	55                   	push   %ebp
c00265c7:	89 e5                	mov    %esp,%ebp
c00265c9:	83 ec 18             	sub    $0x18,%esp
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
c00265cc:	e8 5e ad ff ff       	call   c002132f <intr_get_level>
c00265d1:	85 c0                	test   %eax,%eax
c00265d3:	74 7b                	je     c0026650 <intq_getc+0x8a>
c00265d5:	83 ec 0c             	sub    $0xc,%esp
c00265d8:	68 14 03 03 c0       	push   $0xc0030314
c00265dd:	68 32 03 03 c0       	push   $0xc0030332
c00265e2:	68 40 04 03 c0       	push   $0xc0030440
c00265e7:	6a 2a                	push   $0x2a
c00265e9:	68 49 03 03 c0       	push   $0xc0030349
c00265ee:	e8 2b 2f 00 00       	call   c002951e <debug_panic>
  while (intq_empty (q)) 
    {
      ASSERT (!intr_context ());
c00265f3:	e8 72 b0 ff ff       	call   c002166a <intr_context>
c00265f8:	83 f0 01             	xor    $0x1,%eax
c00265fb:	84 c0                	test   %al,%al
c00265fd:	75 1e                	jne    c002661d <intq_getc+0x57>
c00265ff:	83 ec 0c             	sub    $0xc,%esp
c0026602:	68 5e 03 03 c0       	push   $0xc003035e
c0026607:	68 32 03 03 c0       	push   $0xc0030332
c002660c:	68 40 04 03 c0       	push   $0xc0030440
c0026611:	6a 2d                	push   $0x2d
c0026613:	68 49 03 03 c0       	push   $0xc0030349
c0026618:	e8 01 2f 00 00       	call   c002951e <debug_panic>
      lock_acquire (&q->lock);
c002661d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026620:	83 ec 0c             	sub    $0xc,%esp
c0026623:	50                   	push   %eax
c0026624:	e8 79 c4 ff ff       	call   c0022aa2 <lock_acquire>
c0026629:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_empty);
c002662c:	8b 45 08             	mov    0x8(%ebp),%eax
c002662f:	83 c0 1c             	add    $0x1c,%eax
c0026632:	83 ec 08             	sub    $0x8,%esp
c0026635:	50                   	push   %eax
c0026636:	ff 75 08             	push   0x8(%ebp)
c0026639:	e8 5f 01 00 00       	call   c002679d <wait>
c002663e:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c0026641:	8b 45 08             	mov    0x8(%ebp),%eax
c0026644:	83 ec 0c             	sub    $0xc,%esp
c0026647:	50                   	push   %eax
c0026648:	e8 91 c5 ff ff       	call   c0022bde <lock_release>
c002664d:	83 c4 10             	add    $0x10,%esp
  while (intq_empty (q)) 
c0026650:	83 ec 0c             	sub    $0xc,%esp
c0026653:	ff 75 08             	push   0x8(%ebp)
c0026656:	e8 df fe ff ff       	call   c002653a <intq_empty>
c002665b:	83 c4 10             	add    $0x10,%esp
c002665e:	84 c0                	test   %al,%al
c0026660:	75 91                	jne    c00265f3 <intq_getc+0x2d>
    }
  
  byte = q->buf[q->tail];
c0026662:	8b 45 08             	mov    0x8(%ebp),%eax
c0026665:	8b 40 64             	mov    0x64(%eax),%eax
c0026668:	8b 55 08             	mov    0x8(%ebp),%edx
c002666b:	8a 44 02 20          	mov    0x20(%edx,%eax,1),%al
c002666f:	88 45 f7             	mov    %al,-0x9(%ebp)
  q->tail = next (q->tail);
c0026672:	8b 45 08             	mov    0x8(%ebp),%eax
c0026675:	8b 40 64             	mov    0x64(%eax),%eax
c0026678:	83 ec 0c             	sub    $0xc,%esp
c002667b:	50                   	push   %eax
c002667c:	e8 05 01 00 00       	call   c0026786 <next>
c0026681:	83 c4 10             	add    $0x10,%esp
c0026684:	8b 55 08             	mov    0x8(%ebp),%edx
c0026687:	89 42 64             	mov    %eax,0x64(%edx)
  signal (q, &q->not_full);
c002668a:	8b 45 08             	mov    0x8(%ebp),%eax
c002668d:	83 c0 18             	add    $0x18,%eax
c0026690:	83 ec 08             	sub    $0x8,%esp
c0026693:	50                   	push   %eax
c0026694:	ff 75 08             	push   0x8(%ebp)
c0026697:	e8 c2 01 00 00       	call   c002685e <signal>
c002669c:	83 c4 10             	add    $0x10,%esp
  return byte;
c002669f:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c00266a2:	c9                   	leave  
c00266a3:	c3                   	ret    

c00266a4 <intq_putc>:
/* Adds BYTE to the end of Q.
   If Q is full, sleeps until a byte is removed.
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
c00266a4:	55                   	push   %ebp
c00266a5:	89 e5                	mov    %esp,%ebp
c00266a7:	83 ec 18             	sub    $0x18,%esp
c00266aa:	8b 45 0c             	mov    0xc(%ebp),%eax
c00266ad:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c00266b0:	e8 7a ac ff ff       	call   c002132f <intr_get_level>
c00266b5:	85 c0                	test   %eax,%eax
c00266b7:	74 7b                	je     c0026734 <intq_putc+0x90>
c00266b9:	83 ec 0c             	sub    $0xc,%esp
c00266bc:	68 14 03 03 c0       	push   $0xc0030314
c00266c1:	68 32 03 03 c0       	push   $0xc0030332
c00266c6:	68 4c 04 03 c0       	push   $0xc003044c
c00266cb:	6a 3f                	push   $0x3f
c00266cd:	68 49 03 03 c0       	push   $0xc0030349
c00266d2:	e8 47 2e 00 00       	call   c002951e <debug_panic>
  while (intq_full (q))
    {
      ASSERT (!intr_context ());
c00266d7:	e8 8e af ff ff       	call   c002166a <intr_context>
c00266dc:	83 f0 01             	xor    $0x1,%eax
c00266df:	84 c0                	test   %al,%al
c00266e1:	75 1e                	jne    c0026701 <intq_putc+0x5d>
c00266e3:	83 ec 0c             	sub    $0xc,%esp
c00266e6:	68 5e 03 03 c0       	push   $0xc003035e
c00266eb:	68 32 03 03 c0       	push   $0xc0030332
c00266f0:	68 4c 04 03 c0       	push   $0xc003044c
c00266f5:	6a 42                	push   $0x42
c00266f7:	68 49 03 03 c0       	push   $0xc0030349
c00266fc:	e8 1d 2e 00 00       	call   c002951e <debug_panic>
      lock_acquire (&q->lock);
c0026701:	8b 45 08             	mov    0x8(%ebp),%eax
c0026704:	83 ec 0c             	sub    $0xc,%esp
c0026707:	50                   	push   %eax
c0026708:	e8 95 c3 ff ff       	call   c0022aa2 <lock_acquire>
c002670d:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_full);
c0026710:	8b 45 08             	mov    0x8(%ebp),%eax
c0026713:	83 c0 18             	add    $0x18,%eax
c0026716:	83 ec 08             	sub    $0x8,%esp
c0026719:	50                   	push   %eax
c002671a:	ff 75 08             	push   0x8(%ebp)
c002671d:	e8 7b 00 00 00       	call   c002679d <wait>
c0026722:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c0026725:	8b 45 08             	mov    0x8(%ebp),%eax
c0026728:	83 ec 0c             	sub    $0xc,%esp
c002672b:	50                   	push   %eax
c002672c:	e8 ad c4 ff ff       	call   c0022bde <lock_release>
c0026731:	83 c4 10             	add    $0x10,%esp
  while (intq_full (q))
c0026734:	83 ec 0c             	sub    $0xc,%esp
c0026737:	ff 75 08             	push   0x8(%ebp)
c002673a:	e8 3b fe ff ff       	call   c002657a <intq_full>
c002673f:	83 c4 10             	add    $0x10,%esp
c0026742:	84 c0                	test   %al,%al
c0026744:	75 91                	jne    c00266d7 <intq_putc+0x33>
    }

  q->buf[q->head] = byte;
c0026746:	8b 45 08             	mov    0x8(%ebp),%eax
c0026749:	8b 40 60             	mov    0x60(%eax),%eax
c002674c:	8b 55 08             	mov    0x8(%ebp),%edx
c002674f:	8a 4d f4             	mov    -0xc(%ebp),%cl
c0026752:	88 4c 02 20          	mov    %cl,0x20(%edx,%eax,1)
  q->head = next (q->head);
c0026756:	8b 45 08             	mov    0x8(%ebp),%eax
c0026759:	8b 40 60             	mov    0x60(%eax),%eax
c002675c:	83 ec 0c             	sub    $0xc,%esp
c002675f:	50                   	push   %eax
c0026760:	e8 21 00 00 00       	call   c0026786 <next>
c0026765:	83 c4 10             	add    $0x10,%esp
c0026768:	8b 55 08             	mov    0x8(%ebp),%edx
c002676b:	89 42 60             	mov    %eax,0x60(%edx)
  signal (q, &q->not_empty);
c002676e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026771:	83 c0 1c             	add    $0x1c,%eax
c0026774:	83 ec 08             	sub    $0x8,%esp
c0026777:	50                   	push   %eax
c0026778:	ff 75 08             	push   0x8(%ebp)
c002677b:	e8 de 00 00 00       	call   c002685e <signal>
c0026780:	83 c4 10             	add    $0x10,%esp
}
c0026783:	90                   	nop
c0026784:	c9                   	leave  
c0026785:	c3                   	ret    

c0026786 <next>:

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
c0026786:	55                   	push   %ebp
c0026787:	89 e5                	mov    %esp,%ebp
  return (pos + 1) % INTQ_BUFSIZE;
c0026789:	8b 45 08             	mov    0x8(%ebp),%eax
c002678c:	40                   	inc    %eax
c002678d:	25 3f 00 00 80       	and    $0x8000003f,%eax
c0026792:	85 c0                	test   %eax,%eax
c0026794:	79 05                	jns    c002679b <next+0x15>
c0026796:	48                   	dec    %eax
c0026797:	83 c8 c0             	or     $0xffffffc0,%eax
c002679a:	40                   	inc    %eax
}
c002679b:	5d                   	pop    %ebp
c002679c:	c3                   	ret    

c002679d <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c002679d:	55                   	push   %ebp
c002679e:	89 e5                	mov    %esp,%ebp
c00267a0:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c00267a3:	e8 c2 ae ff ff       	call   c002166a <intr_context>
c00267a8:	83 f0 01             	xor    $0x1,%eax
c00267ab:	84 c0                	test   %al,%al
c00267ad:	75 1e                	jne    c00267cd <wait+0x30>
c00267af:	83 ec 0c             	sub    $0xc,%esp
c00267b2:	68 5e 03 03 c0       	push   $0xc003035e
c00267b7:	68 32 03 03 c0       	push   $0xc0030332
c00267bc:	68 58 04 03 c0       	push   $0xc0030458
c00267c1:	6a 59                	push   $0x59
c00267c3:	68 49 03 03 c0       	push   $0xc0030349
c00267c8:	e8 51 2d 00 00       	call   c002951e <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c00267cd:	e8 5d ab ff ff       	call   c002132f <intr_get_level>
c00267d2:	85 c0                	test   %eax,%eax
c00267d4:	74 1e                	je     c00267f4 <wait+0x57>
c00267d6:	83 ec 0c             	sub    $0xc,%esp
c00267d9:	68 14 03 03 c0       	push   $0xc0030314
c00267de:	68 32 03 03 c0       	push   $0xc0030332
c00267e3:	68 58 04 03 c0       	push   $0xc0030458
c00267e8:	6a 5a                	push   $0x5a
c00267ea:	68 49 03 03 c0       	push   $0xc0030349
c00267ef:	e8 2a 2d 00 00       	call   c002951e <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c00267f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00267f7:	83 c0 1c             	add    $0x1c,%eax
c00267fa:	39 45 0c             	cmp    %eax,0xc(%ebp)
c00267fd:	75 12                	jne    c0026811 <wait+0x74>
c00267ff:	83 ec 0c             	sub    $0xc,%esp
c0026802:	ff 75 08             	push   0x8(%ebp)
c0026805:	e8 30 fd ff ff       	call   c002653a <intq_empty>
c002680a:	83 c4 10             	add    $0x10,%esp
c002680d:	84 c0                	test   %al,%al
c002680f:	75 3b                	jne    c002684c <wait+0xaf>
c0026811:	8b 45 08             	mov    0x8(%ebp),%eax
c0026814:	83 c0 18             	add    $0x18,%eax
c0026817:	39 45 0c             	cmp    %eax,0xc(%ebp)
c002681a:	75 12                	jne    c002682e <wait+0x91>
c002681c:	83 ec 0c             	sub    $0xc,%esp
c002681f:	ff 75 08             	push   0x8(%ebp)
c0026822:	e8 53 fd ff ff       	call   c002657a <intq_full>
c0026827:	83 c4 10             	add    $0x10,%esp
c002682a:	84 c0                	test   %al,%al
c002682c:	75 1e                	jne    c002684c <wait+0xaf>
c002682e:	83 ec 0c             	sub    $0xc,%esp
c0026831:	68 70 03 03 c0       	push   $0xc0030370
c0026836:	68 32 03 03 c0       	push   $0xc0030332
c002683b:	68 58 04 03 c0       	push   $0xc0030458
c0026840:	6a 5b                	push   $0x5b
c0026842:	68 49 03 03 c0       	push   $0xc0030349
c0026847:	e8 d2 2c 00 00       	call   c002951e <debug_panic>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c002684c:	e8 27 a4 ff ff       	call   c0020c78 <thread_current>
c0026851:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026854:	89 02                	mov    %eax,(%edx)
  thread_block ();
c0026856:	e8 fd a2 ff ff       	call   c0020b58 <thread_block>
}
c002685b:	90                   	nop
c002685c:	c9                   	leave  
c002685d:	c3                   	ret    

c002685e <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c002685e:	55                   	push   %ebp
c002685f:	89 e5                	mov    %esp,%ebp
c0026861:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026864:	e8 c6 aa ff ff       	call   c002132f <intr_get_level>
c0026869:	85 c0                	test   %eax,%eax
c002686b:	74 1e                	je     c002688b <signal+0x2d>
c002686d:	83 ec 0c             	sub    $0xc,%esp
c0026870:	68 14 03 03 c0       	push   $0xc0030314
c0026875:	68 32 03 03 c0       	push   $0xc0030332
c002687a:	68 60 04 03 c0       	push   $0xc0030460
c002687f:	6a 69                	push   $0x69
c0026881:	68 49 03 03 c0       	push   $0xc0030349
c0026886:	e8 93 2c 00 00       	call   c002951e <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c002688b:	8b 45 08             	mov    0x8(%ebp),%eax
c002688e:	83 c0 1c             	add    $0x1c,%eax
c0026891:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0026894:	75 15                	jne    c00268ab <signal+0x4d>
c0026896:	83 ec 0c             	sub    $0xc,%esp
c0026899:	ff 75 08             	push   0x8(%ebp)
c002689c:	e8 99 fc ff ff       	call   c002653a <intq_empty>
c00268a1:	83 c4 10             	add    $0x10,%esp
c00268a4:	83 f0 01             	xor    $0x1,%eax
c00268a7:	84 c0                	test   %al,%al
c00268a9:	75 3e                	jne    c00268e9 <signal+0x8b>
c00268ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00268ae:	83 c0 18             	add    $0x18,%eax
c00268b1:	39 45 0c             	cmp    %eax,0xc(%ebp)
c00268b4:	75 15                	jne    c00268cb <signal+0x6d>
c00268b6:	83 ec 0c             	sub    $0xc,%esp
c00268b9:	ff 75 08             	push   0x8(%ebp)
c00268bc:	e8 b9 fc ff ff       	call   c002657a <intq_full>
c00268c1:	83 c4 10             	add    $0x10,%esp
c00268c4:	83 f0 01             	xor    $0x1,%eax
c00268c7:	84 c0                	test   %al,%al
c00268c9:	75 1e                	jne    c00268e9 <signal+0x8b>
c00268cb:	83 ec 0c             	sub    $0xc,%esp
c00268ce:	68 cc 03 03 c0       	push   $0xc00303cc
c00268d3:	68 32 03 03 c0       	push   $0xc0030332
c00268d8:	68 60 04 03 c0       	push   $0xc0030460
c00268dd:	6a 6a                	push   $0x6a
c00268df:	68 49 03 03 c0       	push   $0xc0030349
c00268e4:	e8 35 2c 00 00       	call   c002951e <debug_panic>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c00268e9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00268ec:	8b 00                	mov    (%eax),%eax
c00268ee:	85 c0                	test   %eax,%eax
c00268f0:	74 1a                	je     c002690c <signal+0xae>
    {
      thread_unblock (*waiter);
c00268f2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00268f5:	8b 00                	mov    (%eax),%eax
c00268f7:	83 ec 0c             	sub    $0xc,%esp
c00268fa:	50                   	push   %eax
c00268fb:	e8 c9 a2 ff ff       	call   c0020bc9 <thread_unblock>
c0026900:	83 c4 10             	add    $0x10,%esp
      *waiter = NULL;
c0026903:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026906:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
c002690c:	90                   	nop
c002690d:	c9                   	leave  
c002690e:	c3                   	ret    

c002690f <inb>:
{
c002690f:	55                   	push   %ebp
c0026910:	89 e5                	mov    %esp,%ebp
c0026912:	83 ec 14             	sub    $0x14,%esp
c0026915:	8b 45 08             	mov    0x8(%ebp),%eax
c0026918:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002691c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002691f:	89 c2                	mov    %eax,%edx
c0026921:	ec                   	in     (%dx),%al
c0026922:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026925:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0026928:	c9                   	leave  
c0026929:	c3                   	ret    

c002692a <outb>:
{
c002692a:	55                   	push   %ebp
c002692b:	89 e5                	mov    %esp,%ebp
c002692d:	83 ec 08             	sub    $0x8,%esp
c0026930:	8b 45 08             	mov    0x8(%ebp),%eax
c0026933:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026936:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c002693a:	88 d0                	mov    %dl,%al
c002693c:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002693f:	8a 45 f8             	mov    -0x8(%ebp),%al
c0026942:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026945:	ee                   	out    %al,(%dx)
}
c0026946:	90                   	nop
c0026947:	c9                   	leave  
c0026948:	c3                   	ret    

c0026949 <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c0026949:	55                   	push   %ebp
c002694a:	89 e5                	mov    %esp,%ebp
c002694c:	83 ec 28             	sub    $0x28,%esp
     but for historical reasons everyone always uses BCD format
     except on obscure non-PC platforms, so we don't bother
     trying to detect the format in use. */
  do
    {
      sec = bcd_to_bin (cmos_read (RTC_REG_SEC));
c002694f:	83 ec 0c             	sub    $0xc,%esp
c0026952:	6a 00                	push   $0x0
c0026954:	e8 01 02 00 00       	call   c0026b5a <cmos_read>
c0026959:	83 c4 10             	add    $0x10,%esp
c002695c:	0f b6 c0             	movzbl %al,%eax
c002695f:	83 ec 0c             	sub    $0xc,%esp
c0026962:	50                   	push   %eax
c0026963:	e8 c7 01 00 00       	call   c0026b2f <bcd_to_bin>
c0026968:	83 c4 10             	add    $0x10,%esp
c002696b:	89 45 e8             	mov    %eax,-0x18(%ebp)
      min = bcd_to_bin (cmos_read (RTC_REG_MIN));
c002696e:	83 ec 0c             	sub    $0xc,%esp
c0026971:	6a 02                	push   $0x2
c0026973:	e8 e2 01 00 00       	call   c0026b5a <cmos_read>
c0026978:	83 c4 10             	add    $0x10,%esp
c002697b:	0f b6 c0             	movzbl %al,%eax
c002697e:	83 ec 0c             	sub    $0xc,%esp
c0026981:	50                   	push   %eax
c0026982:	e8 a8 01 00 00       	call   c0026b2f <bcd_to_bin>
c0026987:	83 c4 10             	add    $0x10,%esp
c002698a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      hour = bcd_to_bin (cmos_read (RTC_REG_HOUR));
c002698d:	83 ec 0c             	sub    $0xc,%esp
c0026990:	6a 04                	push   $0x4
c0026992:	e8 c3 01 00 00       	call   c0026b5a <cmos_read>
c0026997:	83 c4 10             	add    $0x10,%esp
c002699a:	0f b6 c0             	movzbl %al,%eax
c002699d:	83 ec 0c             	sub    $0xc,%esp
c00269a0:	50                   	push   %eax
c00269a1:	e8 89 01 00 00       	call   c0026b2f <bcd_to_bin>
c00269a6:	83 c4 10             	add    $0x10,%esp
c00269a9:	89 45 e0             	mov    %eax,-0x20(%ebp)
      mday = bcd_to_bin (cmos_read (RTC_REG_MDAY));
c00269ac:	83 ec 0c             	sub    $0xc,%esp
c00269af:	6a 07                	push   $0x7
c00269b1:	e8 a4 01 00 00       	call   c0026b5a <cmos_read>
c00269b6:	83 c4 10             	add    $0x10,%esp
c00269b9:	0f b6 c0             	movzbl %al,%eax
c00269bc:	83 ec 0c             	sub    $0xc,%esp
c00269bf:	50                   	push   %eax
c00269c0:	e8 6a 01 00 00       	call   c0026b2f <bcd_to_bin>
c00269c5:	83 c4 10             	add    $0x10,%esp
c00269c8:	89 45 dc             	mov    %eax,-0x24(%ebp)
      mon = bcd_to_bin (cmos_read (RTC_REG_MON));
c00269cb:	83 ec 0c             	sub    $0xc,%esp
c00269ce:	6a 08                	push   $0x8
c00269d0:	e8 85 01 00 00       	call   c0026b5a <cmos_read>
c00269d5:	83 c4 10             	add    $0x10,%esp
c00269d8:	0f b6 c0             	movzbl %al,%eax
c00269db:	83 ec 0c             	sub    $0xc,%esp
c00269de:	50                   	push   %eax
c00269df:	e8 4b 01 00 00       	call   c0026b2f <bcd_to_bin>
c00269e4:	83 c4 10             	add    $0x10,%esp
c00269e7:	89 45 d8             	mov    %eax,-0x28(%ebp)
      year = bcd_to_bin (cmos_read (RTC_REG_YEAR));
c00269ea:	83 ec 0c             	sub    $0xc,%esp
c00269ed:	6a 09                	push   $0x9
c00269ef:	e8 66 01 00 00       	call   c0026b5a <cmos_read>
c00269f4:	83 c4 10             	add    $0x10,%esp
c00269f7:	0f b6 c0             	movzbl %al,%eax
c00269fa:	83 ec 0c             	sub    $0xc,%esp
c00269fd:	50                   	push   %eax
c00269fe:	e8 2c 01 00 00       	call   c0026b2f <bcd_to_bin>
c0026a03:	83 c4 10             	add    $0x10,%esp
c0026a06:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c0026a09:	83 ec 0c             	sub    $0xc,%esp
c0026a0c:	6a 00                	push   $0x0
c0026a0e:	e8 47 01 00 00       	call   c0026b5a <cmos_read>
c0026a13:	83 c4 10             	add    $0x10,%esp
c0026a16:	0f b6 c0             	movzbl %al,%eax
c0026a19:	83 ec 0c             	sub    $0xc,%esp
c0026a1c:	50                   	push   %eax
c0026a1d:	e8 0d 01 00 00       	call   c0026b2f <bcd_to_bin>
c0026a22:	83 c4 10             	add    $0x10,%esp
c0026a25:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c0026a28:	0f 85 21 ff ff ff    	jne    c002694f <rtc_get_time+0x6>

  /* Translate years-since-1900 into years-since-1970.
     If it's before the epoch, assume that it has passed 2000.
     This will break at 2070, but that's long after our 31-bit
     time_t breaks in 2038. */
  if (year < 70)
c0026a2e:	83 7d f4 45          	cmpl   $0x45,-0xc(%ebp)
c0026a32:	7f 04                	jg     c0026a38 <rtc_get_time+0xef>
    year += 100;
c0026a34:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
  year -= 70;
c0026a38:	83 6d f4 46          	subl   $0x46,-0xc(%ebp)

  /* Break down all components into seconds. */
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0026a3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0026a3f:	89 d0                	mov    %edx,%eax
c0026a41:	c1 e0 03             	shl    $0x3,%eax
c0026a44:	01 d0                	add    %edx,%eax
c0026a46:	c1 e0 03             	shl    $0x3,%eax
c0026a49:	01 d0                	add    %edx,%eax
c0026a4b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0026a52:	01 c2                	add    %eax,%edx
c0026a54:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026a57:	48                   	dec    %eax
c0026a58:	85 c0                	test   %eax,%eax
c0026a5a:	79 03                	jns    c0026a5f <rtc_get_time+0x116>
c0026a5c:	83 c0 03             	add    $0x3,%eax
c0026a5f:	c1 f8 02             	sar    $0x2,%eax
c0026a62:	01 c2                	add    %eax,%edx
c0026a64:	89 d0                	mov    %edx,%eax
c0026a66:	c1 e0 02             	shl    $0x2,%eax
c0026a69:	01 d0                	add    %edx,%eax
c0026a6b:	c1 e0 02             	shl    $0x2,%eax
c0026a6e:	01 d0                	add    %edx,%eax
c0026a70:	c1 e0 03             	shl    $0x3,%eax
c0026a73:	01 d0                	add    %edx,%eax
c0026a75:	c1 e0 02             	shl    $0x2,%eax
c0026a78:	29 d0                	sub    %edx,%eax
c0026a7a:	c1 e0 07             	shl    $0x7,%eax
c0026a7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (i = 1; i <= mon; i++)
c0026a80:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
c0026a87:	eb 2a                	jmp    c0026ab3 <rtc_get_time+0x16a>
    time += days_per_month[i - 1] * 24 * 60 * 60;
c0026a89:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026a8c:	48                   	dec    %eax
c0026a8d:	8b 14 85 80 04 03 c0 	mov    -0x3ffcfb80(,%eax,4),%edx
c0026a94:	89 d0                	mov    %edx,%eax
c0026a96:	c1 e0 02             	shl    $0x2,%eax
c0026a99:	01 d0                	add    %edx,%eax
c0026a9b:	c1 e0 02             	shl    $0x2,%eax
c0026a9e:	01 d0                	add    %edx,%eax
c0026aa0:	c1 e0 03             	shl    $0x3,%eax
c0026aa3:	01 d0                	add    %edx,%eax
c0026aa5:	c1 e0 02             	shl    $0x2,%eax
c0026aa8:	29 d0                	sub    %edx,%eax
c0026aaa:	c1 e0 07             	shl    $0x7,%eax
c0026aad:	01 45 f0             	add    %eax,-0x10(%ebp)
  for (i = 1; i <= mon; i++)
c0026ab0:	ff 45 ec             	incl   -0x14(%ebp)
c0026ab3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026ab6:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c0026ab9:	7e ce                	jle    c0026a89 <rtc_get_time+0x140>
  if (mon > 2 && year % 4 == 0)
c0026abb:	83 7d d8 02          	cmpl   $0x2,-0x28(%ebp)
c0026abf:	7e 11                	jle    c0026ad2 <rtc_get_time+0x189>
c0026ac1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026ac4:	83 e0 03             	and    $0x3,%eax
c0026ac7:	85 c0                	test   %eax,%eax
c0026ac9:	75 07                	jne    c0026ad2 <rtc_get_time+0x189>
    time += 24 * 60 * 60;
c0026acb:	81 45 f0 80 51 01 00 	addl   $0x15180,-0x10(%ebp)
  time += (mday - 1) * 24 * 60 * 60;
c0026ad2:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0026ad5:	8d 50 ff             	lea    -0x1(%eax),%edx
c0026ad8:	89 d0                	mov    %edx,%eax
c0026ada:	c1 e0 02             	shl    $0x2,%eax
c0026add:	01 d0                	add    %edx,%eax
c0026adf:	c1 e0 02             	shl    $0x2,%eax
c0026ae2:	01 d0                	add    %edx,%eax
c0026ae4:	c1 e0 03             	shl    $0x3,%eax
c0026ae7:	01 d0                	add    %edx,%eax
c0026ae9:	c1 e0 02             	shl    $0x2,%eax
c0026aec:	29 d0                	sub    %edx,%eax
c0026aee:	c1 e0 07             	shl    $0x7,%eax
c0026af1:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += hour * 60 * 60;
c0026af4:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0026af7:	89 d0                	mov    %edx,%eax
c0026af9:	01 c0                	add    %eax,%eax
c0026afb:	01 d0                	add    %edx,%eax
c0026afd:	01 c0                	add    %eax,%eax
c0026aff:	01 d0                	add    %edx,%eax
c0026b01:	c1 e0 05             	shl    $0x5,%eax
c0026b04:	01 d0                	add    %edx,%eax
c0026b06:	c1 e0 04             	shl    $0x4,%eax
c0026b09:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += min * 60;
c0026b0c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0026b0f:	89 d0                	mov    %edx,%eax
c0026b11:	01 c0                	add    %eax,%eax
c0026b13:	01 d0                	add    %edx,%eax
c0026b15:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0026b1c:	01 d0                	add    %edx,%eax
c0026b1e:	c1 e0 02             	shl    $0x2,%eax
c0026b21:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += sec;
c0026b24:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0026b27:	01 45 f0             	add    %eax,-0x10(%ebp)

  return time;
c0026b2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0026b2d:	c9                   	leave  
c0026b2e:	c3                   	ret    

c0026b2f <bcd_to_bin>:

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
c0026b2f:	55                   	push   %ebp
c0026b30:	89 e5                	mov    %esp,%ebp
c0026b32:	83 ec 04             	sub    $0x4,%esp
c0026b35:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b38:	88 45 fc             	mov    %al,-0x4(%ebp)
  return (x & 0x0f) + ((x >> 4) * 10);
c0026b3b:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0026b3f:	83 e0 0f             	and    $0xf,%eax
c0026b42:	89 c1                	mov    %eax,%ecx
c0026b44:	8a 45 fc             	mov    -0x4(%ebp),%al
c0026b47:	c0 e8 04             	shr    $0x4,%al
c0026b4a:	0f b6 d0             	movzbl %al,%edx
c0026b4d:	89 d0                	mov    %edx,%eax
c0026b4f:	c1 e0 02             	shl    $0x2,%eax
c0026b52:	01 d0                	add    %edx,%eax
c0026b54:	01 c0                	add    %eax,%eax
c0026b56:	01 c8                	add    %ecx,%eax
}
c0026b58:	c9                   	leave  
c0026b59:	c3                   	ret    

c0026b5a <cmos_read>:

/* Reads a byte from the CMOS register with the given INDEX and
   returns the byte read. */
static uint8_t
cmos_read (uint8_t index)
{
c0026b5a:	55                   	push   %ebp
c0026b5b:	89 e5                	mov    %esp,%ebp
c0026b5d:	83 ec 04             	sub    $0x4,%esp
c0026b60:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b63:	88 45 fc             	mov    %al,-0x4(%ebp)
  outb (CMOS_REG_SET, index);
c0026b66:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0026b6a:	50                   	push   %eax
c0026b6b:	6a 70                	push   $0x70
c0026b6d:	e8 b8 fd ff ff       	call   c002692a <outb>
c0026b72:	83 c4 08             	add    $0x8,%esp
  return inb (CMOS_REG_IO);
c0026b75:	6a 71                	push   $0x71
c0026b77:	e8 93 fd ff ff       	call   c002690f <inb>
c0026b7c:	83 c4 04             	add    $0x4,%esp
}
c0026b7f:	c9                   	leave  
c0026b80:	c3                   	ret    

c0026b81 <inb>:
{
c0026b81:	55                   	push   %ebp
c0026b82:	89 e5                	mov    %esp,%ebp
c0026b84:	83 ec 14             	sub    $0x14,%esp
c0026b87:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b8a:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026b91:	89 c2                	mov    %eax,%edx
c0026b93:	ec                   	in     (%dx),%al
c0026b94:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026b97:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0026b9a:	c9                   	leave  
c0026b9b:	c3                   	ret    

c0026b9c <outb>:
{
c0026b9c:	55                   	push   %ebp
c0026b9d:	89 e5                	mov    %esp,%ebp
c0026b9f:	83 ec 08             	sub    $0x8,%esp
c0026ba2:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ba5:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026ba8:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0026bac:	88 d0                	mov    %dl,%al
c0026bae:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026bb1:	8a 45 f8             	mov    -0x8(%ebp),%al
c0026bb4:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026bb7:	ee                   	out    %al,(%dx)
}
c0026bb8:	90                   	nop
c0026bb9:	c9                   	leave  
c0026bba:	c3                   	ret    

c0026bbb <outw>:
{
c0026bbb:	55                   	push   %ebp
c0026bbc:	89 e5                	mov    %esp,%ebp
c0026bbe:	83 ec 08             	sub    $0x8,%esp
c0026bc1:	8b 55 08             	mov    0x8(%ebp),%edx
c0026bc4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026bc7:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0026bcb:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0026bcf:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0026bd2:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026bd5:	66 ef                	out    %ax,(%dx)
}
c0026bd7:	90                   	nop
c0026bd8:	c9                   	leave  
c0026bd9:	c3                   	ret    

c0026bda <shutdown>:
/* Shuts down the machine in the way configured by
   shutdown_configure().  If the shutdown type is SHUTDOWN_NONE
   (which is the default), returns without doing anything. */
void
shutdown (void)
{
c0026bda:	55                   	push   %ebp
c0026bdb:	89 e5                	mov    %esp,%ebp
c0026bdd:	83 ec 08             	sub    $0x8,%esp
  switch (how)
c0026be0:	a1 a8 52 03 c0       	mov    0xc00352a8,%eax
c0026be5:	83 f8 01             	cmp    $0x1,%eax
c0026be8:	74 07                	je     c0026bf1 <shutdown+0x17>
c0026bea:	83 f8 02             	cmp    $0x2,%eax
c0026bed:	74 07                	je     c0026bf6 <shutdown+0x1c>
      shutdown_reboot ();
      break;

    default:
      /* Nothing to do. */
      break;
c0026bef:	eb 0a                	jmp    c0026bfb <shutdown+0x21>
      shutdown_power_off ();
c0026bf1:	e8 9c 00 00 00       	call   c0026c92 <shutdown_power_off>
      shutdown_reboot ();
c0026bf6:	e8 11 00 00 00       	call   c0026c0c <shutdown_reboot>
    }
}
c0026bfb:	90                   	nop
c0026bfc:	c9                   	leave  
c0026bfd:	c3                   	ret    

c0026bfe <shutdown_configure>:

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
c0026bfe:	55                   	push   %ebp
c0026bff:	89 e5                	mov    %esp,%ebp
  how = type;
c0026c01:	8b 45 08             	mov    0x8(%ebp),%eax
c0026c04:	a3 a8 52 03 c0       	mov    %eax,0xc00352a8
}
c0026c09:	90                   	nop
c0026c0a:	5d                   	pop    %ebp
c0026c0b:	c3                   	ret    

c0026c0c <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c0026c0c:	55                   	push   %ebp
c0026c0d:	89 e5                	mov    %esp,%ebp
c0026c0f:	83 ec 18             	sub    $0x18,%esp
  printf ("Rebooting...\n");
c0026c12:	83 ec 0c             	sub    $0xc,%esp
c0026c15:	68 b0 04 03 c0       	push   $0xc00304b0
c0026c1a:	e8 c4 4a 00 00       	call   c002b6e3 <puts>
c0026c1f:	83 c4 10             	add    $0x10,%esp
    {
      int i;

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
c0026c22:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0026c29:	eb 29                	jmp    c0026c54 <shutdown_reboot+0x48>
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0026c2b:	83 ec 0c             	sub    $0xc,%esp
c0026c2e:	6a 64                	push   $0x64
c0026c30:	e8 4c ff ff ff       	call   c0026b81 <inb>
c0026c35:	83 c4 10             	add    $0x10,%esp
c0026c38:	0f b6 c0             	movzbl %al,%eax
c0026c3b:	83 e0 02             	and    $0x2,%eax
c0026c3e:	85 c0                	test   %eax,%eax
c0026c40:	74 1d                	je     c0026c5f <shutdown_reboot+0x53>
            break;
          timer_udelay (2);
c0026c42:	83 ec 08             	sub    $0x8,%esp
c0026c45:	6a 00                	push   $0x0
c0026c47:	6a 02                	push   $0x2
c0026c49:	e8 c5 d1 ff ff       	call   c0023e13 <timer_udelay>
c0026c4e:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 0x10000; i++)
c0026c51:	ff 45 f4             	incl   -0xc(%ebp)
c0026c54:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
c0026c5b:	7e ce                	jle    c0026c2b <shutdown_reboot+0x1f>
c0026c5d:	eb 01                	jmp    c0026c60 <shutdown_reboot+0x54>
            break;
c0026c5f:	90                   	nop
        }

      timer_udelay (50);
c0026c60:	83 ec 08             	sub    $0x8,%esp
c0026c63:	6a 00                	push   $0x0
c0026c65:	6a 32                	push   $0x32
c0026c67:	e8 a7 d1 ff ff       	call   c0023e13 <timer_udelay>
c0026c6c:	83 c4 10             	add    $0x10,%esp

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
c0026c6f:	83 ec 08             	sub    $0x8,%esp
c0026c72:	68 fe 00 00 00       	push   $0xfe
c0026c77:	6a 64                	push   $0x64
c0026c79:	e8 1e ff ff ff       	call   c0026b9c <outb>
c0026c7e:	83 c4 10             	add    $0x10,%esp
      timer_udelay (50);
c0026c81:	83 ec 08             	sub    $0x8,%esp
c0026c84:	6a 00                	push   $0x0
c0026c86:	6a 32                	push   $0x32
c0026c88:	e8 86 d1 ff ff       	call   c0023e13 <timer_udelay>
c0026c8d:	83 c4 10             	add    $0x10,%esp
    {
c0026c90:	eb 90                	jmp    c0026c22 <shutdown_reboot+0x16>

c0026c92 <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c0026c92:	55                   	push   %ebp
c0026c93:	89 e5                	mov    %esp,%ebp
c0026c95:	57                   	push   %edi
c0026c96:	56                   	push   %esi
c0026c97:	53                   	push   %ebx
c0026c98:	83 ec 1c             	sub    $0x1c,%esp
  const char s[] = "Shutdown";
c0026c9b:	8d 45 db             	lea    -0x25(%ebp),%eax
c0026c9e:	bb de 04 03 c0       	mov    $0xc00304de,%ebx
c0026ca3:	ba 09 00 00 00       	mov    $0x9,%edx
c0026ca8:	89 c7                	mov    %eax,%edi
c0026caa:	89 de                	mov    %ebx,%esi
c0026cac:	89 d1                	mov    %edx,%ecx
c0026cae:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)

#ifdef FILESYS
  filesys_done ();
#endif

  print_stats ();
c0026cb0:	e8 7d 00 00 00       	call   c0026d32 <print_stats>

  printf ("Powering off...\n");
c0026cb5:	83 ec 0c             	sub    $0xc,%esp
c0026cb8:	68 bd 04 03 c0       	push   $0xc00304bd
c0026cbd:	e8 21 4a 00 00       	call   c002b6e3 <puts>
c0026cc2:	83 c4 10             	add    $0x10,%esp
  serial_flush ();
c0026cc5:	e8 79 dd ff ff       	call   c0024a43 <serial_flush>

  /* ACPI power-off */
  outw (0xB004, 0x2000);
c0026cca:	83 ec 08             	sub    $0x8,%esp
c0026ccd:	68 00 20 00 00       	push   $0x2000
c0026cd2:	68 04 b0 00 00       	push   $0xb004
c0026cd7:	e8 df fe ff ff       	call   c0026bbb <outw>
c0026cdc:	83 c4 10             	add    $0x10,%esp

  /* This is a special power-off sequence supported by Bochs and
     QEMU, but not by physical hardware. */
  for (p = s; *p != '\0'; p++)
c0026cdf:	8d 45 db             	lea    -0x25(%ebp),%eax
c0026ce2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0026ce5:	eb 1c                	jmp    c0026d03 <shutdown_power_off+0x71>
    outb (0x8900, *p);
c0026ce7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0026cea:	8a 00                	mov    (%eax),%al
c0026cec:	0f b6 c0             	movzbl %al,%eax
c0026cef:	83 ec 08             	sub    $0x8,%esp
c0026cf2:	50                   	push   %eax
c0026cf3:	68 00 89 00 00       	push   $0x8900
c0026cf8:	e8 9f fe ff ff       	call   c0026b9c <outb>
c0026cfd:	83 c4 10             	add    $0x10,%esp
  for (p = s; *p != '\0'; p++)
c0026d00:	ff 45 e4             	incl   -0x1c(%ebp)
c0026d03:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0026d06:	8a 00                	mov    (%eax),%al
c0026d08:	84 c0                	test   %al,%al
c0026d0a:	75 db                	jne    c0026ce7 <shutdown_power_off+0x55>
  /* For newer versions of qemu, you must run with -device
   * isa-debug-exit, which exits on any write to an IO port (by
   * default 0x501).  Qemu's exit code is double the value plus one,
   * so there is no way to exit cleanly.  We use 0x31 which should
   * result in a qemu exit code of 0x63.  */
  outb (0x501, 0x31);
c0026d0c:	83 ec 08             	sub    $0x8,%esp
c0026d0f:	6a 31                	push   $0x31
c0026d11:	68 01 05 00 00       	push   $0x501
c0026d16:	e8 81 fe ff ff       	call   c0026b9c <outb>
c0026d1b:	83 c4 10             	add    $0x10,%esp

  /* This will power off a VMware VM if "gui.exitOnCLIHLT = TRUE"
     is set in its configuration file.  (The "pintos" script does
     that automatically.)  */
  asm volatile ("cli; hlt" : : : "memory");
c0026d1e:	fa                   	cli    
c0026d1f:	f4                   	hlt    

  /* None of those worked. */
  printf ("still running...\n");
c0026d20:	83 ec 0c             	sub    $0xc,%esp
c0026d23:	68 cd 04 03 c0       	push   $0xc00304cd
c0026d28:	e8 b6 49 00 00       	call   c002b6e3 <puts>
c0026d2d:	83 c4 10             	add    $0x10,%esp
  for (;;);
c0026d30:	eb fe                	jmp    c0026d30 <shutdown_power_off+0x9e>

c0026d32 <print_stats>:
}

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
c0026d32:	55                   	push   %ebp
c0026d33:	89 e5                	mov    %esp,%ebp
c0026d35:	83 ec 08             	sub    $0x8,%esp
  timer_print_stats ();
c0026d38:	e8 2c d1 ff ff       	call   c0023e69 <timer_print_stats>
  thread_print_stats ();
c0026d3d:	e8 d4 9c ff ff       	call   c0020a16 <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
#endif
  console_print_stats ();
c0026d42:	e8 70 48 00 00       	call   c002b5b7 <console_print_stats>
  kbd_print_stats ();
c0026d47:	e8 2c d4 ff ff       	call   c0024178 <kbd_print_stats>
#ifdef USERPROG
  exception_print_stats ();
#endif
}
c0026d4c:	90                   	nop
c0026d4d:	c9                   	leave  
c0026d4e:	c3                   	ret    

c0026d4f <inb>:
{
c0026d4f:	55                   	push   %ebp
c0026d50:	89 e5                	mov    %esp,%ebp
c0026d52:	83 ec 14             	sub    $0x14,%esp
c0026d55:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d58:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026d5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026d5f:	89 c2                	mov    %eax,%edx
c0026d61:	ec                   	in     (%dx),%al
c0026d62:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026d65:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0026d68:	c9                   	leave  
c0026d69:	c3                   	ret    

c0026d6a <outb>:
{
c0026d6a:	55                   	push   %ebp
c0026d6b:	89 e5                	mov    %esp,%ebp
c0026d6d:	83 ec 08             	sub    $0x8,%esp
c0026d70:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d73:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026d76:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0026d7a:	88 d0                	mov    %dl,%al
c0026d7c:	88 45 f8             	mov    %al,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026d7f:	8a 45 f8             	mov    -0x8(%ebp),%al
c0026d82:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026d85:	ee                   	out    %al,(%dx)
}
c0026d86:	90                   	nop
c0026d87:	c9                   	leave  
c0026d88:	c3                   	ret    

c0026d89 <speaker_on>:

/* Sets the PC speaker to emit a tone at the given FREQUENCY, in
   Hz. */
void
speaker_on (int frequency)
{
c0026d89:	55                   	push   %ebp
c0026d8a:	89 e5                	mov    %esp,%ebp
c0026d8c:	83 ec 18             	sub    $0x18,%esp
  if (frequency >= 20 && frequency <= 20000)
c0026d8f:	83 7d 08 13          	cmpl   $0x13,0x8(%ebp)
c0026d93:	7e 54                	jle    c0026de9 <speaker_on+0x60>
c0026d95:	81 7d 08 20 4e 00 00 	cmpl   $0x4e20,0x8(%ebp)
c0026d9c:	7f 4b                	jg     c0026de9 <speaker_on+0x60>
    {
      /* Set the timer channel that's connected to the speaker to
         output a square wave at the given FREQUENCY, then
         connect the timer channel output to the speaker. */
      enum intr_level old_level = intr_disable ();
c0026d9e:	e8 fa a5 ff ff       	call   c002139d <intr_disable>
c0026da3:	89 45 f4             	mov    %eax,-0xc(%ebp)
      pit_configure_channel (2, 3, frequency);
c0026da6:	83 ec 04             	sub    $0x4,%esp
c0026da9:	ff 75 08             	push   0x8(%ebp)
c0026dac:	6a 03                	push   $0x3
c0026dae:	6a 02                	push   $0x2
c0026db0:	e8 a5 cc ff ff       	call   c0023a5a <pit_configure_channel>
c0026db5:	83 c4 10             	add    $0x10,%esp
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c0026db8:	83 ec 0c             	sub    $0xc,%esp
c0026dbb:	6a 61                	push   $0x61
c0026dbd:	e8 8d ff ff ff       	call   c0026d4f <inb>
c0026dc2:	83 c4 10             	add    $0x10,%esp
c0026dc5:	83 c8 03             	or     $0x3,%eax
c0026dc8:	0f b6 c0             	movzbl %al,%eax
c0026dcb:	83 ec 08             	sub    $0x8,%esp
c0026dce:	50                   	push   %eax
c0026dcf:	6a 61                	push   $0x61
c0026dd1:	e8 94 ff ff ff       	call   c0026d6a <outb>
c0026dd6:	83 c4 10             	add    $0x10,%esp
      intr_set_level (old_level);
c0026dd9:	83 ec 0c             	sub    $0xc,%esp
c0026ddc:	ff 75 f4             	push   -0xc(%ebp)
c0026ddf:	e8 61 a5 ff ff       	call   c0021345 <intr_set_level>
c0026de4:	83 c4 10             	add    $0x10,%esp
    {
c0026de7:	eb 06                	jmp    c0026def <speaker_on+0x66>
    }
  else
    {
      /* FREQUENCY is outside the range of normal human hearing.
         Just turn off the speaker. */
      speaker_off ();
c0026de9:	e8 04 00 00 00       	call   c0026df2 <speaker_off>
    }
}
c0026dee:	90                   	nop
c0026def:	90                   	nop
c0026df0:	c9                   	leave  
c0026df1:	c3                   	ret    

c0026df2 <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c0026df2:	55                   	push   %ebp
c0026df3:	89 e5                	mov    %esp,%ebp
c0026df5:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0026df8:	e8 a0 a5 ff ff       	call   c002139d <intr_disable>
c0026dfd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
c0026e00:	83 ec 0c             	sub    $0xc,%esp
c0026e03:	6a 61                	push   $0x61
c0026e05:	e8 45 ff ff ff       	call   c0026d4f <inb>
c0026e0a:	83 c4 10             	add    $0x10,%esp
c0026e0d:	0f b6 c0             	movzbl %al,%eax
c0026e10:	25 fc 00 00 00       	and    $0xfc,%eax
c0026e15:	83 ec 08             	sub    $0x8,%esp
c0026e18:	50                   	push   %eax
c0026e19:	6a 61                	push   $0x61
c0026e1b:	e8 4a ff ff ff       	call   c0026d6a <outb>
c0026e20:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0026e23:	83 ec 0c             	sub    $0xc,%esp
c0026e26:	ff 75 f4             	push   -0xc(%ebp)
c0026e29:	e8 17 a5 ff ff       	call   c0021345 <intr_set_level>
c0026e2e:	83 c4 10             	add    $0x10,%esp
}
c0026e31:	90                   	nop
c0026e32:	c9                   	leave  
c0026e33:	c3                   	ret    

c0026e34 <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c0026e34:	55                   	push   %ebp
c0026e35:	89 e5                	mov    %esp,%ebp
c0026e37:	83 ec 08             	sub    $0x8,%esp

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c0026e3a:	e8 f0 a4 ff ff       	call   c002132f <intr_get_level>
c0026e3f:	83 f8 01             	cmp    $0x1,%eax
c0026e42:	75 27                	jne    c0026e6b <speaker_beep+0x37>
    {
      speaker_on (440);
c0026e44:	83 ec 0c             	sub    $0xc,%esp
c0026e47:	68 b8 01 00 00       	push   $0x1b8
c0026e4c:	e8 38 ff ff ff       	call   c0026d89 <speaker_on>
c0026e51:	83 c4 10             	add    $0x10,%esp
      timer_msleep (250);
c0026e54:	83 ec 08             	sub    $0x8,%esp
c0026e57:	6a 00                	push   $0x0
c0026e59:	68 fa 00 00 00       	push   $0xfa
c0026e5e:	e8 04 cf ff ff       	call   c0023d67 <timer_msleep>
c0026e63:	83 c4 10             	add    $0x10,%esp
      speaker_off ();
c0026e66:	e8 87 ff ff ff       	call   c0026df2 <speaker_off>
    }
}
c0026e6b:	90                   	nop
c0026e6c:	c9                   	leave  
c0026e6d:	c3                   	ret    

c0026e6e <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c0026e6e:	55                   	push   %ebp
c0026e6f:	89 e5                	mov    %esp,%ebp
c0026e71:	83 ec 18             	sub    $0x18,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c0026e74:	8b 45 04             	mov    0x4(%ebp),%eax
c0026e77:	83 ec 08             	sub    $0x8,%esp
c0026e7a:	50                   	push   %eax
c0026e7b:	68 e8 04 03 c0       	push   $0xc00304e8
c0026e80:	e8 f7 02 00 00       	call   c002717c <printf>
c0026e85:	83 c4 10             	add    $0x10,%esp
  for (frame = __builtin_frame_address (1);
c0026e88:	8b 45 00             	mov    0x0(%ebp),%eax
c0026e8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0026e8e:	eb 21                	jmp    c0026eb1 <debug_backtrace+0x43>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
    printf (" %p", frame[1]);
c0026e90:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026e93:	83 c0 04             	add    $0x4,%eax
c0026e96:	8b 00                	mov    (%eax),%eax
c0026e98:	83 ec 08             	sub    $0x8,%esp
c0026e9b:	50                   	push   %eax
c0026e9c:	68 f7 04 03 c0       	push   $0xc00304f7
c0026ea1:	e8 d6 02 00 00       	call   c002717c <printf>
c0026ea6:	83 c4 10             	add    $0x10,%esp
       frame = frame[0]) 
c0026ea9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026eac:	8b 00                	mov    (%eax),%eax
c0026eae:	89 45 f4             	mov    %eax,-0xc(%ebp)
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026eb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  for (frame = __builtin_frame_address (1);
c0026eb4:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c0026eb9:	76 09                	jbe    c0026ec4 <debug_backtrace+0x56>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026ebb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026ebe:	8b 00                	mov    (%eax),%eax
c0026ec0:	85 c0                	test   %eax,%eax
c0026ec2:	75 cc                	jne    c0026e90 <debug_backtrace+0x22>
  printf (".\n");
c0026ec4:	83 ec 0c             	sub    $0xc,%esp
c0026ec7:	68 fb 04 03 c0       	push   $0xc00304fb
c0026ecc:	e8 12 48 00 00       	call   c002b6e3 <puts>
c0026ed1:	83 c4 10             	add    $0x10,%esp

  if (!explained) 
c0026ed4:	a0 ac 52 03 c0       	mov    0xc00352ac,%al
c0026ed9:	83 f0 01             	xor    $0x1,%eax
c0026edc:	84 c0                	test   %al,%al
c0026ede:	74 17                	je     c0026ef7 <debug_backtrace+0x89>
    {
      explained = true;
c0026ee0:	c6 05 ac 52 03 c0 01 	movb   $0x1,0xc00352ac
      printf ("The `backtrace' program can make call stacks useful.\n"
c0026ee7:	83 ec 0c             	sub    $0xc,%esp
c0026eea:	68 00 05 03 c0       	push   $0xc0030500
c0026eef:	e8 ef 47 00 00       	call   c002b6e3 <puts>
c0026ef4:	83 c4 10             	add    $0x10,%esp
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c0026ef7:	90                   	nop
c0026ef8:	c9                   	leave  
c0026ef9:	c3                   	ret    

c0026efa <swap_byte>:
static bool inited;     

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
c0026efa:	55                   	push   %ebp
c0026efb:	89 e5                	mov    %esp,%ebp
c0026efd:	83 ec 10             	sub    $0x10,%esp
  uint8_t t = *a;
c0026f00:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f03:	8a 00                	mov    (%eax),%al
c0026f05:	88 45 ff             	mov    %al,-0x1(%ebp)
  *a = *b;
c0026f08:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026f0b:	8a 10                	mov    (%eax),%dl
c0026f0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f10:	88 10                	mov    %dl,(%eax)
  *b = t;
c0026f12:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026f15:	8a 55 ff             	mov    -0x1(%ebp),%dl
c0026f18:	88 10                	mov    %dl,(%eax)
}
c0026f1a:	90                   	nop
c0026f1b:	c9                   	leave  
c0026f1c:	c3                   	ret    

c0026f1d <random_init>:

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c0026f1d:	55                   	push   %ebp
c0026f1e:	89 e5                	mov    %esp,%ebp
c0026f20:	83 ec 10             	sub    $0x10,%esp
  uint8_t *seedp = (uint8_t *) &seed;
c0026f23:	8d 45 08             	lea    0x8(%ebp),%eax
c0026f26:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c0026f29:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0026f30:	eb 12                	jmp    c0026f44 <random_init+0x27>
    s[i] = i;
c0026f32:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026f35:	88 c2                	mov    %al,%dl
c0026f37:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026f3a:	05 c0 52 03 c0       	add    $0xc00352c0,%eax
c0026f3f:	88 10                	mov    %dl,(%eax)
  for (i = 0; i < 256; i++) 
c0026f41:	ff 45 fc             	incl   -0x4(%ebp)
c0026f44:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0026f4b:	7e e5                	jle    c0026f32 <random_init+0x15>
  for (i = j = 0; i < 256; i++) 
c0026f4d:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
c0026f51:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0026f58:	eb 3d                	jmp    c0026f97 <random_init+0x7a>
    {
      j += s[i] + seedp[i % sizeof seed];
c0026f5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026f5d:	05 c0 52 03 c0       	add    $0xc00352c0,%eax
c0026f62:	8a 10                	mov    (%eax),%dl
c0026f64:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026f67:	83 e0 03             	and    $0x3,%eax
c0026f6a:	89 c1                	mov    %eax,%ecx
c0026f6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026f6f:	01 c8                	add    %ecx,%eax
c0026f71:	8a 00                	mov    (%eax),%al
c0026f73:	01 d0                	add    %edx,%eax
c0026f75:	00 45 fb             	add    %al,-0x5(%ebp)
      swap_byte (s + i, s + j);
c0026f78:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0026f7c:	8d 90 c0 52 03 c0    	lea    -0x3ffcad40(%eax),%edx
c0026f82:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026f85:	05 c0 52 03 c0       	add    $0xc00352c0,%eax
c0026f8a:	52                   	push   %edx
c0026f8b:	50                   	push   %eax
c0026f8c:	e8 69 ff ff ff       	call   c0026efa <swap_byte>
c0026f91:	83 c4 08             	add    $0x8,%esp
  for (i = j = 0; i < 256; i++) 
c0026f94:	ff 45 fc             	incl   -0x4(%ebp)
c0026f97:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0026f9e:	7e ba                	jle    c0026f5a <random_init+0x3d>
    }

  s_i = s_j = 0;
c0026fa0:	c6 05 c1 53 03 c0 00 	movb   $0x0,0xc00353c1
c0026fa7:	a0 c1 53 03 c0       	mov    0xc00353c1,%al
c0026fac:	a2 c0 53 03 c0       	mov    %al,0xc00353c0
  inited = true;
c0026fb1:	c6 05 c2 53 03 c0 01 	movb   $0x1,0xc00353c2
}
c0026fb8:	90                   	nop
c0026fb9:	c9                   	leave  
c0026fba:	c3                   	ret    

c0026fbb <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0026fbb:	55                   	push   %ebp
c0026fbc:	89 e5                	mov    %esp,%ebp
c0026fbe:	83 ec 10             	sub    $0x10,%esp
  uint8_t *buf;

  if (!inited)
c0026fc1:	a0 c2 53 03 c0       	mov    0xc00353c2,%al
c0026fc6:	83 f0 01             	xor    $0x1,%eax
c0026fc9:	84 c0                	test   %al,%al
c0026fcb:	74 0a                	je     c0026fd7 <random_bytes+0x1c>
    random_init (0);
c0026fcd:	6a 00                	push   $0x0
c0026fcf:	e8 49 ff ff ff       	call   c0026f1d <random_init>
c0026fd4:	83 c4 04             	add    $0x4,%esp

  for (buf = buf_; size-- > 0; buf++)
c0026fd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0026fda:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0026fdd:	eb 7d                	jmp    c002705c <random_bytes+0xa1>
    {
      uint8_t s_k;
      
      s_i++;
c0026fdf:	a0 c0 53 03 c0       	mov    0xc00353c0,%al
c0026fe4:	40                   	inc    %eax
c0026fe5:	a2 c0 53 03 c0       	mov    %al,0xc00353c0
      s_j += s[s_i];
c0026fea:	a0 c0 53 03 c0       	mov    0xc00353c0,%al
c0026fef:	0f b6 c0             	movzbl %al,%eax
c0026ff2:	8a 90 c0 52 03 c0    	mov    -0x3ffcad40(%eax),%dl
c0026ff8:	a0 c1 53 03 c0       	mov    0xc00353c1,%al
c0026ffd:	01 d0                	add    %edx,%eax
c0026fff:	a2 c1 53 03 c0       	mov    %al,0xc00353c1
      swap_byte (s + s_i, s + s_j);
c0027004:	a0 c1 53 03 c0       	mov    0xc00353c1,%al
c0027009:	0f b6 c0             	movzbl %al,%eax
c002700c:	8d 90 c0 52 03 c0    	lea    -0x3ffcad40(%eax),%edx
c0027012:	a0 c0 53 03 c0       	mov    0xc00353c0,%al
c0027017:	0f b6 c0             	movzbl %al,%eax
c002701a:	05 c0 52 03 c0       	add    $0xc00352c0,%eax
c002701f:	52                   	push   %edx
c0027020:	50                   	push   %eax
c0027021:	e8 d4 fe ff ff       	call   c0026efa <swap_byte>
c0027026:	83 c4 08             	add    $0x8,%esp

      s_k = s[s_i] + s[s_j];
c0027029:	a0 c0 53 03 c0       	mov    0xc00353c0,%al
c002702e:	0f b6 c0             	movzbl %al,%eax
c0027031:	8a 90 c0 52 03 c0    	mov    -0x3ffcad40(%eax),%dl
c0027037:	a0 c1 53 03 c0       	mov    0xc00353c1,%al
c002703c:	0f b6 c0             	movzbl %al,%eax
c002703f:	8a 80 c0 52 03 c0    	mov    -0x3ffcad40(%eax),%al
c0027045:	01 d0                	add    %edx,%eax
c0027047:	88 45 fb             	mov    %al,-0x5(%ebp)
      *buf = s[s_k];
c002704a:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c002704e:	8a 90 c0 52 03 c0    	mov    -0x3ffcad40(%eax),%dl
c0027054:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027057:	88 10                	mov    %dl,(%eax)
  for (buf = buf_; size-- > 0; buf++)
c0027059:	ff 45 fc             	incl   -0x4(%ebp)
c002705c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002705f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0027062:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027065:	85 c0                	test   %eax,%eax
c0027067:	0f 85 72 ff ff ff    	jne    c0026fdf <random_bytes+0x24>
    }
}
c002706d:	90                   	nop
c002706e:	90                   	nop
c002706f:	c9                   	leave  
c0027070:	c3                   	ret    

c0027071 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c0027071:	55                   	push   %ebp
c0027072:	89 e5                	mov    %esp,%ebp
c0027074:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c0027077:	6a 04                	push   $0x4
c0027079:	8d 45 fc             	lea    -0x4(%ebp),%eax
c002707c:	50                   	push   %eax
c002707d:	e8 39 ff ff ff       	call   c0026fbb <random_bytes>
c0027082:	83 c4 08             	add    $0x8,%esp
  return ul;
c0027085:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0027088:	c9                   	leave  
c0027089:	c3                   	ret    

c002708a <isdigit>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c002708a:	55                   	push   %ebp
c002708b:	89 e5                	mov    %esp,%ebp
c002708d:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0027091:	7e 0d                	jle    c00270a0 <isdigit+0x16>
c0027093:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0027097:	7f 07                	jg     c00270a0 <isdigit+0x16>
c0027099:	b8 01 00 00 00       	mov    $0x1,%eax
c002709e:	eb 05                	jmp    c00270a5 <isdigit+0x1b>
c00270a0:	b8 00 00 00 00       	mov    $0x0,%eax
c00270a5:	5d                   	pop    %ebp
c00270a6:	c3                   	ret    

c00270a7 <isprint>:
static inline int isprint (int c) { return c >= 32 && c < 127; }
c00270a7:	55                   	push   %ebp
c00270a8:	89 e5                	mov    %esp,%ebp
c00270aa:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c00270ae:	7e 0d                	jle    c00270bd <isprint+0x16>
c00270b0:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c00270b4:	7f 07                	jg     c00270bd <isprint+0x16>
c00270b6:	b8 01 00 00 00       	mov    $0x1,%eax
c00270bb:	eb 05                	jmp    c00270c2 <isprint+0x1b>
c00270bd:	b8 00 00 00 00       	mov    $0x0,%eax
c00270c2:	5d                   	pop    %ebp
c00270c3:	c3                   	ret    

c00270c4 <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
c00270c4:	55                   	push   %ebp
c00270c5:	89 e5                	mov    %esp,%ebp
c00270c7:	83 ec 18             	sub    $0x18,%esp
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
c00270ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00270cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
  aux.length = 0;
c00270d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c00270d7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00270db:	74 06                	je     c00270e3 <vsnprintf+0x1f>
c00270dd:	8b 45 0c             	mov    0xc(%ebp),%eax
c00270e0:	48                   	dec    %eax
c00270e1:	eb 05                	jmp    c00270e8 <vsnprintf+0x24>
c00270e3:	b8 00 00 00 00       	mov    $0x0,%eax
c00270e8:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
c00270eb:	8d 45 ec             	lea    -0x14(%ebp),%eax
c00270ee:	50                   	push   %eax
c00270ef:	68 13 71 02 c0       	push   $0xc0027113
c00270f4:	ff 75 14             	push   0x14(%ebp)
c00270f7:	ff 75 10             	push   0x10(%ebp)
c00270fa:	e8 a3 00 00 00       	call   c00271a2 <__vprintf>
c00270ff:	83 c4 10             	add    $0x10,%esp

  /* Add null terminator. */
  if (buf_size > 0)
c0027102:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0027106:	74 06                	je     c002710e <vsnprintf+0x4a>
    *aux.p = '\0';
c0027108:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002710b:	c6 00 00             	movb   $0x0,(%eax)

  return aux.length;
c002710e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0027111:	c9                   	leave  
c0027112:	c3                   	ret    

c0027113 <vsnprintf_helper>:

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0027113:	55                   	push   %ebp
c0027114:	89 e5                	mov    %esp,%ebp
c0027116:	83 ec 14             	sub    $0x14,%esp
c0027119:	8b 45 08             	mov    0x8(%ebp),%eax
c002711c:	88 45 ec             	mov    %al,-0x14(%ebp)
  struct vsnprintf_aux *aux = aux_;
c002711f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027122:	89 45 fc             	mov    %eax,-0x4(%ebp)

  if (aux->length++ < aux->max_length)
c0027125:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027128:	8b 40 04             	mov    0x4(%eax),%eax
c002712b:	8d 48 01             	lea    0x1(%eax),%ecx
c002712e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027131:	89 4a 04             	mov    %ecx,0x4(%edx)
c0027134:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027137:	8b 52 08             	mov    0x8(%edx),%edx
c002713a:	39 d0                	cmp    %edx,%eax
c002713c:	7d 12                	jge    c0027150 <vsnprintf_helper+0x3d>
    *aux->p++ = ch;
c002713e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027141:	8b 00                	mov    (%eax),%eax
c0027143:	8d 48 01             	lea    0x1(%eax),%ecx
c0027146:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027149:	89 0a                	mov    %ecx,(%edx)
c002714b:	8a 55 ec             	mov    -0x14(%ebp),%dl
c002714e:	88 10                	mov    %dl,(%eax)
}
c0027150:	90                   	nop
c0027151:	c9                   	leave  
c0027152:	c3                   	ret    

c0027153 <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
c0027153:	55                   	push   %ebp
c0027154:	89 e5                	mov    %esp,%ebp
c0027156:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c0027159:	8d 45 14             	lea    0x14(%ebp),%eax
c002715c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vsnprintf (buffer, buf_size, format, args);
c002715f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027162:	50                   	push   %eax
c0027163:	ff 75 10             	push   0x10(%ebp)
c0027166:	ff 75 0c             	push   0xc(%ebp)
c0027169:	ff 75 08             	push   0x8(%ebp)
c002716c:	e8 53 ff ff ff       	call   c00270c4 <vsnprintf>
c0027171:	83 c4 10             	add    $0x10,%esp
c0027174:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c0027177:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002717a:	c9                   	leave  
c002717b:	c3                   	ret    

c002717c <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
c002717c:	55                   	push   %ebp
c002717d:	89 e5                	mov    %esp,%ebp
c002717f:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c0027182:	8d 45 0c             	lea    0xc(%ebp),%eax
c0027185:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vprintf (format, args);
c0027188:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002718b:	83 ec 08             	sub    $0x8,%esp
c002718e:	50                   	push   %eax
c002718f:	ff 75 08             	push   0x8(%ebp)
c0027192:	e8 19 45 00 00       	call   c002b6b0 <vprintf>
c0027197:	83 c4 10             	add    $0x10,%esp
c002719a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c002719d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00271a0:	c9                   	leave  
c00271a1:	c3                   	ret    

c00271a2 <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
c00271a2:	55                   	push   %ebp
c00271a3:	89 e5                	mov    %esp,%ebp
c00271a5:	53                   	push   %ebx
c00271a6:	83 ec 34             	sub    $0x34,%esp
  for (; *format != '\0'; format++)
c00271a9:	e9 23 04 00 00       	jmp    c00275d1 <__vprintf+0x42f>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
c00271ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00271b1:	8a 00                	mov    (%eax),%al
c00271b3:	3c 25                	cmp    $0x25,%al
c00271b5:	74 1c                	je     c00271d3 <__vprintf+0x31>
        {
          output (*format, aux);
c00271b7:	8b 45 08             	mov    0x8(%ebp),%eax
c00271ba:	8a 00                	mov    (%eax),%al
c00271bc:	0f be c0             	movsbl %al,%eax
c00271bf:	83 ec 08             	sub    $0x8,%esp
c00271c2:	ff 75 14             	push   0x14(%ebp)
c00271c5:	50                   	push   %eax
c00271c6:	8b 45 10             	mov    0x10(%ebp),%eax
c00271c9:	ff d0                	call   *%eax
c00271cb:	83 c4 10             	add    $0x10,%esp
          continue;
c00271ce:	e9 fb 03 00 00       	jmp    c00275ce <__vprintf+0x42c>
        }
      format++;
c00271d3:	ff 45 08             	incl   0x8(%ebp)

      /* %% => %. */
      if (*format == '%') 
c00271d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00271d9:	8a 00                	mov    (%eax),%al
c00271db:	3c 25                	cmp    $0x25,%al
c00271dd:	75 15                	jne    c00271f4 <__vprintf+0x52>
        {
          output ('%', aux);
c00271df:	83 ec 08             	sub    $0x8,%esp
c00271e2:	ff 75 14             	push   0x14(%ebp)
c00271e5:	6a 25                	push   $0x25
c00271e7:	8b 45 10             	mov    0x10(%ebp),%eax
c00271ea:	ff d0                	call   *%eax
c00271ec:	83 c4 10             	add    $0x10,%esp
          continue;
c00271ef:	e9 da 03 00 00       	jmp    c00275ce <__vprintf+0x42c>
        }

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);
c00271f4:	83 ec 04             	sub    $0x4,%esp
c00271f7:	8d 45 0c             	lea    0xc(%ebp),%eax
c00271fa:	50                   	push   %eax
c00271fb:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00271fe:	50                   	push   %eax
c00271ff:	ff 75 08             	push   0x8(%ebp)
c0027202:	e8 de 03 00 00       	call   c00275e5 <parse_conversion>
c0027207:	83 c4 10             	add    $0x10,%esp
c002720a:	89 45 08             	mov    %eax,0x8(%ebp)

      /* Do conversion. */
      switch (*format) 
c002720d:	8b 45 08             	mov    0x8(%ebp),%eax
c0027210:	8a 00                	mov    (%eax),%al
c0027212:	0f be c0             	movsbl %al,%eax
c0027215:	83 e8 45             	sub    $0x45,%eax
c0027218:	83 f8 33             	cmp    $0x33,%eax
c002721b:	0f 87 90 03 00 00    	ja     c00275b1 <__vprintf+0x40f>
c0027221:	8b 04 85 84 06 03 c0 	mov    -0x3ffcf97c(,%eax,4),%eax
c0027228:	ff e0                	jmp    *%eax
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
c002722a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002722d:	83 f8 08             	cmp    $0x8,%eax
c0027230:	0f 87 d5 00 00 00    	ja     c002730b <__vprintf+0x169>
c0027236:	8b 04 85 54 07 03 c0 	mov    -0x3ffcf8ac(,%eax,4),%eax
c002723d:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
c002723f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027242:	8d 50 04             	lea    0x4(%eax),%edx
c0027245:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027248:	8b 00                	mov    (%eax),%eax
c002724a:	0f be c0             	movsbl %al,%eax
c002724d:	99                   	cltd   
c002724e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027251:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027254:	e9 cc 00 00 00       	jmp    c0027325 <__vprintf+0x183>
              case SHORT:
                value = (short) va_arg (args, int);
c0027259:	8b 45 0c             	mov    0xc(%ebp),%eax
c002725c:	8d 50 04             	lea    0x4(%eax),%edx
c002725f:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027262:	8b 00                	mov    (%eax),%eax
c0027264:	98                   	cwtl   
c0027265:	99                   	cltd   
c0027266:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027269:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c002726c:	e9 b4 00 00 00       	jmp    c0027325 <__vprintf+0x183>
              case INT:
                value = va_arg (args, int);
c0027271:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027274:	8d 50 04             	lea    0x4(%eax),%edx
c0027277:	89 55 0c             	mov    %edx,0xc(%ebp)
c002727a:	8b 00                	mov    (%eax),%eax
c002727c:	99                   	cltd   
c002727d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027280:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027283:	e9 9d 00 00 00       	jmp    c0027325 <__vprintf+0x183>
              case INTMAX:
                value = va_arg (args, intmax_t);
c0027288:	8b 45 0c             	mov    0xc(%ebp),%eax
c002728b:	8d 50 08             	lea    0x8(%eax),%edx
c002728e:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027291:	8b 50 04             	mov    0x4(%eax),%edx
c0027294:	8b 00                	mov    (%eax),%eax
c0027296:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027299:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c002729c:	e9 84 00 00 00       	jmp    c0027325 <__vprintf+0x183>
              case LONG:
                value = va_arg (args, long);
c00272a1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272a4:	8d 50 04             	lea    0x4(%eax),%edx
c00272a7:	89 55 0c             	mov    %edx,0xc(%ebp)
c00272aa:	8b 00                	mov    (%eax),%eax
c00272ac:	99                   	cltd   
c00272ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00272b0:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00272b3:	eb 70                	jmp    c0027325 <__vprintf+0x183>
              case LONGLONG:
                value = va_arg (args, long long);
c00272b5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272b8:	8d 50 08             	lea    0x8(%eax),%edx
c00272bb:	89 55 0c             	mov    %edx,0xc(%ebp)
c00272be:	8b 50 04             	mov    0x4(%eax),%edx
c00272c1:	8b 00                	mov    (%eax),%eax
c00272c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00272c6:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00272c9:	eb 5a                	jmp    c0027325 <__vprintf+0x183>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c00272cb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272ce:	8d 50 04             	lea    0x4(%eax),%edx
c00272d1:	89 55 0c             	mov    %edx,0xc(%ebp)
c00272d4:	8b 00                	mov    (%eax),%eax
c00272d6:	99                   	cltd   
c00272d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00272da:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00272dd:	eb 46                	jmp    c0027325 <__vprintf+0x183>
              case SIZET:
                value = va_arg (args, size_t);
c00272df:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272e2:	8d 50 04             	lea    0x4(%eax),%edx
c00272e5:	89 55 0c             	mov    %edx,0xc(%ebp)
c00272e8:	8b 00                	mov    (%eax),%eax
c00272ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00272ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                if (value > SIZE_MAX / 2)
c00272f4:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
c00272f9:	b8 00 00 00 00       	mov    $0x0,%eax
c00272fe:	3b 55 f0             	cmp    -0x10(%ebp),%edx
c0027301:	1b 45 f4             	sbb    -0xc(%ebp),%eax
c0027304:	7d 1e                	jge    c0027324 <__vprintf+0x182>
                  value = value - SIZE_MAX - 1;
c0027306:	ff 4d f4             	decl   -0xc(%ebp)
                break;
c0027309:	eb 19                	jmp    c0027324 <__vprintf+0x182>
              default:
                NOT_REACHED ();
c002730b:	68 1c 06 03 c0       	push   $0xc003061c
c0027310:	68 50 08 03 c0       	push   $0xc0030850
c0027315:	68 dc 00 00 00       	push   $0xdc
c002731a:	68 3e 06 03 c0       	push   $0xc003063e
c002731f:	e8 fa 21 00 00       	call   c002951e <debug_panic>
                break;
c0027324:	90                   	nop
              }

            format_integer (value < 0 ? -value : value,
c0027325:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027328:	c1 e8 1f             	shr    $0x1f,%eax
c002732b:	0f b6 c8             	movzbl %al,%ecx
c002732e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027331:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0027334:	85 d2                	test   %edx,%edx
c0027336:	79 07                	jns    c002733f <__vprintf+0x19d>
c0027338:	f7 d8                	neg    %eax
c002733a:	83 d2 00             	adc    $0x0,%edx
c002733d:	f7 da                	neg    %edx
c002733f:	ff 75 14             	push   0x14(%ebp)
c0027342:	ff 75 10             	push   0x10(%ebp)
c0027345:	8d 5d cc             	lea    -0x34(%ebp),%ebx
c0027348:	53                   	push   %ebx
c0027349:	68 a8 05 03 c0       	push   $0xc00305a8
c002734e:	51                   	push   %ecx
c002734f:	6a 01                	push   $0x1
c0027351:	52                   	push   %edx
c0027352:	50                   	push   %eax
c0027353:	e8 41 05 00 00       	call   c0027899 <format_integer>
c0027358:	83 c4 20             	add    $0x20,%esp
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
c002735b:	e9 6e 02 00 00       	jmp    c00275ce <__vprintf+0x42c>
          {
            /* Unsigned integer conversions. */
            uintmax_t value;
            const struct integer_base *b;

            switch (c.type) 
c0027360:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0027363:	83 f8 08             	cmp    $0x8,%eax
c0027366:	0f 87 d3 00 00 00    	ja     c002743f <__vprintf+0x29d>
c002736c:	8b 04 85 78 07 03 c0 	mov    -0x3ffcf888(,%eax,4),%eax
c0027373:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
c0027375:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027378:	8d 50 04             	lea    0x4(%eax),%edx
c002737b:	89 55 0c             	mov    %edx,0xc(%ebp)
c002737e:	8b 00                	mov    (%eax),%eax
c0027380:	0f b6 c0             	movzbl %al,%eax
c0027383:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027386:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c002738d:	e9 c6 00 00 00       	jmp    c0027458 <__vprintf+0x2b6>
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
c0027392:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027395:	8d 50 04             	lea    0x4(%eax),%edx
c0027398:	89 55 0c             	mov    %edx,0xc(%ebp)
c002739b:	8b 00                	mov    (%eax),%eax
c002739d:	0f b7 c0             	movzwl %ax,%eax
c00273a0:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00273a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c00273aa:	e9 a9 00 00 00       	jmp    c0027458 <__vprintf+0x2b6>
              case INT:
                value = va_arg (args, unsigned);
c00273af:	8b 45 0c             	mov    0xc(%ebp),%eax
c00273b2:	8d 50 04             	lea    0x4(%eax),%edx
c00273b5:	89 55 0c             	mov    %edx,0xc(%ebp)
c00273b8:	8b 00                	mov    (%eax),%eax
c00273ba:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00273bd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c00273c4:	e9 8f 00 00 00       	jmp    c0027458 <__vprintf+0x2b6>
              case INTMAX:
                value = va_arg (args, uintmax_t);
c00273c9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00273cc:	8d 50 08             	lea    0x8(%eax),%edx
c00273cf:	89 55 0c             	mov    %edx,0xc(%ebp)
c00273d2:	8b 50 04             	mov    0x4(%eax),%edx
c00273d5:	8b 00                	mov    (%eax),%eax
c00273d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00273da:	89 55 ec             	mov    %edx,-0x14(%ebp)
                break;
c00273dd:	eb 79                	jmp    c0027458 <__vprintf+0x2b6>
              case LONG:
                value = va_arg (args, unsigned long);
c00273df:	8b 45 0c             	mov    0xc(%ebp),%eax
c00273e2:	8d 50 04             	lea    0x4(%eax),%edx
c00273e5:	89 55 0c             	mov    %edx,0xc(%ebp)
c00273e8:	8b 00                	mov    (%eax),%eax
c00273ea:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00273ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c00273f4:	eb 62                	jmp    c0027458 <__vprintf+0x2b6>
              case LONGLONG:
                value = va_arg (args, unsigned long long);
c00273f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00273f9:	8d 50 08             	lea    0x8(%eax),%edx
c00273fc:	89 55 0c             	mov    %edx,0xc(%ebp)
c00273ff:	8b 50 04             	mov    0x4(%eax),%edx
c0027402:	8b 00                	mov    (%eax),%eax
c0027404:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027407:	89 55 ec             	mov    %edx,-0x14(%ebp)
                break;
c002740a:	eb 4c                	jmp    c0027458 <__vprintf+0x2b6>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c002740c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002740f:	8d 50 04             	lea    0x4(%eax),%edx
c0027412:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027415:	8b 00                	mov    (%eax),%eax
c0027417:	99                   	cltd   
c0027418:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002741b:	89 55 ec             	mov    %edx,-0x14(%ebp)
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c002741e:	83 65 e8 ff          	andl   $0xffffffff,-0x18(%ebp)
c0027422:	83 65 ec 00          	andl   $0x0,-0x14(%ebp)
#endif
                break;
c0027426:	eb 30                	jmp    c0027458 <__vprintf+0x2b6>
              case SIZET:
                value = va_arg (args, size_t);
c0027428:	8b 45 0c             	mov    0xc(%ebp),%eax
c002742b:	8d 50 04             	lea    0x4(%eax),%edx
c002742e:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027431:	8b 00                	mov    (%eax),%eax
c0027433:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027436:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c002743d:	eb 19                	jmp    c0027458 <__vprintf+0x2b6>
              default:
                NOT_REACHED ();
c002743f:	68 1c 06 03 c0       	push   $0xc003061c
c0027444:	68 50 08 03 c0       	push   $0xc0030850
c0027449:	68 0b 01 00 00       	push   $0x10b
c002744e:	68 3e 06 03 c0       	push   $0xc003063e
c0027453:	e8 c6 20 00 00       	call   c002951e <debug_panic>
              }

            switch (*format) 
c0027458:	8b 45 08             	mov    0x8(%ebp),%eax
c002745b:	8a 00                	mov    (%eax),%al
c002745d:	0f be c0             	movsbl %al,%eax
c0027460:	83 f8 78             	cmp    $0x78,%eax
c0027463:	74 2b                	je     c0027490 <__vprintf+0x2ee>
c0027465:	83 f8 78             	cmp    $0x78,%eax
c0027468:	7f 38                	jg     c00274a2 <__vprintf+0x300>
c002746a:	83 f8 75             	cmp    $0x75,%eax
c002746d:	74 18                	je     c0027487 <__vprintf+0x2e5>
c002746f:	83 f8 75             	cmp    $0x75,%eax
c0027472:	7f 2e                	jg     c00274a2 <__vprintf+0x300>
c0027474:	83 f8 58             	cmp    $0x58,%eax
c0027477:	74 20                	je     c0027499 <__vprintf+0x2f7>
c0027479:	83 f8 6f             	cmp    $0x6f,%eax
c002747c:	75 24                	jne    c00274a2 <__vprintf+0x300>
              {
              case 'o': b = &base_o; break;
c002747e:	c7 45 e4 c4 05 03 c0 	movl   $0xc00305c4,-0x1c(%ebp)
c0027485:	eb 34                	jmp    c00274bb <__vprintf+0x319>
              case 'u': b = &base_d; break;
c0027487:	c7 45 e4 a8 05 03 c0 	movl   $0xc00305a8,-0x1c(%ebp)
c002748e:	eb 2b                	jmp    c00274bb <__vprintf+0x319>
              case 'x': b = &base_x; break;
c0027490:	c7 45 e4 e8 05 03 c0 	movl   $0xc00305e8,-0x1c(%ebp)
c0027497:	eb 22                	jmp    c00274bb <__vprintf+0x319>
              case 'X': b = &base_X; break;
c0027499:	c7 45 e4 0c 06 03 c0 	movl   $0xc003060c,-0x1c(%ebp)
c00274a0:	eb 19                	jmp    c00274bb <__vprintf+0x319>
              default: NOT_REACHED ();
c00274a2:	68 1c 06 03 c0       	push   $0xc003061c
c00274a7:	68 50 08 03 c0       	push   $0xc0030850
c00274ac:	68 14 01 00 00       	push   $0x114
c00274b1:	68 3e 06 03 c0       	push   $0xc003063e
c00274b6:	e8 63 20 00 00       	call   c002951e <debug_panic>
              }

            format_integer (value, false, false, b, &c, output, aux);
c00274bb:	ff 75 14             	push   0x14(%ebp)
c00274be:	ff 75 10             	push   0x10(%ebp)
c00274c1:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00274c4:	50                   	push   %eax
c00274c5:	ff 75 e4             	push   -0x1c(%ebp)
c00274c8:	6a 00                	push   $0x0
c00274ca:	6a 00                	push   $0x0
c00274cc:	ff 75 ec             	push   -0x14(%ebp)
c00274cf:	ff 75 e8             	push   -0x18(%ebp)
c00274d2:	e8 c2 03 00 00       	call   c0027899 <format_integer>
c00274d7:	83 c4 20             	add    $0x20,%esp
          }
          break;
c00274da:	e9 ef 00 00 00       	jmp    c00275ce <__vprintf+0x42c>

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
c00274df:	8b 45 0c             	mov    0xc(%ebp),%eax
c00274e2:	8d 50 04             	lea    0x4(%eax),%edx
c00274e5:	89 55 0c             	mov    %edx,0xc(%ebp)
c00274e8:	8b 00                	mov    (%eax),%eax
c00274ea:	88 45 cb             	mov    %al,-0x35(%ebp)
            format_string (&ch, 1, &c, output, aux);
c00274ed:	83 ec 0c             	sub    $0xc,%esp
c00274f0:	ff 75 14             	push   0x14(%ebp)
c00274f3:	ff 75 10             	push   0x10(%ebp)
c00274f6:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00274f9:	50                   	push   %eax
c00274fa:	6a 01                	push   $0x1
c00274fc:	8d 45 cb             	lea    -0x35(%ebp),%eax
c00274ff:	50                   	push   %eax
c0027500:	e8 e8 06 00 00       	call   c0027bed <format_string>
c0027505:	83 c4 20             	add    $0x20,%esp
          }
          break;
c0027508:	e9 c1 00 00 00       	jmp    c00275ce <__vprintf+0x42c>

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
c002750d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027510:	8d 50 04             	lea    0x4(%eax),%edx
c0027513:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027516:	8b 00                	mov    (%eax),%eax
c0027518:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if (s == NULL)
c002751b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002751f:	75 07                	jne    c0027528 <__vprintf+0x386>
              s = "(null)";
c0027521:	c7 45 e0 50 06 03 c0 	movl   $0xc0030650,-0x20(%ebp)

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c0027528:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002752b:	83 ec 08             	sub    $0x8,%esp
c002752e:	50                   	push   %eax
c002752f:	ff 75 e0             	push   -0x20(%ebp)
c0027532:	e8 b5 14 00 00       	call   c00289ec <strnlen>
c0027537:	83 c4 10             	add    $0x10,%esp
c002753a:	89 c2                	mov    %eax,%edx
c002753c:	83 ec 0c             	sub    $0xc,%esp
c002753f:	ff 75 14             	push   0x14(%ebp)
c0027542:	ff 75 10             	push   0x10(%ebp)
c0027545:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0027548:	50                   	push   %eax
c0027549:	52                   	push   %edx
c002754a:	ff 75 e0             	push   -0x20(%ebp)
c002754d:	e8 9b 06 00 00       	call   c0027bed <format_string>
c0027552:	83 c4 20             	add    $0x20,%esp
          }
          break;
c0027555:	eb 77                	jmp    c00275ce <__vprintf+0x42c>
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
c0027557:	8b 45 0c             	mov    0xc(%ebp),%eax
c002755a:	8d 50 04             	lea    0x4(%eax),%edx
c002755d:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027560:	8b 00                	mov    (%eax),%eax
c0027562:	89 45 dc             	mov    %eax,-0x24(%ebp)

            c.flags = POUND;
c0027565:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%ebp)
            format_integer ((uintptr_t) p, false, false,
c002756c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002756f:	ba 00 00 00 00       	mov    $0x0,%edx
c0027574:	ff 75 14             	push   0x14(%ebp)
c0027577:	ff 75 10             	push   0x10(%ebp)
c002757a:	8d 4d cc             	lea    -0x34(%ebp),%ecx
c002757d:	51                   	push   %ecx
c002757e:	68 e8 05 03 c0       	push   $0xc00305e8
c0027583:	6a 00                	push   $0x0
c0027585:	6a 00                	push   $0x0
c0027587:	52                   	push   %edx
c0027588:	50                   	push   %eax
c0027589:	e8 0b 03 00 00       	call   c0027899 <format_integer>
c002758e:	83 c4 20             	add    $0x20,%esp
                            &base_x, &c, output, aux);
          }
          break;
c0027591:	eb 3b                	jmp    c00275ce <__vprintf+0x42c>
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c0027593:	8b 45 08             	mov    0x8(%ebp),%eax
c0027596:	8a 00                	mov    (%eax),%al
c0027598:	0f be c0             	movsbl %al,%eax
c002759b:	50                   	push   %eax
c002759c:	ff 75 14             	push   0x14(%ebp)
c002759f:	ff 75 10             	push   0x10(%ebp)
c00275a2:	68 57 06 03 c0       	push   $0xc0030657
c00275a7:	e8 dc 06 00 00       	call   c0027c88 <__printf>
c00275ac:	83 c4 10             	add    $0x10,%esp
          break;
c00275af:	eb 1d                	jmp    c00275ce <__vprintf+0x42c>

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c00275b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00275b4:	8a 00                	mov    (%eax),%al
c00275b6:	0f be c0             	movsbl %al,%eax
c00275b9:	50                   	push   %eax
c00275ba:	ff 75 14             	push   0x14(%ebp)
c00275bd:	ff 75 10             	push   0x10(%ebp)
c00275c0:	68 6d 06 03 c0       	push   $0xc003066d
c00275c5:	e8 be 06 00 00       	call   c0027c88 <__printf>
c00275ca:	83 c4 10             	add    $0x10,%esp
          break;
c00275cd:	90                   	nop
  for (; *format != '\0'; format++)
c00275ce:	ff 45 08             	incl   0x8(%ebp)
c00275d1:	8b 45 08             	mov    0x8(%ebp),%eax
c00275d4:	8a 00                	mov    (%eax),%al
c00275d6:	84 c0                	test   %al,%al
c00275d8:	0f 85 d0 fb ff ff    	jne    c00271ae <__vprintf+0xc>
        }
    }
}
c00275de:	90                   	nop
c00275df:	90                   	nop
c00275e0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00275e3:	c9                   	leave  
c00275e4:	c3                   	ret    

c00275e5 <parse_conversion>:
   that indicates the conversion (e.g. the `d' in `%d').  Uses
   *ARGS for `*' field widths and precisions. */
static const char *
parse_conversion (const char *format, struct printf_conversion *c,
                  va_list *args) 
{
c00275e5:	55                   	push   %ebp
c00275e6:	89 e5                	mov    %esp,%ebp
  /* Parse flag characters. */
  c->flags = 0;
c00275e8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00275eb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (;;) 
    {
      switch (*format++) 
c00275f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00275f4:	8d 50 01             	lea    0x1(%eax),%edx
c00275f7:	89 55 08             	mov    %edx,0x8(%ebp)
c00275fa:	8a 00                	mov    (%eax),%al
c00275fc:	0f be c0             	movsbl %al,%eax
c00275ff:	83 e8 20             	sub    $0x20,%eax
c0027602:	83 f8 10             	cmp    $0x10,%eax
c0027605:	77 6f                	ja     c0027676 <parse_conversion+0x91>
c0027607:	8b 04 85 9c 07 03 c0 	mov    -0x3ffcf864(,%eax,4),%eax
c002760e:	ff e0                	jmp    *%eax
        {
        case '-':
          c->flags |= MINUS;
c0027610:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027613:	8b 00                	mov    (%eax),%eax
c0027615:	83 c8 01             	or     $0x1,%eax
c0027618:	89 c2                	mov    %eax,%edx
c002761a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002761d:	89 10                	mov    %edx,(%eax)
          break;
c002761f:	eb 67                	jmp    c0027688 <parse_conversion+0xa3>
        case '+':
          c->flags |= PLUS;
c0027621:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027624:	8b 00                	mov    (%eax),%eax
c0027626:	83 c8 02             	or     $0x2,%eax
c0027629:	89 c2                	mov    %eax,%edx
c002762b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002762e:	89 10                	mov    %edx,(%eax)
          break;
c0027630:	eb 56                	jmp    c0027688 <parse_conversion+0xa3>
        case ' ':
          c->flags |= SPACE;
c0027632:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027635:	8b 00                	mov    (%eax),%eax
c0027637:	83 c8 04             	or     $0x4,%eax
c002763a:	89 c2                	mov    %eax,%edx
c002763c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002763f:	89 10                	mov    %edx,(%eax)
          break;
c0027641:	eb 45                	jmp    c0027688 <parse_conversion+0xa3>
        case '#':
          c->flags |= POUND;
c0027643:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027646:	8b 00                	mov    (%eax),%eax
c0027648:	83 c8 08             	or     $0x8,%eax
c002764b:	89 c2                	mov    %eax,%edx
c002764d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027650:	89 10                	mov    %edx,(%eax)
          break;
c0027652:	eb 34                	jmp    c0027688 <parse_conversion+0xa3>
        case '0':
          c->flags |= ZERO;
c0027654:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027657:	8b 00                	mov    (%eax),%eax
c0027659:	83 c8 10             	or     $0x10,%eax
c002765c:	89 c2                	mov    %eax,%edx
c002765e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027661:	89 10                	mov    %edx,(%eax)
          break;
c0027663:	eb 23                	jmp    c0027688 <parse_conversion+0xa3>
        case '\'':
          c->flags |= GROUP;
c0027665:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027668:	8b 00                	mov    (%eax),%eax
c002766a:	83 c8 20             	or     $0x20,%eax
c002766d:	89 c2                	mov    %eax,%edx
c002766f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027672:	89 10                	mov    %edx,(%eax)
          break;
c0027674:	eb 12                	jmp    c0027688 <parse_conversion+0xa3>
        default:
          format--;
c0027676:	ff 4d 08             	decl   0x8(%ebp)
          goto not_a_flag;
c0027679:	90                   	nop
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
c002767a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002767d:	8b 00                	mov    (%eax),%eax
c002767f:	83 e0 01             	and    $0x1,%eax
c0027682:	85 c0                	test   %eax,%eax
c0027684:	74 16                	je     c002769c <parse_conversion+0xb7>
c0027686:	eb 05                	jmp    c002768d <parse_conversion+0xa8>
      switch (*format++) 
c0027688:	e9 64 ff ff ff       	jmp    c00275f1 <parse_conversion+0xc>
    c->flags &= ~ZERO;
c002768d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027690:	8b 00                	mov    (%eax),%eax
c0027692:	83 e0 ef             	and    $0xffffffef,%eax
c0027695:	89 c2                	mov    %eax,%edx
c0027697:	8b 45 0c             	mov    0xc(%ebp),%eax
c002769a:	89 10                	mov    %edx,(%eax)
  if (c->flags & PLUS)
c002769c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002769f:	8b 00                	mov    (%eax),%eax
c00276a1:	83 e0 02             	and    $0x2,%eax
c00276a4:	85 c0                	test   %eax,%eax
c00276a6:	74 0f                	je     c00276b7 <parse_conversion+0xd2>
    c->flags &= ~SPACE;
c00276a8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276ab:	8b 00                	mov    (%eax),%eax
c00276ad:	83 e0 fb             	and    $0xfffffffb,%eax
c00276b0:	89 c2                	mov    %eax,%edx
c00276b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276b5:	89 10                	mov    %edx,(%eax)

  /* Parse field width. */
  c->width = 0;
c00276b7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276ba:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  if (*format == '*')
c00276c1:	8b 45 08             	mov    0x8(%ebp),%eax
c00276c4:	8a 00                	mov    (%eax),%al
c00276c6:	3c 2a                	cmp    $0x2a,%al
c00276c8:	75 41                	jne    c002770b <parse_conversion+0x126>
    {
      format++;
c00276ca:	ff 45 08             	incl   0x8(%ebp)
      c->width = va_arg (*args, int);
c00276cd:	8b 45 10             	mov    0x10(%ebp),%eax
c00276d0:	8b 00                	mov    (%eax),%eax
c00276d2:	8d 48 04             	lea    0x4(%eax),%ecx
c00276d5:	8b 55 10             	mov    0x10(%ebp),%edx
c00276d8:	89 0a                	mov    %ecx,(%edx)
c00276da:	8b 10                	mov    (%eax),%edx
c00276dc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276df:	89 50 04             	mov    %edx,0x4(%eax)
c00276e2:	eb 3c                	jmp    c0027720 <parse_conversion+0x13b>
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
c00276e4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276e7:	8b 50 04             	mov    0x4(%eax),%edx
c00276ea:	89 d0                	mov    %edx,%eax
c00276ec:	c1 e0 02             	shl    $0x2,%eax
c00276ef:	01 d0                	add    %edx,%eax
c00276f1:	01 c0                	add    %eax,%eax
c00276f3:	89 c2                	mov    %eax,%edx
c00276f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00276f8:	8a 00                	mov    (%eax),%al
c00276fa:	0f be c0             	movsbl %al,%eax
c00276fd:	01 d0                	add    %edx,%eax
c00276ff:	8d 50 d0             	lea    -0x30(%eax),%edx
c0027702:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027705:	89 50 04             	mov    %edx,0x4(%eax)
      for (; isdigit (*format); format++)
c0027708:	ff 45 08             	incl   0x8(%ebp)
c002770b:	8b 45 08             	mov    0x8(%ebp),%eax
c002770e:	8a 00                	mov    (%eax),%al
c0027710:	0f be c0             	movsbl %al,%eax
c0027713:	50                   	push   %eax
c0027714:	e8 71 f9 ff ff       	call   c002708a <isdigit>
c0027719:	83 c4 04             	add    $0x4,%esp
c002771c:	85 c0                	test   %eax,%eax
c002771e:	75 c4                	jne    c00276e4 <parse_conversion+0xff>
    }
  if (c->width < 0) 
c0027720:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027723:	8b 40 04             	mov    0x4(%eax),%eax
c0027726:	85 c0                	test   %eax,%eax
c0027728:	79 1f                	jns    c0027749 <parse_conversion+0x164>
    {
      c->width = -c->width;
c002772a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002772d:	8b 40 04             	mov    0x4(%eax),%eax
c0027730:	f7 d8                	neg    %eax
c0027732:	89 c2                	mov    %eax,%edx
c0027734:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027737:	89 50 04             	mov    %edx,0x4(%eax)
      c->flags |= MINUS;
c002773a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002773d:	8b 00                	mov    (%eax),%eax
c002773f:	83 c8 01             	or     $0x1,%eax
c0027742:	89 c2                	mov    %eax,%edx
c0027744:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027747:	89 10                	mov    %edx,(%eax)
    }
      
  /* Parse precision. */
  c->precision = -1;
c0027749:	8b 45 0c             	mov    0xc(%ebp),%eax
c002774c:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
  if (*format == '.') 
c0027753:	8b 45 08             	mov    0x8(%ebp),%eax
c0027756:	8a 00                	mov    (%eax),%al
c0027758:	3c 2e                	cmp    $0x2e,%al
c002775a:	0f 85 82 00 00 00    	jne    c00277e2 <parse_conversion+0x1fd>
    {
      format++;
c0027760:	ff 45 08             	incl   0x8(%ebp)
      if (*format == '*') 
c0027763:	8b 45 08             	mov    0x8(%ebp),%eax
c0027766:	8a 00                	mov    (%eax),%al
c0027768:	3c 2a                	cmp    $0x2a,%al
c002776a:	75 1a                	jne    c0027786 <parse_conversion+0x1a1>
        {
          format++;
c002776c:	ff 45 08             	incl   0x8(%ebp)
          c->precision = va_arg (*args, int);
c002776f:	8b 45 10             	mov    0x10(%ebp),%eax
c0027772:	8b 00                	mov    (%eax),%eax
c0027774:	8d 48 04             	lea    0x4(%eax),%ecx
c0027777:	8b 55 10             	mov    0x10(%ebp),%edx
c002777a:	89 0a                	mov    %ecx,(%edx)
c002777c:	8b 10                	mov    (%eax),%edx
c002777e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027781:	89 50 08             	mov    %edx,0x8(%eax)
c0027784:	eb 48                	jmp    c00277ce <parse_conversion+0x1e9>
        }
      else 
        {
          c->precision = 0;
c0027786:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027789:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          for (; isdigit (*format); format++)
c0027790:	eb 27                	jmp    c00277b9 <parse_conversion+0x1d4>
            c->precision = c->precision * 10 + *format - '0';
c0027792:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027795:	8b 50 08             	mov    0x8(%eax),%edx
c0027798:	89 d0                	mov    %edx,%eax
c002779a:	c1 e0 02             	shl    $0x2,%eax
c002779d:	01 d0                	add    %edx,%eax
c002779f:	01 c0                	add    %eax,%eax
c00277a1:	89 c2                	mov    %eax,%edx
c00277a3:	8b 45 08             	mov    0x8(%ebp),%eax
c00277a6:	8a 00                	mov    (%eax),%al
c00277a8:	0f be c0             	movsbl %al,%eax
c00277ab:	01 d0                	add    %edx,%eax
c00277ad:	8d 50 d0             	lea    -0x30(%eax),%edx
c00277b0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277b3:	89 50 08             	mov    %edx,0x8(%eax)
          for (; isdigit (*format); format++)
c00277b6:	ff 45 08             	incl   0x8(%ebp)
c00277b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00277bc:	8a 00                	mov    (%eax),%al
c00277be:	0f be c0             	movsbl %al,%eax
c00277c1:	50                   	push   %eax
c00277c2:	e8 c3 f8 ff ff       	call   c002708a <isdigit>
c00277c7:	83 c4 04             	add    $0x4,%esp
c00277ca:	85 c0                	test   %eax,%eax
c00277cc:	75 c4                	jne    c0027792 <parse_conversion+0x1ad>
        }
      if (c->precision < 0) 
c00277ce:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277d1:	8b 40 08             	mov    0x8(%eax),%eax
c00277d4:	85 c0                	test   %eax,%eax
c00277d6:	79 0a                	jns    c00277e2 <parse_conversion+0x1fd>
        c->precision = -1;
c00277d8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277db:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
    }
  if (c->precision >= 0)
c00277e2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277e5:	8b 40 08             	mov    0x8(%eax),%eax
c00277e8:	85 c0                	test   %eax,%eax
c00277ea:	78 0f                	js     c00277fb <parse_conversion+0x216>
    c->flags &= ~ZERO;
c00277ec:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277ef:	8b 00                	mov    (%eax),%eax
c00277f1:	83 e0 ef             	and    $0xffffffef,%eax
c00277f4:	89 c2                	mov    %eax,%edx
c00277f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277f9:	89 10                	mov    %edx,(%eax)

  /* Parse type. */
  c->type = INT;
c00277fb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277fe:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  switch (*format++) 
c0027805:	8b 45 08             	mov    0x8(%ebp),%eax
c0027808:	8d 50 01             	lea    0x1(%eax),%edx
c002780b:	89 55 08             	mov    %edx,0x8(%ebp)
c002780e:	8a 00                	mov    (%eax),%al
c0027810:	0f be c0             	movsbl %al,%eax
c0027813:	83 e8 68             	sub    $0x68,%eax
c0027816:	83 f8 12             	cmp    $0x12,%eax
c0027819:	77 75                	ja     c0027890 <parse_conversion+0x2ab>
c002781b:	8b 04 85 e0 07 03 c0 	mov    -0x3ffcf820(,%eax,4),%eax
c0027822:	ff e0                	jmp    *%eax
    {
    case 'h':
      if (*format == 'h') 
c0027824:	8b 45 08             	mov    0x8(%ebp),%eax
c0027827:	8a 00                	mov    (%eax),%al
c0027829:	3c 68                	cmp    $0x68,%al
c002782b:	75 0f                	jne    c002783c <parse_conversion+0x257>
        {
          format++;
c002782d:	ff 45 08             	incl   0x8(%ebp)
          c->type = CHAR;
c0027830:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027833:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
        }
      else
        c->type = SHORT;
      break;
c002783a:	eb 58                	jmp    c0027894 <parse_conversion+0x2af>
        c->type = SHORT;
c002783c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002783f:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
      break;
c0027846:	eb 4c                	jmp    c0027894 <parse_conversion+0x2af>
      
    case 'j':
      c->type = INTMAX;
c0027848:	8b 45 0c             	mov    0xc(%ebp),%eax
c002784b:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
      break;
c0027852:	eb 40                	jmp    c0027894 <parse_conversion+0x2af>

    case 'l':
      if (*format == 'l')
c0027854:	8b 45 08             	mov    0x8(%ebp),%eax
c0027857:	8a 00                	mov    (%eax),%al
c0027859:	3c 6c                	cmp    $0x6c,%al
c002785b:	75 0f                	jne    c002786c <parse_conversion+0x287>
        {
          format++;
c002785d:	ff 45 08             	incl   0x8(%ebp)
          c->type = LONGLONG;
c0027860:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027863:	c7 40 0c 06 00 00 00 	movl   $0x6,0xc(%eax)
        }
      else
        c->type = LONG;
      break;
c002786a:	eb 28                	jmp    c0027894 <parse_conversion+0x2af>
        c->type = LONG;
c002786c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002786f:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
      break;
c0027876:	eb 1c                	jmp    c0027894 <parse_conversion+0x2af>

    case 't':
      c->type = PTRDIFFT;
c0027878:	8b 45 0c             	mov    0xc(%ebp),%eax
c002787b:	c7 40 0c 07 00 00 00 	movl   $0x7,0xc(%eax)
      break;
c0027882:	eb 10                	jmp    c0027894 <parse_conversion+0x2af>

    case 'z':
      c->type = SIZET;
c0027884:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027887:	c7 40 0c 08 00 00 00 	movl   $0x8,0xc(%eax)
      break;
c002788e:	eb 04                	jmp    c0027894 <parse_conversion+0x2af>

    default:
      format--;
c0027890:	ff 4d 08             	decl   0x8(%ebp)
      break;
c0027893:	90                   	nop
    }

  return format;
c0027894:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0027897:	c9                   	leave  
c0027898:	c3                   	ret    

c0027899 <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
c0027899:	55                   	push   %ebp
c002789a:	89 e5                	mov    %esp,%ebp
c002789c:	57                   	push   %edi
c002789d:	56                   	push   %esi
c002789e:	53                   	push   %ebx
c002789f:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
c00278a5:	8b 45 10             	mov    0x10(%ebp),%eax
c00278a8:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
c00278ae:	8b 55 14             	mov    0x14(%ebp),%edx
c00278b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00278b4:	89 45 80             	mov    %eax,-0x80(%ebp)
c00278b7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278ba:	89 45 84             	mov    %eax,-0x7c(%ebp)
c00278bd:	8a 85 74 ff ff ff    	mov    -0x8c(%ebp),%al
c00278c3:	88 85 7c ff ff ff    	mov    %al,-0x84(%ebp)
c00278c9:	88 d0                	mov    %dl,%al
c00278cb:	88 85 78 ff ff ff    	mov    %al,-0x88(%ebp)
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
c00278d1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  if (is_signed) 
c00278d8:	80 bd 7c ff ff ff 00 	cmpb   $0x0,-0x84(%ebp)
c00278df:	74 5c                	je     c002793d <format_integer+0xa4>
    {
      if (c->flags & PLUS)
c00278e1:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00278e4:	8b 00                	mov    (%eax),%eax
c00278e6:	83 e0 02             	and    $0x2,%eax
c00278e9:	85 c0                	test   %eax,%eax
c00278eb:	74 1a                	je     c0027907 <format_integer+0x6e>
        sign = negative ? '-' : '+';
c00278ed:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c00278f4:	74 07                	je     c00278fd <format_integer+0x64>
c00278f6:	b8 2d 00 00 00       	mov    $0x2d,%eax
c00278fb:	eb 05                	jmp    c0027902 <format_integer+0x69>
c00278fd:	b8 2b 00 00 00       	mov    $0x2b,%eax
c0027902:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027905:	eb 36                	jmp    c002793d <format_integer+0xa4>
      else if (c->flags & SPACE)
c0027907:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002790a:	8b 00                	mov    (%eax),%eax
c002790c:	83 e0 04             	and    $0x4,%eax
c002790f:	85 c0                	test   %eax,%eax
c0027911:	74 1a                	je     c002792d <format_integer+0x94>
        sign = negative ? '-' : ' ';
c0027913:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c002791a:	74 07                	je     c0027923 <format_integer+0x8a>
c002791c:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027921:	eb 05                	jmp    c0027928 <format_integer+0x8f>
c0027923:	b8 20 00 00 00       	mov    $0x20,%eax
c0027928:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002792b:	eb 10                	jmp    c002793d <format_integer+0xa4>
      else if (negative)
c002792d:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027934:	74 07                	je     c002793d <format_integer+0xa4>
        sign = '-';
c0027936:	c7 45 e0 2d 00 00 00 	movl   $0x2d,-0x20(%ebp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
c002793d:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027940:	8b 00                	mov    (%eax),%eax
c0027942:	83 e0 08             	and    $0x8,%eax
c0027945:	85 c0                	test   %eax,%eax
c0027947:	74 20                	je     c0027969 <format_integer+0xd0>
c0027949:	8b 45 80             	mov    -0x80(%ebp),%eax
c002794c:	80 f4 00             	xor    $0x0,%ah
c002794f:	89 c1                	mov    %eax,%ecx
c0027951:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0027954:	80 f4 00             	xor    $0x0,%ah
c0027957:	89 c3                	mov    %eax,%ebx
c0027959:	89 d8                	mov    %ebx,%eax
c002795b:	09 c8                	or     %ecx,%eax
c002795d:	85 c0                	test   %eax,%eax
c002795f:	74 08                	je     c0027969 <format_integer+0xd0>
c0027961:	8b 45 18             	mov    0x18(%ebp),%eax
c0027964:	8b 40 08             	mov    0x8(%eax),%eax
c0027967:	eb 05                	jmp    c002796e <format_integer+0xd5>
c0027969:	b8 00 00 00 00       	mov    $0x0,%eax
c002796e:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
c0027971:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027974:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  digit_cnt = 0;
c0027977:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  while (value > 0) 
c002797e:	e9 8f 00 00 00       	jmp    c0027a12 <format_integer+0x179>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0027983:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027986:	8b 00                	mov    (%eax),%eax
c0027988:	83 e0 20             	and    $0x20,%eax
c002798b:	85 c0                	test   %eax,%eax
c002798d:	74 24                	je     c00279b3 <format_integer+0x11a>
c002798f:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c0027993:	7e 1e                	jle    c00279b3 <format_integer+0x11a>
c0027995:	8b 45 18             	mov    0x18(%ebp),%eax
c0027998:	8b 48 0c             	mov    0xc(%eax),%ecx
c002799b:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002799e:	99                   	cltd   
c002799f:	f7 f9                	idiv   %ecx
c00279a1:	89 d0                	mov    %edx,%eax
c00279a3:	85 c0                	test   %eax,%eax
c00279a5:	75 0c                	jne    c00279b3 <format_integer+0x11a>
        *cp++ = ',';
c00279a7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00279aa:	8d 50 01             	lea    0x1(%eax),%edx
c00279ad:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00279b0:	c6 00 2c             	movb   $0x2c,(%eax)
      *cp++ = b->digits[value % b->base];
c00279b3:	8b 45 18             	mov    0x18(%ebp),%eax
c00279b6:	8b 40 04             	mov    0x4(%eax),%eax
c00279b9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
c00279bf:	8b 45 18             	mov    0x18(%ebp),%eax
c00279c2:	8b 00                	mov    (%eax),%eax
c00279c4:	89 c1                	mov    %eax,%ecx
c00279c6:	89 c3                	mov    %eax,%ebx
c00279c8:	c1 fb 1f             	sar    $0x1f,%ebx
c00279cb:	8b 45 80             	mov    -0x80(%ebp),%eax
c00279ce:	8b 55 84             	mov    -0x7c(%ebp),%edx
c00279d1:	53                   	push   %ebx
c00279d2:	51                   	push   %ecx
c00279d3:	52                   	push   %edx
c00279d4:	50                   	push   %eax
c00279d5:	e8 eb 15 00 00       	call   c0028fc5 <__umoddi3>
c00279da:	83 c4 10             	add    $0x10,%esp
c00279dd:	8b 9d 74 ff ff ff    	mov    -0x8c(%ebp),%ebx
c00279e3:	8d 0c 03             	lea    (%ebx,%eax,1),%ecx
c00279e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00279e9:	8d 50 01             	lea    0x1(%eax),%edx
c00279ec:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00279ef:	8a 11                	mov    (%ecx),%dl
c00279f1:	88 10                	mov    %dl,(%eax)
      value /= b->base;
c00279f3:	8b 45 18             	mov    0x18(%ebp),%eax
c00279f6:	8b 00                	mov    (%eax),%eax
c00279f8:	99                   	cltd   
c00279f9:	52                   	push   %edx
c00279fa:	50                   	push   %eax
c00279fb:	ff 75 84             	push   -0x7c(%ebp)
c00279fe:	ff 75 80             	push   -0x80(%ebp)
c0027a01:	e8 8b 15 00 00       	call   c0028f91 <__udivdi3>
c0027a06:	83 c4 10             	add    $0x10,%esp
c0027a09:	89 45 80             	mov    %eax,-0x80(%ebp)
c0027a0c:	89 55 84             	mov    %edx,-0x7c(%ebp)
      digit_cnt++;
c0027a0f:	ff 45 d8             	incl   -0x28(%ebp)
  while (value > 0) 
c0027a12:	8b 45 80             	mov    -0x80(%ebp),%eax
c0027a15:	80 f4 00             	xor    $0x0,%ah
c0027a18:	89 c6                	mov    %eax,%esi
c0027a1a:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0027a1d:	80 f4 00             	xor    $0x0,%ah
c0027a20:	89 c7                	mov    %eax,%edi
c0027a22:	89 f8                	mov    %edi,%eax
c0027a24:	09 f0                	or     %esi,%eax
c0027a26:	85 c0                	test   %eax,%eax
c0027a28:	0f 85 55 ff ff ff    	jne    c0027983 <format_integer+0xea>
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
c0027a2e:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027a31:	8b 40 08             	mov    0x8(%eax),%eax
c0027a34:	85 c0                	test   %eax,%eax
c0027a36:	78 08                	js     c0027a40 <format_integer+0x1a7>
c0027a38:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027a3b:	8b 40 08             	mov    0x8(%eax),%eax
c0027a3e:	eb 05                	jmp    c0027a45 <format_integer+0x1ac>
c0027a40:	b8 01 00 00 00       	mov    $0x1,%eax
c0027a45:	89 45 d0             	mov    %eax,-0x30(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027a48:	eb 0c                	jmp    c0027a56 <format_integer+0x1bd>
    *cp++ = '0';
c0027a4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027a4d:	8d 50 01             	lea    0x1(%eax),%edx
c0027a50:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0027a53:	c6 00 30             	movb   $0x30,(%eax)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027a56:	8d 55 90             	lea    -0x70(%ebp),%edx
c0027a59:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027a5c:	29 d0                	sub    %edx,%eax
c0027a5e:	39 45 d0             	cmp    %eax,-0x30(%ebp)
c0027a61:	7e 0b                	jle    c0027a6e <format_integer+0x1d5>
c0027a63:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027a66:	83 c0 3f             	add    $0x3f,%eax
c0027a69:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0027a6c:	72 dc                	jb     c0027a4a <format_integer+0x1b1>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0027a6e:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027a71:	8b 00                	mov    (%eax),%eax
c0027a73:	83 e0 08             	and    $0x8,%eax
c0027a76:	85 c0                	test   %eax,%eax
c0027a78:	74 28                	je     c0027aa2 <format_integer+0x209>
c0027a7a:	8b 45 18             	mov    0x18(%ebp),%eax
c0027a7d:	8b 00                	mov    (%eax),%eax
c0027a7f:	83 f8 08             	cmp    $0x8,%eax
c0027a82:	75 1e                	jne    c0027aa2 <format_integer+0x209>
c0027a84:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027a87:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0027a8a:	74 0a                	je     c0027a96 <format_integer+0x1fd>
c0027a8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027a8f:	48                   	dec    %eax
c0027a90:	8a 00                	mov    (%eax),%al
c0027a92:	3c 30                	cmp    $0x30,%al
c0027a94:	74 0c                	je     c0027aa2 <format_integer+0x209>
    *cp++ = '0';
c0027a96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027a99:	8d 50 01             	lea    0x1(%eax),%edx
c0027a9c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0027a9f:	c6 00 30             	movb   $0x30,(%eax)

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c0027aa2:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027aa5:	8b 40 04             	mov    0x4(%eax),%eax
c0027aa8:	8d 55 90             	lea    -0x70(%ebp),%edx
c0027aab:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0027aae:	29 d1                	sub    %edx,%ecx
c0027ab0:	29 c8                	sub    %ecx,%eax
c0027ab2:	89 c2                	mov    %eax,%edx
c0027ab4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0027ab8:	74 07                	je     c0027ac1 <format_integer+0x228>
c0027aba:	b8 02 00 00 00       	mov    $0x2,%eax
c0027abf:	eb 05                	jmp    c0027ac6 <format_integer+0x22d>
c0027ac1:	b8 00 00 00 00       	mov    $0x0,%eax
c0027ac6:	89 d1                	mov    %edx,%ecx
c0027ac8:	29 c1                	sub    %eax,%ecx
c0027aca:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0027ace:	0f 95 c0             	setne  %al
c0027ad1:	0f b6 d0             	movzbl %al,%edx
c0027ad4:	89 c8                	mov    %ecx,%eax
c0027ad6:	29 d0                	sub    %edx,%eax
c0027ad8:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (pad_cnt < 0)
c0027adb:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0027adf:	79 07                	jns    c0027ae8 <format_integer+0x24f>
    pad_cnt = 0;
c0027ae1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
c0027ae8:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027aeb:	8b 00                	mov    (%eax),%eax
c0027aed:	83 e0 11             	and    $0x11,%eax
c0027af0:	85 c0                	test   %eax,%eax
c0027af2:	75 14                	jne    c0027b08 <format_integer+0x26f>
    output_dup (' ', pad_cnt, output, aux);
c0027af4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027af7:	ff 75 24             	push   0x24(%ebp)
c0027afa:	ff 75 20             	push   0x20(%ebp)
c0027afd:	50                   	push   %eax
c0027afe:	6a 20                	push   $0x20
c0027b00:	e8 b6 00 00 00       	call   c0027bbb <output_dup>
c0027b05:	83 c4 10             	add    $0x10,%esp
  if (sign)
c0027b08:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0027b0c:	74 15                	je     c0027b23 <format_integer+0x28a>
    output (sign, aux);
c0027b0e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027b11:	0f be c0             	movsbl %al,%eax
c0027b14:	83 ec 08             	sub    $0x8,%esp
c0027b17:	ff 75 24             	push   0x24(%ebp)
c0027b1a:	50                   	push   %eax
c0027b1b:	8b 45 20             	mov    0x20(%ebp),%eax
c0027b1e:	ff d0                	call   *%eax
c0027b20:	83 c4 10             	add    $0x10,%esp
  if (x) 
c0027b23:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0027b27:	74 25                	je     c0027b4e <format_integer+0x2b5>
    {
      output ('0', aux);
c0027b29:	83 ec 08             	sub    $0x8,%esp
c0027b2c:	ff 75 24             	push   0x24(%ebp)
c0027b2f:	6a 30                	push   $0x30
c0027b31:	8b 45 20             	mov    0x20(%ebp),%eax
c0027b34:	ff d0                	call   *%eax
c0027b36:	83 c4 10             	add    $0x10,%esp
      output (x, aux); 
c0027b39:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0027b3c:	0f be c0             	movsbl %al,%eax
c0027b3f:	83 ec 08             	sub    $0x8,%esp
c0027b42:	ff 75 24             	push   0x24(%ebp)
c0027b45:	50                   	push   %eax
c0027b46:	8b 45 20             	mov    0x20(%ebp),%eax
c0027b49:	ff d0                	call   *%eax
c0027b4b:	83 c4 10             	add    $0x10,%esp
    }
  if (c->flags & ZERO)
c0027b4e:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027b51:	8b 00                	mov    (%eax),%eax
c0027b53:	83 e0 10             	and    $0x10,%eax
c0027b56:	85 c0                	test   %eax,%eax
c0027b58:	74 30                	je     c0027b8a <format_integer+0x2f1>
    output_dup ('0', pad_cnt, output, aux);
c0027b5a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027b5d:	ff 75 24             	push   0x24(%ebp)
c0027b60:	ff 75 20             	push   0x20(%ebp)
c0027b63:	50                   	push   %eax
c0027b64:	6a 30                	push   $0x30
c0027b66:	e8 50 00 00 00       	call   c0027bbb <output_dup>
c0027b6b:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c0027b6e:	eb 1a                	jmp    c0027b8a <format_integer+0x2f1>
    output (*--cp, aux);
c0027b70:	ff 4d e4             	decl   -0x1c(%ebp)
c0027b73:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027b76:	8a 00                	mov    (%eax),%al
c0027b78:	0f be c0             	movsbl %al,%eax
c0027b7b:	83 ec 08             	sub    $0x8,%esp
c0027b7e:	ff 75 24             	push   0x24(%ebp)
c0027b81:	50                   	push   %eax
c0027b82:	8b 45 20             	mov    0x20(%ebp),%eax
c0027b85:	ff d0                	call   *%eax
c0027b87:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c0027b8a:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027b8d:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0027b90:	77 de                	ja     c0027b70 <format_integer+0x2d7>
  if (c->flags & MINUS)
c0027b92:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027b95:	8b 00                	mov    (%eax),%eax
c0027b97:	83 e0 01             	and    $0x1,%eax
c0027b9a:	85 c0                	test   %eax,%eax
c0027b9c:	74 14                	je     c0027bb2 <format_integer+0x319>
    output_dup (' ', pad_cnt, output, aux);
c0027b9e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027ba1:	ff 75 24             	push   0x24(%ebp)
c0027ba4:	ff 75 20             	push   0x20(%ebp)
c0027ba7:	50                   	push   %eax
c0027ba8:	6a 20                	push   $0x20
c0027baa:	e8 0c 00 00 00       	call   c0027bbb <output_dup>
c0027baf:	83 c4 10             	add    $0x10,%esp
}
c0027bb2:	90                   	nop
c0027bb3:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0027bb6:	5b                   	pop    %ebx
c0027bb7:	5e                   	pop    %esi
c0027bb8:	5f                   	pop    %edi
c0027bb9:	5d                   	pop    %ebp
c0027bba:	c3                   	ret    

c0027bbb <output_dup>:

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0027bbb:	55                   	push   %ebp
c0027bbc:	89 e5                	mov    %esp,%ebp
c0027bbe:	83 ec 18             	sub    $0x18,%esp
c0027bc1:	8b 45 08             	mov    0x8(%ebp),%eax
c0027bc4:	88 45 f4             	mov    %al,-0xc(%ebp)
  while (cnt-- > 0)
c0027bc7:	eb 13                	jmp    c0027bdc <output_dup+0x21>
    output (ch, aux);
c0027bc9:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0027bcd:	83 ec 08             	sub    $0x8,%esp
c0027bd0:	ff 75 14             	push   0x14(%ebp)
c0027bd3:	50                   	push   %eax
c0027bd4:	8b 45 10             	mov    0x10(%ebp),%eax
c0027bd7:	ff d0                	call   *%eax
c0027bd9:	83 c4 10             	add    $0x10,%esp
  while (cnt-- > 0)
c0027bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027bdf:	8d 50 ff             	lea    -0x1(%eax),%edx
c0027be2:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027be5:	85 c0                	test   %eax,%eax
c0027be7:	75 e0                	jne    c0027bc9 <output_dup+0xe>
}
c0027be9:	90                   	nop
c0027bea:	90                   	nop
c0027beb:	c9                   	leave  
c0027bec:	c3                   	ret    

c0027bed <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c0027bed:	55                   	push   %ebp
c0027bee:	89 e5                	mov    %esp,%ebp
c0027bf0:	83 ec 18             	sub    $0x18,%esp
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0027bf3:	8b 45 10             	mov    0x10(%ebp),%eax
c0027bf6:	8b 40 04             	mov    0x4(%eax),%eax
c0027bf9:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0027bfc:	7d 26                	jge    c0027c24 <format_string+0x37>
c0027bfe:	8b 45 10             	mov    0x10(%ebp),%eax
c0027c01:	8b 00                	mov    (%eax),%eax
c0027c03:	83 e0 01             	and    $0x1,%eax
c0027c06:	85 c0                	test   %eax,%eax
c0027c08:	75 1a                	jne    c0027c24 <format_string+0x37>
    output_dup (' ', c->width - length, output, aux);
c0027c0a:	8b 45 10             	mov    0x10(%ebp),%eax
c0027c0d:	8b 40 04             	mov    0x4(%eax),%eax
c0027c10:	2b 45 0c             	sub    0xc(%ebp),%eax
c0027c13:	ff 75 18             	push   0x18(%ebp)
c0027c16:	ff 75 14             	push   0x14(%ebp)
c0027c19:	50                   	push   %eax
c0027c1a:	6a 20                	push   $0x20
c0027c1c:	e8 9a ff ff ff       	call   c0027bbb <output_dup>
c0027c21:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c0027c24:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0027c2b:	eb 1f                	jmp    c0027c4c <format_string+0x5f>
    output (string[i], aux);
c0027c2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0027c30:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c33:	01 d0                	add    %edx,%eax
c0027c35:	8a 00                	mov    (%eax),%al
c0027c37:	0f be c0             	movsbl %al,%eax
c0027c3a:	83 ec 08             	sub    $0x8,%esp
c0027c3d:	ff 75 18             	push   0x18(%ebp)
c0027c40:	50                   	push   %eax
c0027c41:	8b 45 14             	mov    0x14(%ebp),%eax
c0027c44:	ff d0                	call   *%eax
c0027c46:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c0027c49:	ff 45 f4             	incl   -0xc(%ebp)
c0027c4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027c4f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027c52:	7c d9                	jl     c0027c2d <format_string+0x40>
  if (c->width > length && (c->flags & MINUS) != 0)
c0027c54:	8b 45 10             	mov    0x10(%ebp),%eax
c0027c57:	8b 40 04             	mov    0x4(%eax),%eax
c0027c5a:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0027c5d:	7d 26                	jge    c0027c85 <format_string+0x98>
c0027c5f:	8b 45 10             	mov    0x10(%ebp),%eax
c0027c62:	8b 00                	mov    (%eax),%eax
c0027c64:	83 e0 01             	and    $0x1,%eax
c0027c67:	85 c0                	test   %eax,%eax
c0027c69:	74 1a                	je     c0027c85 <format_string+0x98>
    output_dup (' ', c->width - length, output, aux);
c0027c6b:	8b 45 10             	mov    0x10(%ebp),%eax
c0027c6e:	8b 40 04             	mov    0x4(%eax),%eax
c0027c71:	2b 45 0c             	sub    0xc(%ebp),%eax
c0027c74:	ff 75 18             	push   0x18(%ebp)
c0027c77:	ff 75 14             	push   0x14(%ebp)
c0027c7a:	50                   	push   %eax
c0027c7b:	6a 20                	push   $0x20
c0027c7d:	e8 39 ff ff ff       	call   c0027bbb <output_dup>
c0027c82:	83 c4 10             	add    $0x10,%esp
}
c0027c85:	90                   	nop
c0027c86:	c9                   	leave  
c0027c87:	c3                   	ret    

c0027c88 <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c0027c88:	55                   	push   %ebp
c0027c89:	89 e5                	mov    %esp,%ebp
c0027c8b:	83 ec 18             	sub    $0x18,%esp
  va_list args;

  va_start (args, aux);
c0027c8e:	8d 45 14             	lea    0x14(%ebp),%eax
c0027c91:	89 45 f4             	mov    %eax,-0xc(%ebp)
  __vprintf (format, args, output, aux);
c0027c94:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027c97:	ff 75 10             	push   0x10(%ebp)
c0027c9a:	ff 75 0c             	push   0xc(%ebp)
c0027c9d:	50                   	push   %eax
c0027c9e:	ff 75 08             	push   0x8(%ebp)
c0027ca1:	e8 fc f4 ff ff       	call   c00271a2 <__vprintf>
c0027ca6:	83 c4 10             	add    $0x10,%esp
  va_end (args);
}
c0027ca9:	90                   	nop
c0027caa:	c9                   	leave  
c0027cab:	c3                   	ret    

c0027cac <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0027cac:	55                   	push   %ebp
c0027cad:	89 e5                	mov    %esp,%ebp
c0027caf:	83 ec 38             	sub    $0x38,%esp
c0027cb2:	8b 45 14             	mov    0x14(%ebp),%eax
c0027cb5:	88 45 d4             	mov    %al,-0x2c(%ebp)
  const uint8_t *buf = buf_;
c0027cb8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cbb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const size_t per_line = 16; /* Maximum bytes per line. */
c0027cbe:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)

  while (size > 0)
c0027cc5:	e9 b4 01 00 00       	jmp    c0027e7e <hex_dump+0x1d2>
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
c0027cca:	8b 45 08             	mov    0x8(%ebp),%eax
c0027ccd:	ba 00 00 00 00       	mov    $0x0,%edx
c0027cd2:	f7 75 e8             	divl   -0x18(%ebp)
c0027cd5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      end = per_line;
c0027cd8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027cdb:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (end - start > size)
c0027cde:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027ce1:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027ce4:	39 45 10             	cmp    %eax,0x10(%ebp)
c0027ce7:	73 0b                	jae    c0027cf4 <hex_dump+0x48>
        end = start + size;
c0027ce9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0027cec:	8b 45 10             	mov    0x10(%ebp),%eax
c0027cef:	01 d0                	add    %edx,%eax
c0027cf1:	89 45 f0             	mov    %eax,-0x10(%ebp)
      n = end - start;
c0027cf4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027cf7:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027cfa:	89 45 e0             	mov    %eax,-0x20(%ebp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027cfd:	8b 45 08             	mov    0x8(%ebp),%eax
c0027d00:	ba 00 00 00 00       	mov    $0x0,%edx
c0027d05:	f7 75 e8             	divl   -0x18(%ebp)
c0027d08:	0f af 45 e8          	imul   -0x18(%ebp),%eax
c0027d0c:	ba 00 00 00 00       	mov    $0x0,%edx
c0027d11:	83 ec 04             	sub    $0x4,%esp
c0027d14:	52                   	push   %edx
c0027d15:	50                   	push   %eax
c0027d16:	68 2c 08 03 c0       	push   $0xc003082c
c0027d1b:	e8 5c f4 ff ff       	call   c002717c <printf>
c0027d20:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c0027d23:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0027d2a:	eb 13                	jmp    c0027d3f <hex_dump+0x93>
        printf ("   ");
c0027d2c:	83 ec 0c             	sub    $0xc,%esp
c0027d2f:	68 34 08 03 c0       	push   $0xc0030834
c0027d34:	e8 43 f4 ff ff       	call   c002717c <printf>
c0027d39:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c0027d3c:	ff 45 ec             	incl   -0x14(%ebp)
c0027d3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027d42:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0027d45:	72 e5                	jb     c0027d2c <hex_dump+0x80>
      for (; i < end; i++) 
c0027d47:	eb 3e                	jmp    c0027d87 <hex_dump+0xdb>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027d49:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027d4c:	d1 e8                	shr    %eax
c0027d4e:	48                   	dec    %eax
        printf ("%02hhx%c",
c0027d4f:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c0027d52:	75 07                	jne    c0027d5b <hex_dump+0xaf>
c0027d54:	ba 2d 00 00 00       	mov    $0x2d,%edx
c0027d59:	eb 05                	jmp    c0027d60 <hex_dump+0xb4>
c0027d5b:	ba 20 00 00 00       	mov    $0x20,%edx
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027d60:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027d63:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027d66:	89 c1                	mov    %eax,%ecx
c0027d68:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027d6b:	01 c8                	add    %ecx,%eax
c0027d6d:	8a 00                	mov    (%eax),%al
        printf ("%02hhx%c",
c0027d6f:	0f b6 c0             	movzbl %al,%eax
c0027d72:	83 ec 04             	sub    $0x4,%esp
c0027d75:	52                   	push   %edx
c0027d76:	50                   	push   %eax
c0027d77:	68 38 08 03 c0       	push   $0xc0030838
c0027d7c:	e8 fb f3 ff ff       	call   c002717c <printf>
c0027d81:	83 c4 10             	add    $0x10,%esp
      for (; i < end; i++) 
c0027d84:	ff 45 ec             	incl   -0x14(%ebp)
c0027d87:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027d8a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0027d8d:	72 ba                	jb     c0027d49 <hex_dump+0x9d>
      if (ascii) 
c0027d8f:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
c0027d93:	0f 84 c6 00 00 00    	je     c0027e5f <hex_dump+0x1b3>
        {
          for (; i < per_line; i++)
c0027d99:	eb 13                	jmp    c0027dae <hex_dump+0x102>
            printf ("   ");
c0027d9b:	83 ec 0c             	sub    $0xc,%esp
c0027d9e:	68 34 08 03 c0       	push   $0xc0030834
c0027da3:	e8 d4 f3 ff ff       	call   c002717c <printf>
c0027da8:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
c0027dab:	ff 45 ec             	incl   -0x14(%ebp)
c0027dae:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027db1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0027db4:	72 e5                	jb     c0027d9b <hex_dump+0xef>
          printf ("|");
c0027db6:	83 ec 0c             	sub    $0xc,%esp
c0027db9:	6a 7c                	push   $0x7c
c0027dbb:	e8 a8 39 00 00       	call   c002b768 <putchar>
c0027dc0:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c0027dc3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0027dca:	eb 10                	jmp    c0027ddc <hex_dump+0x130>
            printf (" ");
c0027dcc:	83 ec 0c             	sub    $0xc,%esp
c0027dcf:	6a 20                	push   $0x20
c0027dd1:	e8 92 39 00 00       	call   c002b768 <putchar>
c0027dd6:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c0027dd9:	ff 45 ec             	incl   -0x14(%ebp)
c0027ddc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027ddf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0027de2:	72 e8                	jb     c0027dcc <hex_dump+0x120>
          for (; i < end; i++)
c0027de4:	eb 4a                	jmp    c0027e30 <hex_dump+0x184>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027de6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027de9:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027dec:	89 c2                	mov    %eax,%edx
c0027dee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027df1:	01 d0                	add    %edx,%eax
c0027df3:	8a 00                	mov    (%eax),%al
c0027df5:	0f b6 c0             	movzbl %al,%eax
c0027df8:	83 ec 0c             	sub    $0xc,%esp
c0027dfb:	50                   	push   %eax
c0027dfc:	e8 a6 f2 ff ff       	call   c00270a7 <isprint>
c0027e01:	83 c4 10             	add    $0x10,%esp
            printf ("%c",
c0027e04:	85 c0                	test   %eax,%eax
c0027e06:	74 14                	je     c0027e1c <hex_dump+0x170>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027e08:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027e0b:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027e0e:	89 c2                	mov    %eax,%edx
c0027e10:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027e13:	01 d0                	add    %edx,%eax
c0027e15:	8a 00                	mov    (%eax),%al
            printf ("%c",
c0027e17:	0f b6 c0             	movzbl %al,%eax
c0027e1a:	eb 05                	jmp    c0027e21 <hex_dump+0x175>
c0027e1c:	b8 2e 00 00 00       	mov    $0x2e,%eax
c0027e21:	83 ec 0c             	sub    $0xc,%esp
c0027e24:	50                   	push   %eax
c0027e25:	e8 3e 39 00 00       	call   c002b768 <putchar>
c0027e2a:	83 c4 10             	add    $0x10,%esp
          for (; i < end; i++)
c0027e2d:	ff 45 ec             	incl   -0x14(%ebp)
c0027e30:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027e33:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0027e36:	72 ae                	jb     c0027de6 <hex_dump+0x13a>
          for (; i < per_line; i++)
c0027e38:	eb 10                	jmp    c0027e4a <hex_dump+0x19e>
            printf (" ");
c0027e3a:	83 ec 0c             	sub    $0xc,%esp
c0027e3d:	6a 20                	push   $0x20
c0027e3f:	e8 24 39 00 00       	call   c002b768 <putchar>
c0027e44:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
c0027e47:	ff 45 ec             	incl   -0x14(%ebp)
c0027e4a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027e4d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0027e50:	72 e8                	jb     c0027e3a <hex_dump+0x18e>
          printf ("|");
c0027e52:	83 ec 0c             	sub    $0xc,%esp
c0027e55:	6a 7c                	push   $0x7c
c0027e57:	e8 0c 39 00 00       	call   c002b768 <putchar>
c0027e5c:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c0027e5f:	83 ec 0c             	sub    $0xc,%esp
c0027e62:	6a 0a                	push   $0xa
c0027e64:	e8 ff 38 00 00       	call   c002b768 <putchar>
c0027e69:	83 c4 10             	add    $0x10,%esp

      ofs += n;
c0027e6c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027e6f:	01 45 08             	add    %eax,0x8(%ebp)
      buf += n;
c0027e72:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027e75:	01 45 f4             	add    %eax,-0xc(%ebp)
      size -= n;
c0027e78:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027e7b:	29 45 10             	sub    %eax,0x10(%ebp)
  while (size > 0)
c0027e7e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0027e82:	0f 85 42 fe ff ff    	jne    c0027cca <hex_dump+0x1e>
    }
}
c0027e88:	90                   	nop
c0027e89:	90                   	nop
c0027e8a:	c9                   	leave  
c0027e8b:	c3                   	ret    

c0027e8c <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c0027e8c:	55                   	push   %ebp
c0027e8d:	89 e5                	mov    %esp,%ebp
c0027e8f:	83 ec 28             	sub    $0x28,%esp
c0027e92:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0027e95:	89 4d e0             	mov    %ecx,-0x20(%ebp)
c0027e98:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0027e9b:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  if (size == 1)
c0027e9e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c0027ea1:	83 f1 01             	xor    $0x1,%ecx
c0027ea4:	89 c8                	mov    %ecx,%eax
c0027ea6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0027ea9:	80 f5 00             	xor    $0x0,%ch
c0027eac:	89 ca                	mov    %ecx,%edx
c0027eae:	09 d0                	or     %edx,%eax
c0027eb0:	85 c0                	test   %eax,%eax
c0027eb2:	75 12                	jne    c0027ec6 <print_human_readable_size+0x3a>
    printf ("1 byte");
c0027eb4:	83 ec 0c             	sub    $0xc,%esp
c0027eb7:	68 41 08 03 c0       	push   $0xc0030841
c0027ebc:	e8 bb f2 ff ff       	call   c002717c <printf>
c0027ec1:	83 c4 10             	add    $0x10,%esp

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
    }
}
c0027ec4:	eb 57                	jmp    c0027f1d <print_human_readable_size+0x91>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027ec6:	c7 45 f4 68 38 03 c0 	movl   $0xc0033868,-0xc(%ebp)
c0027ecd:	eb 17                	jmp    c0027ee6 <print_human_readable_size+0x5a>
        size /= 1024;
c0027ecf:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027ed2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0027ed5:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0027ed9:	c1 ea 0a             	shr    $0xa,%edx
c0027edc:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027edf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027ee2:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c0027ee6:	ba ff 03 00 00       	mov    $0x3ff,%edx
c0027eeb:	b8 00 00 00 00       	mov    $0x0,%eax
c0027ef0:	3b 55 e0             	cmp    -0x20(%ebp),%edx
c0027ef3:	1b 45 e4             	sbb    -0x1c(%ebp),%eax
c0027ef6:	73 0c                	jae    c0027f04 <print_human_readable_size+0x78>
c0027ef8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027efb:	83 c0 04             	add    $0x4,%eax
c0027efe:	8b 00                	mov    (%eax),%eax
c0027f00:	85 c0                	test   %eax,%eax
c0027f02:	75 cb                	jne    c0027ecf <print_human_readable_size+0x43>
      printf ("%"PRIu64" %s", size, *fp);
c0027f04:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027f07:	8b 00                	mov    (%eax),%eax
c0027f09:	50                   	push   %eax
c0027f0a:	ff 75 e4             	push   -0x1c(%ebp)
c0027f0d:	ff 75 e0             	push   -0x20(%ebp)
c0027f10:	68 48 08 03 c0       	push   $0xc0030848
c0027f15:	e8 62 f2 ff ff       	call   c002717c <printf>
c0027f1a:	83 c4 10             	add    $0x10,%esp
}
c0027f1d:	90                   	nop
c0027f1e:	c9                   	leave  
c0027f1f:	c3                   	ret    

c0027f20 <isdigit>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0027f20:	55                   	push   %ebp
c0027f21:	89 e5                	mov    %esp,%ebp
c0027f23:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0027f27:	7e 0d                	jle    c0027f36 <isdigit+0x16>
c0027f29:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0027f2d:	7f 07                	jg     c0027f36 <isdigit+0x16>
c0027f2f:	b8 01 00 00 00       	mov    $0x1,%eax
c0027f34:	eb 05                	jmp    c0027f3b <isdigit+0x1b>
c0027f36:	b8 00 00 00 00       	mov    $0x0,%eax
c0027f3b:	5d                   	pop    %ebp
c0027f3c:	c3                   	ret    

c0027f3d <isspace>:
static inline int isspace (int c) {
c0027f3d:	55                   	push   %ebp
c0027f3e:	89 e5                	mov    %esp,%ebp
          || c == '\r' || c == '\t' || c == '\v');
c0027f40:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0027f44:	74 1e                	je     c0027f64 <isspace+0x27>
  return (c == ' ' || c == '\f' || c == '\n'
c0027f46:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c0027f4a:	74 18                	je     c0027f64 <isspace+0x27>
c0027f4c:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c0027f50:	74 12                	je     c0027f64 <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c0027f52:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c0027f56:	74 0c                	je     c0027f64 <isspace+0x27>
c0027f58:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0027f5c:	74 06                	je     c0027f64 <isspace+0x27>
c0027f5e:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0027f62:	75 07                	jne    c0027f6b <isspace+0x2e>
c0027f64:	b8 01 00 00 00       	mov    $0x1,%eax
c0027f69:	eb 05                	jmp    c0027f70 <isspace+0x33>
c0027f6b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0027f70:	5d                   	pop    %ebp
c0027f71:	c3                   	ret    

c0027f72 <atoi>:

/* Converts a string representation of a signed decimal integer
   in S into an `int', which is returned. */
int
atoi (const char *s) 
{
c0027f72:	55                   	push   %ebp
c0027f73:	89 e5                	mov    %esp,%ebp
c0027f75:	83 ec 18             	sub    $0x18,%esp
  bool negative;
  int value;

  ASSERT (s != NULL);
c0027f78:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0027f7c:	75 21                	jne    c0027f9f <atoi+0x2d>
c0027f7e:	83 ec 0c             	sub    $0xc,%esp
c0027f81:	68 6c 08 03 c0       	push   $0xc003086c
c0027f86:	68 76 08 03 c0       	push   $0xc0030876
c0027f8b:	68 d4 08 03 c0       	push   $0xc00308d4
c0027f90:	6a 0f                	push   $0xf
c0027f92:	68 8d 08 03 c0       	push   $0xc003088d
c0027f97:	e8 82 15 00 00       	call   c002951e <debug_panic>

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
    s++;
c0027f9c:	ff 45 08             	incl   0x8(%ebp)
  while (isspace ((unsigned char) *s))
c0027f9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0027fa2:	8a 00                	mov    (%eax),%al
c0027fa4:	0f b6 c0             	movzbl %al,%eax
c0027fa7:	83 ec 0c             	sub    $0xc,%esp
c0027faa:	50                   	push   %eax
c0027fab:	e8 8d ff ff ff       	call   c0027f3d <isspace>
c0027fb0:	83 c4 10             	add    $0x10,%esp
c0027fb3:	85 c0                	test   %eax,%eax
c0027fb5:	75 e5                	jne    c0027f9c <atoi+0x2a>

  /* Parse sign. */
  negative = false;
c0027fb7:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  if (*s == '+')
c0027fbb:	8b 45 08             	mov    0x8(%ebp),%eax
c0027fbe:	8a 00                	mov    (%eax),%al
c0027fc0:	3c 2b                	cmp    $0x2b,%al
c0027fc2:	75 05                	jne    c0027fc9 <atoi+0x57>
    s++;
c0027fc4:	ff 45 08             	incl   0x8(%ebp)
c0027fc7:	eb 10                	jmp    c0027fd9 <atoi+0x67>
  else if (*s == '-')
c0027fc9:	8b 45 08             	mov    0x8(%ebp),%eax
c0027fcc:	8a 00                	mov    (%eax),%al
c0027fce:	3c 2d                	cmp    $0x2d,%al
c0027fd0:	75 07                	jne    c0027fd9 <atoi+0x67>
    {
      negative = true;
c0027fd2:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
      s++;
c0027fd6:	ff 45 08             	incl   0x8(%ebp)

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c0027fd9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0027fe0:	eb 23                	jmp    c0028005 <atoi+0x93>
    value = value * 10 - (*s - '0');
c0027fe2:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0027fe5:	89 d0                	mov    %edx,%eax
c0027fe7:	c1 e0 02             	shl    $0x2,%eax
c0027fea:	01 d0                	add    %edx,%eax
c0027fec:	01 c0                	add    %eax,%eax
c0027fee:	89 c1                	mov    %eax,%ecx
c0027ff0:	8b 45 08             	mov    0x8(%ebp),%eax
c0027ff3:	8a 00                	mov    (%eax),%al
c0027ff5:	0f be c0             	movsbl %al,%eax
c0027ff8:	8d 50 d0             	lea    -0x30(%eax),%edx
c0027ffb:	89 c8                	mov    %ecx,%eax
c0027ffd:	29 d0                	sub    %edx,%eax
c0027fff:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (value = 0; isdigit (*s); s++)
c0028002:	ff 45 08             	incl   0x8(%ebp)
c0028005:	8b 45 08             	mov    0x8(%ebp),%eax
c0028008:	8a 00                	mov    (%eax),%al
c002800a:	0f be c0             	movsbl %al,%eax
c002800d:	83 ec 0c             	sub    $0xc,%esp
c0028010:	50                   	push   %eax
c0028011:	e8 0a ff ff ff       	call   c0027f20 <isdigit>
c0028016:	83 c4 10             	add    $0x10,%esp
c0028019:	85 c0                	test   %eax,%eax
c002801b:	75 c5                	jne    c0027fe2 <atoi+0x70>
  if (!negative)
c002801d:	8a 45 f7             	mov    -0x9(%ebp),%al
c0028020:	83 f0 01             	xor    $0x1,%eax
c0028023:	84 c0                	test   %al,%al
c0028025:	74 03                	je     c002802a <atoi+0xb8>
    value = -value;
c0028027:	f7 5d f0             	negl   -0x10(%ebp)

  return value;
c002802a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002802d:	c9                   	leave  
c002802e:	c3                   	ret    

c002802f <compare_thunk>:

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c002802f:	55                   	push   %ebp
c0028030:	89 e5                	mov    %esp,%ebp
c0028032:	83 ec 18             	sub    $0x18,%esp
  int (**compare) (const void *, const void *) = aux;
c0028035:	8b 45 10             	mov    0x10(%ebp),%eax
c0028038:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return (*compare) (a, b);
c002803b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002803e:	8b 00                	mov    (%eax),%eax
c0028040:	83 ec 08             	sub    $0x8,%esp
c0028043:	ff 75 0c             	push   0xc(%ebp)
c0028046:	ff 75 08             	push   0x8(%ebp)
c0028049:	ff d0                	call   *%eax
c002804b:	83 c4 10             	add    $0x10,%esp
}
c002804e:	c9                   	leave  
c002804f:	c3                   	ret    

c0028050 <qsort>:
   zero if A > B.  Runs in O(n lg n) time and O(1) space in
   CNT. */
void
qsort (void *array, size_t cnt, size_t size,
       int (*compare) (const void *, const void *)) 
{
c0028050:	55                   	push   %ebp
c0028051:	89 e5                	mov    %esp,%ebp
c0028053:	83 ec 08             	sub    $0x8,%esp
  sort (array, cnt, size, compare_thunk, &compare);
c0028056:	83 ec 0c             	sub    $0xc,%esp
c0028059:	8d 45 14             	lea    0x14(%ebp),%eax
c002805c:	50                   	push   %eax
c002805d:	68 2f 80 02 c0       	push   $0xc002802f
c0028062:	ff 75 10             	push   0x10(%ebp)
c0028065:	ff 75 0c             	push   0xc(%ebp)
c0028068:	ff 75 08             	push   0x8(%ebp)
c002806b:	e8 52 01 00 00       	call   c00281c2 <sort>
c0028070:	83 c4 20             	add    $0x20,%esp
}
c0028073:	90                   	nop
c0028074:	c9                   	leave  
c0028075:	c3                   	ret    

c0028076 <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c0028076:	55                   	push   %ebp
c0028077:	89 e5                	mov    %esp,%ebp
c0028079:	83 ec 10             	sub    $0x10,%esp
  unsigned char *a = array + (a_idx - 1) * size;
c002807c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002807f:	48                   	dec    %eax
c0028080:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028084:	89 c2                	mov    %eax,%edx
c0028086:	8b 45 08             	mov    0x8(%ebp),%eax
c0028089:	01 d0                	add    %edx,%eax
c002808b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned char *b = array + (b_idx - 1) * size;
c002808e:	8b 45 10             	mov    0x10(%ebp),%eax
c0028091:	48                   	dec    %eax
c0028092:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028096:	89 c2                	mov    %eax,%edx
c0028098:	8b 45 08             	mov    0x8(%ebp),%eax
c002809b:	01 d0                	add    %edx,%eax
c002809d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t i;

  for (i = 0; i < size; i++)
c00280a0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00280a7:	eb 31                	jmp    c00280da <do_swap+0x64>
    {
      unsigned char t = a[i];
c00280a9:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00280ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00280af:	01 d0                	add    %edx,%eax
c00280b1:	8a 00                	mov    (%eax),%al
c00280b3:	88 45 f3             	mov    %al,-0xd(%ebp)
      a[i] = b[i];
c00280b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00280b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00280bc:	01 d0                	add    %edx,%eax
c00280be:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c00280c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00280c4:	01 ca                	add    %ecx,%edx
c00280c6:	8a 00                	mov    (%eax),%al
c00280c8:	88 02                	mov    %al,(%edx)
      b[i] = t;
c00280ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00280cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00280d0:	01 c2                	add    %eax,%edx
c00280d2:	8a 45 f3             	mov    -0xd(%ebp),%al
c00280d5:	88 02                	mov    %al,(%edx)
  for (i = 0; i < size; i++)
c00280d7:	ff 45 fc             	incl   -0x4(%ebp)
c00280da:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00280dd:	3b 45 14             	cmp    0x14(%ebp),%eax
c00280e0:	72 c7                	jb     c00280a9 <do_swap+0x33>
    }
}
c00280e2:	90                   	nop
c00280e3:	90                   	nop
c00280e4:	c9                   	leave  
c00280e5:	c3                   	ret    

c00280e6 <do_compare>:
   strcmp()-type result. */
static int
do_compare (unsigned char *array, size_t a_idx, size_t b_idx, size_t size,
            int (*compare) (const void *, const void *, void *aux),
            void *aux) 
{
c00280e6:	55                   	push   %ebp
c00280e7:	89 e5                	mov    %esp,%ebp
c00280e9:	83 ec 08             	sub    $0x8,%esp
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c00280ec:	8b 45 10             	mov    0x10(%ebp),%eax
c00280ef:	48                   	dec    %eax
c00280f0:	0f af 45 14          	imul   0x14(%ebp),%eax
c00280f4:	89 c2                	mov    %eax,%edx
c00280f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00280f9:	01 c2                	add    %eax,%edx
c00280fb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00280fe:	48                   	dec    %eax
c00280ff:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028103:	89 c1                	mov    %eax,%ecx
c0028105:	8b 45 08             	mov    0x8(%ebp),%eax
c0028108:	01 c8                	add    %ecx,%eax
c002810a:	83 ec 04             	sub    $0x4,%esp
c002810d:	ff 75 1c             	push   0x1c(%ebp)
c0028110:	52                   	push   %edx
c0028111:	50                   	push   %eax
c0028112:	8b 45 18             	mov    0x18(%ebp),%eax
c0028115:	ff d0                	call   *%eax
c0028117:	83 c4 10             	add    $0x10,%esp
}
c002811a:	c9                   	leave  
c002811b:	c3                   	ret    

c002811c <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c002811c:	55                   	push   %ebp
c002811d:	89 e5                	mov    %esp,%ebp
c002811f:	83 ec 18             	sub    $0x18,%esp
  for (;;) 
    {
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
c0028122:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028125:	01 c0                	add    %eax,%eax
c0028127:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t right = 2 * i + 1;
c002812a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002812d:	01 c0                	add    %eax,%eax
c002812f:	40                   	inc    %eax
c0028130:	89 45 ec             	mov    %eax,-0x14(%ebp)
      size_t max = i;
c0028133:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028136:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0028139:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002813c:	3b 45 10             	cmp    0x10(%ebp),%eax
c002813f:	77 27                	ja     c0028168 <heapify+0x4c>
c0028141:	83 ec 08             	sub    $0x8,%esp
c0028144:	ff 75 1c             	push   0x1c(%ebp)
c0028147:	ff 75 18             	push   0x18(%ebp)
c002814a:	ff 75 14             	push   0x14(%ebp)
c002814d:	ff 75 f4             	push   -0xc(%ebp)
c0028150:	ff 75 f0             	push   -0x10(%ebp)
c0028153:	ff 75 08             	push   0x8(%ebp)
c0028156:	e8 8b ff ff ff       	call   c00280e6 <do_compare>
c002815b:	83 c4 20             	add    $0x20,%esp
c002815e:	85 c0                	test   %eax,%eax
c0028160:	7e 06                	jle    c0028168 <heapify+0x4c>
        max = left;
c0028162:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028165:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (right <= cnt
c0028168:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002816b:	3b 45 10             	cmp    0x10(%ebp),%eax
c002816e:	77 27                	ja     c0028197 <heapify+0x7b>
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0028170:	83 ec 08             	sub    $0x8,%esp
c0028173:	ff 75 1c             	push   0x1c(%ebp)
c0028176:	ff 75 18             	push   0x18(%ebp)
c0028179:	ff 75 14             	push   0x14(%ebp)
c002817c:	ff 75 f4             	push   -0xc(%ebp)
c002817f:	ff 75 ec             	push   -0x14(%ebp)
c0028182:	ff 75 08             	push   0x8(%ebp)
c0028185:	e8 5c ff ff ff       	call   c00280e6 <do_compare>
c002818a:	83 c4 20             	add    $0x20,%esp
c002818d:	85 c0                	test   %eax,%eax
c002818f:	7e 06                	jle    c0028197 <heapify+0x7b>
        max = right;
c0028191:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028194:	89 45 f4             	mov    %eax,-0xc(%ebp)

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c0028197:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002819a:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002819d:	74 1f                	je     c00281be <heapify+0xa2>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c002819f:	ff 75 14             	push   0x14(%ebp)
c00281a2:	ff 75 f4             	push   -0xc(%ebp)
c00281a5:	ff 75 0c             	push   0xc(%ebp)
c00281a8:	ff 75 08             	push   0x8(%ebp)
c00281ab:	e8 c6 fe ff ff       	call   c0028076 <do_swap>
c00281b0:	83 c4 10             	add    $0x10,%esp
      i = max;
c00281b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00281b6:	89 45 0c             	mov    %eax,0xc(%ebp)
    {
c00281b9:	e9 64 ff ff ff       	jmp    c0028122 <heapify+0x6>
        break;
c00281be:	90                   	nop
    }
}
c00281bf:	90                   	nop
c00281c0:	c9                   	leave  
c00281c1:	c3                   	ret    

c00281c2 <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c00281c2:	55                   	push   %ebp
c00281c3:	89 e5                	mov    %esp,%ebp
c00281c5:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c00281c8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00281cc:	75 27                	jne    c00281f5 <sort+0x33>
c00281ce:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00281d2:	74 21                	je     c00281f5 <sort+0x33>
c00281d4:	83 ec 0c             	sub    $0xc,%esp
c00281d7:	68 a0 08 03 c0       	push   $0xc00308a0
c00281dc:	68 76 08 03 c0       	push   $0xc0030876
c00281e1:	68 dc 08 03 c0       	push   $0xc00308dc
c00281e6:	68 8a 00 00 00       	push   $0x8a
c00281eb:	68 8d 08 03 c0       	push   $0xc003088d
c00281f0:	e8 29 13 00 00       	call   c002951e <debug_panic>
  ASSERT (compare != NULL);
c00281f5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c00281f9:	75 21                	jne    c002821c <sort+0x5a>
c00281fb:	83 ec 0c             	sub    $0xc,%esp
c00281fe:	68 ba 08 03 c0       	push   $0xc00308ba
c0028203:	68 76 08 03 c0       	push   $0xc0030876
c0028208:	68 dc 08 03 c0       	push   $0xc00308dc
c002820d:	68 8b 00 00 00       	push   $0x8b
c0028212:	68 8d 08 03 c0       	push   $0xc003088d
c0028217:	e8 02 13 00 00       	call   c002951e <debug_panic>
  ASSERT (size > 0);
c002821c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028220:	75 21                	jne    c0028243 <sort+0x81>
c0028222:	83 ec 0c             	sub    $0xc,%esp
c0028225:	68 ca 08 03 c0       	push   $0xc00308ca
c002822a:	68 76 08 03 c0       	push   $0xc0030876
c002822f:	68 dc 08 03 c0       	push   $0xc00308dc
c0028234:	68 8c 00 00 00       	push   $0x8c
c0028239:	68 8d 08 03 c0       	push   $0xc003088d
c002823e:	e8 db 12 00 00       	call   c002951e <debug_panic>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c0028243:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028246:	d1 e8                	shr    %eax
c0028248:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002824b:	eb 20                	jmp    c002826d <sort+0xab>
    heapify (array, i, cnt, size, compare, aux);
c002824d:	83 ec 08             	sub    $0x8,%esp
c0028250:	ff 75 18             	push   0x18(%ebp)
c0028253:	ff 75 14             	push   0x14(%ebp)
c0028256:	ff 75 10             	push   0x10(%ebp)
c0028259:	ff 75 0c             	push   0xc(%ebp)
c002825c:	ff 75 f4             	push   -0xc(%ebp)
c002825f:	ff 75 08             	push   0x8(%ebp)
c0028262:	e8 b5 fe ff ff       	call   c002811c <heapify>
c0028267:	83 c4 20             	add    $0x20,%esp
  for (i = cnt / 2; i > 0; i--)
c002826a:	ff 4d f4             	decl   -0xc(%ebp)
c002826d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028271:	75 da                	jne    c002824d <sort+0x8b>

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c0028273:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028276:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028279:	eb 34                	jmp    c00282af <sort+0xed>
    {
      do_swap (array, 1, i, size);
c002827b:	ff 75 10             	push   0x10(%ebp)
c002827e:	ff 75 f4             	push   -0xc(%ebp)
c0028281:	6a 01                	push   $0x1
c0028283:	ff 75 08             	push   0x8(%ebp)
c0028286:	e8 eb fd ff ff       	call   c0028076 <do_swap>
c002828b:	83 c4 10             	add    $0x10,%esp
      heapify (array, 1, i - 1, size, compare, aux); 
c002828e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028291:	48                   	dec    %eax
c0028292:	83 ec 08             	sub    $0x8,%esp
c0028295:	ff 75 18             	push   0x18(%ebp)
c0028298:	ff 75 14             	push   0x14(%ebp)
c002829b:	ff 75 10             	push   0x10(%ebp)
c002829e:	50                   	push   %eax
c002829f:	6a 01                	push   $0x1
c00282a1:	ff 75 08             	push   0x8(%ebp)
c00282a4:	e8 73 fe ff ff       	call   c002811c <heapify>
c00282a9:	83 c4 20             	add    $0x20,%esp
  for (i = cnt; i > 1; i--) 
c00282ac:	ff 4d f4             	decl   -0xc(%ebp)
c00282af:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c00282b3:	77 c6                	ja     c002827b <sort+0xb9>
    }
}
c00282b5:	90                   	nop
c00282b6:	90                   	nop
c00282b7:	c9                   	leave  
c00282b8:	c3                   	ret    

c00282b9 <bsearch>:
   strcmp()-type result, i.e. less than zero if A < B, zero if A
   == B, greater than zero if A > B. */
void *
bsearch (const void *key, const void *array, size_t cnt,
         size_t size, int (*compare) (const void *, const void *)) 
{
c00282b9:	55                   	push   %ebp
c00282ba:	89 e5                	mov    %esp,%ebp
c00282bc:	83 ec 08             	sub    $0x8,%esp
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c00282bf:	83 ec 08             	sub    $0x8,%esp
c00282c2:	8d 45 18             	lea    0x18(%ebp),%eax
c00282c5:	50                   	push   %eax
c00282c6:	68 2f 80 02 c0       	push   $0xc002802f
c00282cb:	ff 75 14             	push   0x14(%ebp)
c00282ce:	ff 75 10             	push   0x10(%ebp)
c00282d1:	ff 75 0c             	push   0xc(%ebp)
c00282d4:	ff 75 08             	push   0x8(%ebp)
c00282d7:	e8 05 00 00 00       	call   c00282e1 <binary_search>
c00282dc:	83 c4 20             	add    $0x20,%esp
}
c00282df:	c9                   	leave  
c00282e0:	c3                   	ret    

c00282e1 <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c00282e1:	55                   	push   %ebp
c00282e2:	89 e5                	mov    %esp,%ebp
c00282e4:	83 ec 28             	sub    $0x28,%esp
  const unsigned char *first = array;
c00282e7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00282ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *last = array + size * cnt;
c00282ed:	8b 45 14             	mov    0x14(%ebp),%eax
c00282f0:	0f af 45 10          	imul   0x10(%ebp),%eax
c00282f4:	89 c2                	mov    %eax,%edx
c00282f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00282f9:	01 d0                	add    %edx,%eax
c00282fb:	89 45 f0             	mov    %eax,-0x10(%ebp)

  while (first < last) 
c00282fe:	eb 61                	jmp    c0028361 <binary_search+0x80>
    {
      size_t range = (last - first) / size;
c0028300:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028303:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0028306:	ba 00 00 00 00       	mov    $0x0,%edx
c002830b:	f7 75 14             	divl   0x14(%ebp)
c002830e:	89 45 ec             	mov    %eax,-0x14(%ebp)
      const unsigned char *middle = first + (range / 2) * size;
c0028311:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028314:	d1 e8                	shr    %eax
c0028316:	0f af 45 14          	imul   0x14(%ebp),%eax
c002831a:	89 c2                	mov    %eax,%edx
c002831c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002831f:	01 d0                	add    %edx,%eax
c0028321:	89 45 e8             	mov    %eax,-0x18(%ebp)
      int cmp = compare (key, middle, aux);
c0028324:	83 ec 04             	sub    $0x4,%esp
c0028327:	ff 75 1c             	push   0x1c(%ebp)
c002832a:	ff 75 e8             	push   -0x18(%ebp)
c002832d:	ff 75 08             	push   0x8(%ebp)
c0028330:	8b 45 18             	mov    0x18(%ebp),%eax
c0028333:	ff d0                	call   *%eax
c0028335:	83 c4 10             	add    $0x10,%esp
c0028338:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if (cmp < 0) 
c002833b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002833f:	79 08                	jns    c0028349 <binary_search+0x68>
        last = middle;
c0028341:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028344:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028347:	eb 18                	jmp    c0028361 <binary_search+0x80>
      else if (cmp > 0) 
c0028349:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002834d:	7e 0d                	jle    c002835c <binary_search+0x7b>
        first = middle + size;
c002834f:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0028352:	8b 45 14             	mov    0x14(%ebp),%eax
c0028355:	01 d0                	add    %edx,%eax
c0028357:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002835a:	eb 05                	jmp    c0028361 <binary_search+0x80>
      else
        return (void *) middle;
c002835c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002835f:	eb 0d                	jmp    c002836e <binary_search+0x8d>
  while (first < last) 
c0028361:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028364:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028367:	72 97                	jb     c0028300 <binary_search+0x1f>
    }
  
  return NULL;
c0028369:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002836e:	c9                   	leave  
c002836f:	c3                   	ret    

c0028370 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c0028370:	55                   	push   %ebp
c0028371:	89 e5                	mov    %esp,%ebp
c0028373:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028376:	8b 45 08             	mov    0x8(%ebp),%eax
c0028379:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c002837c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002837f:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028382:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028386:	75 24                	jne    c00283ac <memcpy+0x3c>
c0028388:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002838c:	74 1e                	je     c00283ac <memcpy+0x3c>
c002838e:	83 ec 0c             	sub    $0xc,%esp
c0028391:	68 e4 08 03 c0       	push   $0xc00308e4
c0028396:	68 fd 08 03 c0       	push   $0xc00308fd
c002839b:	68 f4 09 03 c0       	push   $0xc00309f4
c00283a0:	6a 0c                	push   $0xc
c00283a2:	68 14 09 03 c0       	push   $0xc0030914
c00283a7:	e8 72 11 00 00       	call   c002951e <debug_panic>
  ASSERT (src != NULL || size == 0);
c00283ac:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00283b0:	75 3a                	jne    c00283ec <memcpy+0x7c>
c00283b2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00283b6:	74 34                	je     c00283ec <memcpy+0x7c>
c00283b8:	83 ec 0c             	sub    $0xc,%esp
c00283bb:	68 27 09 03 c0       	push   $0xc0030927
c00283c0:	68 fd 08 03 c0       	push   $0xc00308fd
c00283c5:	68 f4 09 03 c0       	push   $0xc00309f4
c00283ca:	6a 0d                	push   $0xd
c00283cc:	68 14 09 03 c0       	push   $0xc0030914
c00283d1:	e8 48 11 00 00       	call   c002951e <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
c00283d6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00283d9:	8d 42 01             	lea    0x1(%edx),%eax
c00283dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00283df:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00283e2:	8d 48 01             	lea    0x1(%eax),%ecx
c00283e5:	89 4d f4             	mov    %ecx,-0xc(%ebp)
c00283e8:	8a 12                	mov    (%edx),%dl
c00283ea:	88 10                	mov    %dl,(%eax)
  while (size-- > 0)
c00283ec:	8b 45 10             	mov    0x10(%ebp),%eax
c00283ef:	8d 50 ff             	lea    -0x1(%eax),%edx
c00283f2:	89 55 10             	mov    %edx,0x10(%ebp)
c00283f5:	85 c0                	test   %eax,%eax
c00283f7:	75 dd                	jne    c00283d6 <memcpy+0x66>

  return dst_;
c00283f9:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00283fc:	c9                   	leave  
c00283fd:	c3                   	ret    

c00283fe <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c00283fe:	55                   	push   %ebp
c00283ff:	89 e5                	mov    %esp,%ebp
c0028401:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028404:	8b 45 08             	mov    0x8(%ebp),%eax
c0028407:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c002840a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002840d:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028410:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028414:	75 24                	jne    c002843a <memmove+0x3c>
c0028416:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002841a:	74 1e                	je     c002843a <memmove+0x3c>
c002841c:	83 ec 0c             	sub    $0xc,%esp
c002841f:	68 e4 08 03 c0       	push   $0xc00308e4
c0028424:	68 fd 08 03 c0       	push   $0xc00308fd
c0028429:	68 fc 09 03 c0       	push   $0xc00309fc
c002842e:	6a 1d                	push   $0x1d
c0028430:	68 14 09 03 c0       	push   $0xc0030914
c0028435:	e8 e4 10 00 00       	call   c002951e <debug_panic>
  ASSERT (src != NULL || size == 0);
c002843a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002843e:	75 24                	jne    c0028464 <memmove+0x66>
c0028440:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028444:	74 1e                	je     c0028464 <memmove+0x66>
c0028446:	83 ec 0c             	sub    $0xc,%esp
c0028449:	68 27 09 03 c0       	push   $0xc0030927
c002844e:	68 fd 08 03 c0       	push   $0xc00308fd
c0028453:	68 fc 09 03 c0       	push   $0xc00309fc
c0028458:	6a 1e                	push   $0x1e
c002845a:	68 14 09 03 c0       	push   $0xc0030914
c002845f:	e8 ba 10 00 00       	call   c002951e <debug_panic>

  if (dst < src) 
c0028464:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028467:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002846a:	73 27                	jae    c0028493 <memmove+0x95>
    {
      while (size-- > 0)
c002846c:	eb 16                	jmp    c0028484 <memmove+0x86>
        *dst++ = *src++;
c002846e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028471:	8d 42 01             	lea    0x1(%edx),%eax
c0028474:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028477:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002847a:	8d 48 01             	lea    0x1(%eax),%ecx
c002847d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
c0028480:	8a 12                	mov    (%edx),%dl
c0028482:	88 10                	mov    %dl,(%eax)
      while (size-- > 0)
c0028484:	8b 45 10             	mov    0x10(%ebp),%eax
c0028487:	8d 50 ff             	lea    -0x1(%eax),%edx
c002848a:	89 55 10             	mov    %edx,0x10(%ebp)
c002848d:	85 c0                	test   %eax,%eax
c002848f:	75 dd                	jne    c002846e <memmove+0x70>
c0028491:	eb 2b                	jmp    c00284be <memmove+0xc0>
    }
  else 
    {
      dst += size;
c0028493:	8b 45 10             	mov    0x10(%ebp),%eax
c0028496:	01 45 f4             	add    %eax,-0xc(%ebp)
      src += size;
c0028499:	8b 45 10             	mov    0x10(%ebp),%eax
c002849c:	01 45 f0             	add    %eax,-0x10(%ebp)
      while (size-- > 0)
c002849f:	eb 10                	jmp    c00284b1 <memmove+0xb3>
        *--dst = *--src;
c00284a1:	ff 4d f0             	decl   -0x10(%ebp)
c00284a4:	ff 4d f4             	decl   -0xc(%ebp)
c00284a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00284aa:	8a 10                	mov    (%eax),%dl
c00284ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00284af:	88 10                	mov    %dl,(%eax)
      while (size-- > 0)
c00284b1:	8b 45 10             	mov    0x10(%ebp),%eax
c00284b4:	8d 50 ff             	lea    -0x1(%eax),%edx
c00284b7:	89 55 10             	mov    %edx,0x10(%ebp)
c00284ba:	85 c0                	test   %eax,%eax
c00284bc:	75 e3                	jne    c00284a1 <memmove+0xa3>
    }

  return dst;
c00284be:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00284c1:	c9                   	leave  
c00284c2:	c3                   	ret    

c00284c3 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c00284c3:	55                   	push   %ebp
c00284c4:	89 e5                	mov    %esp,%ebp
c00284c6:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = a_;
c00284c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00284cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = b_;
c00284cf:	8b 45 0c             	mov    0xc(%ebp),%eax
c00284d2:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL || size == 0);
c00284d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00284d9:	75 24                	jne    c00284ff <memcmp+0x3c>
c00284db:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00284df:	74 1e                	je     c00284ff <memcmp+0x3c>
c00284e1:	83 ec 0c             	sub    $0xc,%esp
c00284e4:	68 40 09 03 c0       	push   $0xc0030940
c00284e9:	68 fd 08 03 c0       	push   $0xc00308fd
c00284ee:	68 04 0a 03 c0       	push   $0xc0030a04
c00284f3:	6a 3a                	push   $0x3a
c00284f5:	68 14 09 03 c0       	push   $0xc0030914
c00284fa:	e8 1f 10 00 00       	call   c002951e <debug_panic>
  ASSERT (b != NULL || size == 0);
c00284ff:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028503:	75 54                	jne    c0028559 <memcmp+0x96>
c0028505:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028509:	74 4e                	je     c0028559 <memcmp+0x96>
c002850b:	83 ec 0c             	sub    $0xc,%esp
c002850e:	68 57 09 03 c0       	push   $0xc0030957
c0028513:	68 fd 08 03 c0       	push   $0xc00308fd
c0028518:	68 04 0a 03 c0       	push   $0xc0030a04
c002851d:	6a 3b                	push   $0x3b
c002851f:	68 14 09 03 c0       	push   $0xc0030914
c0028524:	e8 f5 0f 00 00       	call   c002951e <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
c0028529:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002852c:	8a 10                	mov    (%eax),%dl
c002852e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028531:	8a 00                	mov    (%eax),%al
c0028533:	38 c2                	cmp    %al,%dl
c0028535:	74 1c                	je     c0028553 <memcmp+0x90>
      return *a > *b ? +1 : -1;
c0028537:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002853a:	8a 10                	mov    (%eax),%dl
c002853c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002853f:	8a 00                	mov    (%eax),%al
c0028541:	38 c2                	cmp    %al,%dl
c0028543:	76 07                	jbe    c002854c <memcmp+0x89>
c0028545:	b8 01 00 00 00       	mov    $0x1,%eax
c002854a:	eb 1f                	jmp    c002856b <memcmp+0xa8>
c002854c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0028551:	eb 18                	jmp    c002856b <memcmp+0xa8>
  for (; size-- > 0; a++, b++)
c0028553:	ff 45 f4             	incl   -0xc(%ebp)
c0028556:	ff 45 f0             	incl   -0x10(%ebp)
c0028559:	8b 45 10             	mov    0x10(%ebp),%eax
c002855c:	8d 50 ff             	lea    -0x1(%eax),%edx
c002855f:	89 55 10             	mov    %edx,0x10(%ebp)
c0028562:	85 c0                	test   %eax,%eax
c0028564:	75 c3                	jne    c0028529 <memcmp+0x66>
  return 0;
c0028566:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002856b:	c9                   	leave  
c002856c:	c3                   	ret    

c002856d <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c002856d:	55                   	push   %ebp
c002856e:	89 e5                	mov    %esp,%ebp
c0028570:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = (const unsigned char *) a_;
c0028573:	8b 45 08             	mov    0x8(%ebp),%eax
c0028576:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = (const unsigned char *) b_;
c0028579:	8b 45 0c             	mov    0xc(%ebp),%eax
c002857c:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL);
c002857f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028583:	75 1e                	jne    c00285a3 <strcmp+0x36>
c0028585:	83 ec 0c             	sub    $0xc,%esp
c0028588:	68 6e 09 03 c0       	push   $0xc003096e
c002858d:	68 fd 08 03 c0       	push   $0xc00308fd
c0028592:	68 0c 0a 03 c0       	push   $0xc0030a0c
c0028597:	6a 4e                	push   $0x4e
c0028599:	68 14 09 03 c0       	push   $0xc0030914
c002859e:	e8 7b 0f 00 00       	call   c002951e <debug_panic>
  ASSERT (b != NULL);
c00285a3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00285a7:	75 24                	jne    c00285cd <strcmp+0x60>
c00285a9:	83 ec 0c             	sub    $0xc,%esp
c00285ac:	68 78 09 03 c0       	push   $0xc0030978
c00285b1:	68 fd 08 03 c0       	push   $0xc00308fd
c00285b6:	68 0c 0a 03 c0       	push   $0xc0030a0c
c00285bb:	6a 4f                	push   $0x4f
c00285bd:	68 14 09 03 c0       	push   $0xc0030914
c00285c2:	e8 57 0f 00 00       	call   c002951e <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
c00285c7:	ff 45 f4             	incl   -0xc(%ebp)
      b++;
c00285ca:	ff 45 f0             	incl   -0x10(%ebp)
  while (*a != '\0' && *a == *b) 
c00285cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00285d0:	8a 00                	mov    (%eax),%al
c00285d2:	84 c0                	test   %al,%al
c00285d4:	74 0e                	je     c00285e4 <strcmp+0x77>
c00285d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00285d9:	8a 10                	mov    (%eax),%dl
c00285db:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00285de:	8a 00                	mov    (%eax),%al
c00285e0:	38 c2                	cmp    %al,%dl
c00285e2:	74 e3                	je     c00285c7 <strcmp+0x5a>
    }

  return *a < *b ? -1 : *a > *b;
c00285e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00285e7:	8a 10                	mov    (%eax),%dl
c00285e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00285ec:	8a 00                	mov    (%eax),%al
c00285ee:	38 c2                	cmp    %al,%dl
c00285f0:	72 14                	jb     c0028606 <strcmp+0x99>
c00285f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00285f5:	8a 10                	mov    (%eax),%dl
c00285f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00285fa:	8a 00                	mov    (%eax),%al
c00285fc:	38 c2                	cmp    %al,%dl
c00285fe:	0f 97 c0             	seta   %al
c0028601:	0f b6 c0             	movzbl %al,%eax
c0028604:	eb 05                	jmp    c002860b <strcmp+0x9e>
c0028606:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002860b:	c9                   	leave  
c002860c:	c3                   	ret    

c002860d <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c002860d:	55                   	push   %ebp
c002860e:	89 e5                	mov    %esp,%ebp
c0028610:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *block = block_;
c0028613:	8b 45 08             	mov    0x8(%ebp),%eax
c0028616:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned char ch = ch_;
c0028619:	8b 45 0c             	mov    0xc(%ebp),%eax
c002861c:	88 45 f3             	mov    %al,-0xd(%ebp)

  ASSERT (block != NULL || size == 0);
c002861f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028623:	75 36                	jne    c002865b <memchr+0x4e>
c0028625:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028629:	74 30                	je     c002865b <memchr+0x4e>
c002862b:	83 ec 0c             	sub    $0xc,%esp
c002862e:	68 82 09 03 c0       	push   $0xc0030982
c0028633:	68 fd 08 03 c0       	push   $0xc00308fd
c0028638:	68 14 0a 03 c0       	push   $0xc0030a14
c002863d:	6a 63                	push   $0x63
c002863f:	68 14 09 03 c0       	push   $0xc0030914
c0028644:	e8 d5 0e 00 00       	call   c002951e <debug_panic>

  for (; size-- > 0; block++)
    if (*block == ch)
c0028649:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002864c:	8a 00                	mov    (%eax),%al
c002864e:	38 45 f3             	cmp    %al,-0xd(%ebp)
c0028651:	75 05                	jne    c0028658 <memchr+0x4b>
      return (void *) block;
c0028653:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028656:	eb 15                	jmp    c002866d <memchr+0x60>
  for (; size-- > 0; block++)
c0028658:	ff 45 f4             	incl   -0xc(%ebp)
c002865b:	8b 45 10             	mov    0x10(%ebp),%eax
c002865e:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028661:	89 55 10             	mov    %edx,0x10(%ebp)
c0028664:	85 c0                	test   %eax,%eax
c0028666:	75 e1                	jne    c0028649 <memchr+0x3c>

  return NULL;
c0028668:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002866d:	c9                   	leave  
c002866e:	c3                   	ret    

c002866f <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c002866f:	55                   	push   %ebp
c0028670:	89 e5                	mov    %esp,%ebp
c0028672:	83 ec 18             	sub    $0x18,%esp
  char c = c_;
c0028675:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028678:	88 45 f7             	mov    %al,-0x9(%ebp)

  ASSERT (string != NULL);
c002867b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002867f:	75 1e                	jne    c002869f <strchr+0x30>
c0028681:	83 ec 0c             	sub    $0xc,%esp
c0028684:	68 9d 09 03 c0       	push   $0xc003099d
c0028689:	68 fd 08 03 c0       	push   $0xc00308fd
c002868e:	68 1c 0a 03 c0       	push   $0xc0030a1c
c0028693:	6a 75                	push   $0x75
c0028695:	68 14 09 03 c0       	push   $0xc0030914
c002869a:	e8 7f 0e 00 00       	call   c002951e <debug_panic>

  for (;;) 
    if (*string == c)
c002869f:	8b 45 08             	mov    0x8(%ebp),%eax
c00286a2:	8a 00                	mov    (%eax),%al
c00286a4:	38 45 f7             	cmp    %al,-0x9(%ebp)
c00286a7:	75 05                	jne    c00286ae <strchr+0x3f>
      return (char *) string;
c00286a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00286ac:	eb 15                	jmp    c00286c3 <strchr+0x54>
    else if (*string == '\0')
c00286ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00286b1:	8a 00                	mov    (%eax),%al
c00286b3:	84 c0                	test   %al,%al
c00286b5:	75 07                	jne    c00286be <strchr+0x4f>
      return NULL;
c00286b7:	b8 00 00 00 00       	mov    $0x0,%eax
c00286bc:	eb 05                	jmp    c00286c3 <strchr+0x54>
    else
      string++;
c00286be:	ff 45 08             	incl   0x8(%ebp)
    if (*string == c)
c00286c1:	eb dc                	jmp    c002869f <strchr+0x30>
}
c00286c3:	c9                   	leave  
c00286c4:	c3                   	ret    

c00286c5 <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c00286c5:	55                   	push   %ebp
c00286c6:	89 e5                	mov    %esp,%ebp
c00286c8:	83 ec 18             	sub    $0x18,%esp
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c00286cb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00286d2:	eb 23                	jmp    c00286f7 <strcspn+0x32>
    if (strchr (stop, string[length]) != NULL)
c00286d4:	8b 55 08             	mov    0x8(%ebp),%edx
c00286d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00286da:	01 d0                	add    %edx,%eax
c00286dc:	8a 00                	mov    (%eax),%al
c00286de:	0f be c0             	movsbl %al,%eax
c00286e1:	83 ec 08             	sub    $0x8,%esp
c00286e4:	50                   	push   %eax
c00286e5:	ff 75 0c             	push   0xc(%ebp)
c00286e8:	e8 82 ff ff ff       	call   c002866f <strchr>
c00286ed:	83 c4 10             	add    $0x10,%esp
c00286f0:	85 c0                	test   %eax,%eax
c00286f2:	75 13                	jne    c0028707 <strcspn+0x42>
  for (length = 0; string[length] != '\0'; length++)
c00286f4:	ff 45 f4             	incl   -0xc(%ebp)
c00286f7:	8b 55 08             	mov    0x8(%ebp),%edx
c00286fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00286fd:	01 d0                	add    %edx,%eax
c00286ff:	8a 00                	mov    (%eax),%al
c0028701:	84 c0                	test   %al,%al
c0028703:	75 cf                	jne    c00286d4 <strcspn+0xf>
c0028705:	eb 01                	jmp    c0028708 <strcspn+0x43>
      break;
c0028707:	90                   	nop
  return length;
c0028708:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002870b:	c9                   	leave  
c002870c:	c3                   	ret    

c002870d <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c002870d:	55                   	push   %ebp
c002870e:	89 e5                	mov    %esp,%ebp
c0028710:	83 ec 08             	sub    $0x8,%esp
  for (; *string != '\0'; string++)
c0028713:	eb 23                	jmp    c0028738 <strpbrk+0x2b>
    if (strchr (stop, *string) != NULL)
c0028715:	8b 45 08             	mov    0x8(%ebp),%eax
c0028718:	8a 00                	mov    (%eax),%al
c002871a:	0f be c0             	movsbl %al,%eax
c002871d:	83 ec 08             	sub    $0x8,%esp
c0028720:	50                   	push   %eax
c0028721:	ff 75 0c             	push   0xc(%ebp)
c0028724:	e8 46 ff ff ff       	call   c002866f <strchr>
c0028729:	83 c4 10             	add    $0x10,%esp
c002872c:	85 c0                	test   %eax,%eax
c002872e:	74 05                	je     c0028735 <strpbrk+0x28>
      return (char *) string;
c0028730:	8b 45 08             	mov    0x8(%ebp),%eax
c0028733:	eb 11                	jmp    c0028746 <strpbrk+0x39>
  for (; *string != '\0'; string++)
c0028735:	ff 45 08             	incl   0x8(%ebp)
c0028738:	8b 45 08             	mov    0x8(%ebp),%eax
c002873b:	8a 00                	mov    (%eax),%al
c002873d:	84 c0                	test   %al,%al
c002873f:	75 d4                	jne    c0028715 <strpbrk+0x8>
  return NULL;
c0028741:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028746:	c9                   	leave  
c0028747:	c3                   	ret    

c0028748 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c0028748:	55                   	push   %ebp
c0028749:	89 e5                	mov    %esp,%ebp
c002874b:	83 ec 10             	sub    $0x10,%esp
  char c = c_;
c002874e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028751:	88 45 fb             	mov    %al,-0x5(%ebp)
  const char *p = NULL;
c0028754:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

  for (; *string != '\0'; string++)
c002875b:	eb 13                	jmp    c0028770 <strrchr+0x28>
    if (*string == c)
c002875d:	8b 45 08             	mov    0x8(%ebp),%eax
c0028760:	8a 00                	mov    (%eax),%al
c0028762:	38 45 fb             	cmp    %al,-0x5(%ebp)
c0028765:	75 06                	jne    c002876d <strrchr+0x25>
      p = string;
c0028767:	8b 45 08             	mov    0x8(%ebp),%eax
c002876a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  for (; *string != '\0'; string++)
c002876d:	ff 45 08             	incl   0x8(%ebp)
c0028770:	8b 45 08             	mov    0x8(%ebp),%eax
c0028773:	8a 00                	mov    (%eax),%al
c0028775:	84 c0                	test   %al,%al
c0028777:	75 e4                	jne    c002875d <strrchr+0x15>
  return (char *) p;
c0028779:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c002877c:	c9                   	leave  
c002877d:	c3                   	ret    

c002877e <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c002877e:	55                   	push   %ebp
c002877f:	89 e5                	mov    %esp,%ebp
c0028781:	83 ec 18             	sub    $0x18,%esp
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c0028784:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002878b:	eb 23                	jmp    c00287b0 <strspn+0x32>
    if (strchr (skip, string[length]) == NULL)
c002878d:	8b 55 08             	mov    0x8(%ebp),%edx
c0028790:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028793:	01 d0                	add    %edx,%eax
c0028795:	8a 00                	mov    (%eax),%al
c0028797:	0f be c0             	movsbl %al,%eax
c002879a:	83 ec 08             	sub    $0x8,%esp
c002879d:	50                   	push   %eax
c002879e:	ff 75 0c             	push   0xc(%ebp)
c00287a1:	e8 c9 fe ff ff       	call   c002866f <strchr>
c00287a6:	83 c4 10             	add    $0x10,%esp
c00287a9:	85 c0                	test   %eax,%eax
c00287ab:	74 13                	je     c00287c0 <strspn+0x42>
  for (length = 0; string[length] != '\0'; length++)
c00287ad:	ff 45 f4             	incl   -0xc(%ebp)
c00287b0:	8b 55 08             	mov    0x8(%ebp),%edx
c00287b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00287b6:	01 d0                	add    %edx,%eax
c00287b8:	8a 00                	mov    (%eax),%al
c00287ba:	84 c0                	test   %al,%al
c00287bc:	75 cf                	jne    c002878d <strspn+0xf>
c00287be:	eb 01                	jmp    c00287c1 <strspn+0x43>
      break;
c00287c0:	90                   	nop
  return length;
c00287c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00287c4:	c9                   	leave  
c00287c5:	c3                   	ret    

c00287c6 <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
c00287c6:	55                   	push   %ebp
c00287c7:	89 e5                	mov    %esp,%ebp
c00287c9:	83 ec 18             	sub    $0x18,%esp
  size_t haystack_len = strlen (haystack);
c00287cc:	83 ec 0c             	sub    $0xc,%esp
c00287cf:	ff 75 08             	push   0x8(%ebp)
c00287d2:	e8 cc 01 00 00       	call   c00289a3 <strlen>
c00287d7:	83 c4 10             	add    $0x10,%esp
c00287da:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t needle_len = strlen (needle);
c00287dd:	83 ec 0c             	sub    $0xc,%esp
c00287e0:	ff 75 0c             	push   0xc(%ebp)
c00287e3:	e8 bb 01 00 00       	call   c00289a3 <strlen>
c00287e8:	83 c4 10             	add    $0x10,%esp
c00287eb:	89 45 ec             	mov    %eax,-0x14(%ebp)

  if (haystack_len >= needle_len) 
c00287ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00287f1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00287f4:	72 3f                	jb     c0028835 <strstr+0x6f>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c00287f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00287fd:	eb 2b                	jmp    c002882a <strstr+0x64>
        if (!memcmp (haystack + i, needle, needle_len))
c00287ff:	8b 55 08             	mov    0x8(%ebp),%edx
c0028802:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028805:	01 d0                	add    %edx,%eax
c0028807:	83 ec 04             	sub    $0x4,%esp
c002880a:	ff 75 ec             	push   -0x14(%ebp)
c002880d:	ff 75 0c             	push   0xc(%ebp)
c0028810:	50                   	push   %eax
c0028811:	e8 ad fc ff ff       	call   c00284c3 <memcmp>
c0028816:	83 c4 10             	add    $0x10,%esp
c0028819:	85 c0                	test   %eax,%eax
c002881b:	75 0a                	jne    c0028827 <strstr+0x61>
          return (char *) haystack + i;
c002881d:	8b 55 08             	mov    0x8(%ebp),%edx
c0028820:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028823:	01 d0                	add    %edx,%eax
c0028825:	eb 13                	jmp    c002883a <strstr+0x74>
      for (i = 0; i <= haystack_len - needle_len; i++)
c0028827:	ff 45 f4             	incl   -0xc(%ebp)
c002882a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002882d:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0028830:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0028833:	76 ca                	jbe    c00287ff <strstr+0x39>
    }

  return NULL;
c0028835:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002883a:	c9                   	leave  
c002883b:	c3                   	ret    

c002883c <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c002883c:	55                   	push   %ebp
c002883d:	89 e5                	mov    %esp,%ebp
c002883f:	83 ec 18             	sub    $0x18,%esp
  char *token;
  
  ASSERT (delimiters != NULL);
c0028842:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028846:	75 21                	jne    c0028869 <strtok_r+0x2d>
c0028848:	83 ec 0c             	sub    $0xc,%esp
c002884b:	68 ac 09 03 c0       	push   $0xc00309ac
c0028850:	68 fd 08 03 c0       	push   $0xc00308fd
c0028855:	68 24 0a 03 c0       	push   $0xc0030a24
c002885a:	68 ef 00 00 00       	push   $0xef
c002885f:	68 14 09 03 c0       	push   $0xc0030914
c0028864:	e8 b5 0c 00 00       	call   c002951e <debug_panic>
  ASSERT (save_ptr != NULL);
c0028869:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002886d:	75 21                	jne    c0028890 <strtok_r+0x54>
c002886f:	83 ec 0c             	sub    $0xc,%esp
c0028872:	68 bf 09 03 c0       	push   $0xc00309bf
c0028877:	68 fd 08 03 c0       	push   $0xc00308fd
c002887c:	68 24 0a 03 c0       	push   $0xc0030a24
c0028881:	68 f0 00 00 00       	push   $0xf0
c0028886:	68 14 09 03 c0       	push   $0xc0030914
c002888b:	e8 8e 0c 00 00       	call   c002951e <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0028890:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028894:	75 08                	jne    c002889e <strtok_r+0x62>
    s = *save_ptr;
c0028896:	8b 45 10             	mov    0x10(%ebp),%eax
c0028899:	8b 00                	mov    (%eax),%eax
c002889b:	89 45 08             	mov    %eax,0x8(%ebp)
  ASSERT (s != NULL);
c002889e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00288a2:	75 3c                	jne    c00288e0 <strtok_r+0xa4>
c00288a4:	83 ec 0c             	sub    $0xc,%esp
c00288a7:	68 d0 09 03 c0       	push   $0xc00309d0
c00288ac:	68 fd 08 03 c0       	push   $0xc00308fd
c00288b1:	68 24 0a 03 c0       	push   $0xc0030a24
c00288b6:	68 f6 00 00 00       	push   $0xf6
c00288bb:	68 14 09 03 c0       	push   $0xc0030914
c00288c0:	e8 59 0c 00 00       	call   c002951e <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c00288c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00288c8:	8a 00                	mov    (%eax),%al
c00288ca:	84 c0                	test   %al,%al
c00288cc:	75 0f                	jne    c00288dd <strtok_r+0xa1>
        {
          *save_ptr = s;
c00288ce:	8b 45 10             	mov    0x10(%ebp),%eax
c00288d1:	8b 55 08             	mov    0x8(%ebp),%edx
c00288d4:	89 10                	mov    %edx,(%eax)
          return NULL;
c00288d6:	b8 00 00 00 00       	mov    $0x0,%eax
c00288db:	eb 6b                	jmp    c0028948 <strtok_r+0x10c>
        }

      s++;
c00288dd:	ff 45 08             	incl   0x8(%ebp)
  while (strchr (delimiters, *s) != NULL) 
c00288e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00288e3:	8a 00                	mov    (%eax),%al
c00288e5:	0f be c0             	movsbl %al,%eax
c00288e8:	83 ec 08             	sub    $0x8,%esp
c00288eb:	50                   	push   %eax
c00288ec:	ff 75 0c             	push   0xc(%ebp)
c00288ef:	e8 7b fd ff ff       	call   c002866f <strchr>
c00288f4:	83 c4 10             	add    $0x10,%esp
c00288f7:	85 c0                	test   %eax,%eax
c00288f9:	75 ca                	jne    c00288c5 <strtok_r+0x89>
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
c00288fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00288fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (strchr (delimiters, *s) == NULL)
c0028901:	eb 03                	jmp    c0028906 <strtok_r+0xca>
    s++;
c0028903:	ff 45 08             	incl   0x8(%ebp)
  while (strchr (delimiters, *s) == NULL)
c0028906:	8b 45 08             	mov    0x8(%ebp),%eax
c0028909:	8a 00                	mov    (%eax),%al
c002890b:	0f be c0             	movsbl %al,%eax
c002890e:	83 ec 08             	sub    $0x8,%esp
c0028911:	50                   	push   %eax
c0028912:	ff 75 0c             	push   0xc(%ebp)
c0028915:	e8 55 fd ff ff       	call   c002866f <strchr>
c002891a:	83 c4 10             	add    $0x10,%esp
c002891d:	85 c0                	test   %eax,%eax
c002891f:	74 e2                	je     c0028903 <strtok_r+0xc7>
  if (*s != '\0') 
c0028921:	8b 45 08             	mov    0x8(%ebp),%eax
c0028924:	8a 00                	mov    (%eax),%al
c0028926:	84 c0                	test   %al,%al
c0028928:	74 13                	je     c002893d <strtok_r+0x101>
    {
      *s = '\0';
c002892a:	8b 45 08             	mov    0x8(%ebp),%eax
c002892d:	c6 00 00             	movb   $0x0,(%eax)
      *save_ptr = s + 1;
c0028930:	8b 45 08             	mov    0x8(%ebp),%eax
c0028933:	8d 50 01             	lea    0x1(%eax),%edx
c0028936:	8b 45 10             	mov    0x10(%ebp),%eax
c0028939:	89 10                	mov    %edx,(%eax)
c002893b:	eb 08                	jmp    c0028945 <strtok_r+0x109>
    }
  else 
    *save_ptr = s;
c002893d:	8b 45 10             	mov    0x10(%ebp),%eax
c0028940:	8b 55 08             	mov    0x8(%ebp),%edx
c0028943:	89 10                	mov    %edx,(%eax)
  return token;
c0028945:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028948:	c9                   	leave  
c0028949:	c3                   	ret    

c002894a <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c002894a:	55                   	push   %ebp
c002894b:	89 e5                	mov    %esp,%ebp
c002894d:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028950:	8b 45 08             	mov    0x8(%ebp),%eax
c0028953:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028956:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002895a:	75 35                	jne    c0028991 <memset+0x47>
c002895c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028960:	74 2f                	je     c0028991 <memset+0x47>
c0028962:	83 ec 0c             	sub    $0xc,%esp
c0028965:	68 e4 08 03 c0       	push   $0xc00308e4
c002896a:	68 fd 08 03 c0       	push   $0xc00308fd
c002896f:	68 30 0a 03 c0       	push   $0xc0030a30
c0028974:	68 1b 01 00 00       	push   $0x11b
c0028979:	68 14 09 03 c0       	push   $0xc0030914
c002897e:	e8 9b 0b 00 00       	call   c002951e <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
c0028983:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028986:	8d 50 01             	lea    0x1(%eax),%edx
c0028989:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002898c:	8b 55 0c             	mov    0xc(%ebp),%edx
c002898f:	88 10                	mov    %dl,(%eax)
  while (size-- > 0)
c0028991:	8b 45 10             	mov    0x10(%ebp),%eax
c0028994:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028997:	89 55 10             	mov    %edx,0x10(%ebp)
c002899a:	85 c0                	test   %eax,%eax
c002899c:	75 e5                	jne    c0028983 <memset+0x39>

  return dst_;
c002899e:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00289a1:	c9                   	leave  
c00289a2:	c3                   	ret    

c00289a3 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c00289a3:	55                   	push   %ebp
c00289a4:	89 e5                	mov    %esp,%ebp
c00289a6:	83 ec 18             	sub    $0x18,%esp
  const char *p;

  ASSERT (string != NULL);
c00289a9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00289ad:	75 21                	jne    c00289d0 <strlen+0x2d>
c00289af:	83 ec 0c             	sub    $0xc,%esp
c00289b2:	68 9d 09 03 c0       	push   $0xc003099d
c00289b7:	68 fd 08 03 c0       	push   $0xc00308fd
c00289bc:	68 38 0a 03 c0       	push   $0xc0030a38
c00289c1:	68 29 01 00 00       	push   $0x129
c00289c6:	68 14 09 03 c0       	push   $0xc0030914
c00289cb:	e8 4e 0b 00 00       	call   c002951e <debug_panic>

  for (p = string; *p != '\0'; p++)
c00289d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00289d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00289d6:	eb 03                	jmp    c00289db <strlen+0x38>
c00289d8:	ff 45 f4             	incl   -0xc(%ebp)
c00289db:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00289de:	8a 00                	mov    (%eax),%al
c00289e0:	84 c0                	test   %al,%al
c00289e2:	75 f4                	jne    c00289d8 <strlen+0x35>
    continue;
  return p - string;
c00289e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00289e7:	2b 45 08             	sub    0x8(%ebp),%eax
}
c00289ea:	c9                   	leave  
c00289eb:	c3                   	ret    

c00289ec <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c00289ec:	55                   	push   %ebp
c00289ed:	89 e5                	mov    %esp,%ebp
c00289ef:	83 ec 10             	sub    $0x10,%esp
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c00289f2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00289f9:	eb 03                	jmp    c00289fe <strnlen+0x12>
c00289fb:	ff 45 fc             	incl   -0x4(%ebp)
c00289fe:	8b 55 08             	mov    0x8(%ebp),%edx
c0028a01:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028a04:	01 d0                	add    %edx,%eax
c0028a06:	8a 00                	mov    (%eax),%al
c0028a08:	84 c0                	test   %al,%al
c0028a0a:	74 08                	je     c0028a14 <strnlen+0x28>
c0028a0c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028a0f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0028a12:	72 e7                	jb     c00289fb <strnlen+0xf>
    continue;
  return length;
c0028a14:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028a17:	c9                   	leave  
c0028a18:	c3                   	ret    

c0028a19 <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c0028a19:	55                   	push   %ebp
c0028a1a:	89 e5                	mov    %esp,%ebp
c0028a1c:	83 ec 18             	sub    $0x18,%esp
  size_t src_len;

  ASSERT (dst != NULL);
c0028a1f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028a23:	75 21                	jne    c0028a46 <strlcpy+0x2d>
c0028a25:	83 ec 0c             	sub    $0xc,%esp
c0028a28:	68 da 09 03 c0       	push   $0xc00309da
c0028a2d:	68 fd 08 03 c0       	push   $0xc00308fd
c0028a32:	68 40 0a 03 c0       	push   $0xc0030a40
c0028a37:	68 4a 01 00 00       	push   $0x14a
c0028a3c:	68 14 09 03 c0       	push   $0xc0030914
c0028a41:	e8 d8 0a 00 00       	call   c002951e <debug_panic>
  ASSERT (src != NULL);
c0028a46:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028a4a:	75 21                	jne    c0028a6d <strlcpy+0x54>
c0028a4c:	83 ec 0c             	sub    $0xc,%esp
c0028a4f:	68 e6 09 03 c0       	push   $0xc00309e6
c0028a54:	68 fd 08 03 c0       	push   $0xc00308fd
c0028a59:	68 40 0a 03 c0       	push   $0xc0030a40
c0028a5e:	68 4b 01 00 00       	push   $0x14b
c0028a63:	68 14 09 03 c0       	push   $0xc0030914
c0028a68:	e8 b1 0a 00 00       	call   c002951e <debug_panic>

  src_len = strlen (src);
c0028a6d:	83 ec 0c             	sub    $0xc,%esp
c0028a70:	ff 75 0c             	push   0xc(%ebp)
c0028a73:	e8 2b ff ff ff       	call   c00289a3 <strlen>
c0028a78:	83 c4 10             	add    $0x10,%esp
c0028a7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (size > 0) 
c0028a7e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028a82:	74 34                	je     c0028ab8 <strlcpy+0x9f>
    {
      size_t dst_len = size - 1;
c0028a84:	8b 45 10             	mov    0x10(%ebp),%eax
c0028a87:	48                   	dec    %eax
c0028a88:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < dst_len)
c0028a8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028a8e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028a91:	73 06                	jae    c0028a99 <strlcpy+0x80>
        dst_len = src_len;
c0028a93:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028a96:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst, src, dst_len);
c0028a99:	83 ec 04             	sub    $0x4,%esp
c0028a9c:	ff 75 f4             	push   -0xc(%ebp)
c0028a9f:	ff 75 0c             	push   0xc(%ebp)
c0028aa2:	ff 75 08             	push   0x8(%ebp)
c0028aa5:	e8 c6 f8 ff ff       	call   c0028370 <memcpy>
c0028aaa:	83 c4 10             	add    $0x10,%esp
      dst[dst_len] = '\0';
c0028aad:	8b 55 08             	mov    0x8(%ebp),%edx
c0028ab0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028ab3:	01 d0                	add    %edx,%eax
c0028ab5:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len;
c0028ab8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028abb:	c9                   	leave  
c0028abc:	c3                   	ret    

c0028abd <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c0028abd:	55                   	push   %ebp
c0028abe:	89 e5                	mov    %esp,%ebp
c0028ac0:	83 ec 18             	sub    $0x18,%esp
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c0028ac3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028ac7:	75 21                	jne    c0028aea <strlcat+0x2d>
c0028ac9:	83 ec 0c             	sub    $0xc,%esp
c0028acc:	68 da 09 03 c0       	push   $0xc00309da
c0028ad1:	68 fd 08 03 c0       	push   $0xc00308fd
c0028ad6:	68 48 0a 03 c0       	push   $0xc0030a48
c0028adb:	68 68 01 00 00       	push   $0x168
c0028ae0:	68 14 09 03 c0       	push   $0xc0030914
c0028ae5:	e8 34 0a 00 00       	call   c002951e <debug_panic>
  ASSERT (src != NULL);
c0028aea:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028aee:	75 21                	jne    c0028b11 <strlcat+0x54>
c0028af0:	83 ec 0c             	sub    $0xc,%esp
c0028af3:	68 e6 09 03 c0       	push   $0xc00309e6
c0028af8:	68 fd 08 03 c0       	push   $0xc00308fd
c0028afd:	68 48 0a 03 c0       	push   $0xc0030a48
c0028b02:	68 69 01 00 00       	push   $0x169
c0028b07:	68 14 09 03 c0       	push   $0xc0030914
c0028b0c:	e8 0d 0a 00 00       	call   c002951e <debug_panic>

  src_len = strlen (src);
c0028b11:	83 ec 0c             	sub    $0xc,%esp
c0028b14:	ff 75 0c             	push   0xc(%ebp)
c0028b17:	e8 87 fe ff ff       	call   c00289a3 <strlen>
c0028b1c:	83 c4 10             	add    $0x10,%esp
c0028b1f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  dst_len = strlen (dst);
c0028b22:	83 ec 0c             	sub    $0xc,%esp
c0028b25:	ff 75 08             	push   0x8(%ebp)
c0028b28:	e8 76 fe ff ff       	call   c00289a3 <strlen>
c0028b2d:	83 c4 10             	add    $0x10,%esp
c0028b30:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (size > 0 && dst_len < size) 
c0028b33:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028b37:	74 4a                	je     c0028b83 <strlcat+0xc6>
c0028b39:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028b3c:	3b 45 10             	cmp    0x10(%ebp),%eax
c0028b3f:	73 42                	jae    c0028b83 <strlcat+0xc6>
    {
      size_t copy_cnt = size - dst_len - 1;
c0028b41:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b44:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0028b47:	48                   	dec    %eax
c0028b48:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < copy_cnt)
c0028b4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028b4e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028b51:	73 06                	jae    c0028b59 <strlcat+0x9c>
        copy_cnt = src_len;
c0028b53:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028b56:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst + dst_len, src, copy_cnt);
c0028b59:	8b 55 08             	mov    0x8(%ebp),%edx
c0028b5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028b5f:	01 d0                	add    %edx,%eax
c0028b61:	83 ec 04             	sub    $0x4,%esp
c0028b64:	ff 75 f4             	push   -0xc(%ebp)
c0028b67:	ff 75 0c             	push   0xc(%ebp)
c0028b6a:	50                   	push   %eax
c0028b6b:	e8 00 f8 ff ff       	call   c0028370 <memcpy>
c0028b70:	83 c4 10             	add    $0x10,%esp
      dst[dst_len + copy_cnt] = '\0';
c0028b73:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028b76:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b79:	01 c2                	add    %eax,%edx
c0028b7b:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b7e:	01 d0                	add    %edx,%eax
c0028b80:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len + dst_len;
c0028b83:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028b86:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028b89:	01 d0                	add    %edx,%eax
}
c0028b8b:	c9                   	leave  
c0028b8c:	c3                   	ret    

c0028b8d <divl>:
   yield a 32-bit quotient.  Returns the quotient.
   Traps with a divide error (#DE) if the quotient does not fit
   in 32 bits. */
static inline uint32_t
divl (uint64_t n, uint32_t d)
{
c0028b8d:	55                   	push   %ebp
c0028b8e:	89 e5                	mov    %esp,%ebp
c0028b90:	83 ec 18             	sub    $0x18,%esp
c0028b93:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b96:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028b99:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028b9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  uint32_t n1 = n >> 32;
c0028b9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028ba2:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028ba5:	89 d0                	mov    %edx,%eax
c0028ba7:	31 d2                	xor    %edx,%edx
c0028ba9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  uint32_t n0 = n;
c0028bac:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028baf:	89 45 f8             	mov    %eax,-0x8(%ebp)
  uint32_t q, r;

  asm ("divl %4"
c0028bb2:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0028bb5:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0028bb8:	f7 75 10             	divl   0x10(%ebp)
c0028bbb:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028bbe:	89 45 f0             	mov    %eax,-0x10(%ebp)
       : "=d" (r), "=a" (q)
       : "0" (n1), "1" (n0), "rm" (d));

  return q;
c0028bc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028bc4:	c9                   	leave  
c0028bc5:	c3                   	ret    

c0028bc6 <nlz>:

/* Returns the number of leading zero bits in X,
   which must be nonzero. */
static int
nlz (uint32_t x) 
{
c0028bc6:	55                   	push   %ebp
c0028bc7:	89 e5                	mov    %esp,%ebp
c0028bc9:	83 ec 10             	sub    $0x10,%esp
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
c0028bcc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if (x <= 0x0000FFFF)
c0028bd3:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
c0028bda:	77 08                	ja     c0028be4 <nlz+0x1e>
    {
      n += 16;
c0028bdc:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
      x <<= 16; 
c0028be0:	c1 65 08 10          	shll   $0x10,0x8(%ebp)
    }
  if (x <= 0x00FFFFFF)
c0028be4:	81 7d 08 ff ff ff 00 	cmpl   $0xffffff,0x8(%ebp)
c0028beb:	77 08                	ja     c0028bf5 <nlz+0x2f>
    {
      n += 8;
c0028bed:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
      x <<= 8; 
c0028bf1:	c1 65 08 08          	shll   $0x8,0x8(%ebp)
    }
  if (x <= 0x0FFFFFFF)
c0028bf5:	81 7d 08 ff ff ff 0f 	cmpl   $0xfffffff,0x8(%ebp)
c0028bfc:	77 08                	ja     c0028c06 <nlz+0x40>
    {
      n += 4;
c0028bfe:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
      x <<= 4;
c0028c02:	c1 65 08 04          	shll   $0x4,0x8(%ebp)
    }
  if (x <= 0x3FFFFFFF)
c0028c06:	81 7d 08 ff ff ff 3f 	cmpl   $0x3fffffff,0x8(%ebp)
c0028c0d:	77 08                	ja     c0028c17 <nlz+0x51>
    {
      n += 2;
c0028c0f:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
      x <<= 2; 
c0028c13:	c1 65 08 02          	shll   $0x2,0x8(%ebp)
    }
  if (x <= 0x7FFFFFFF)
c0028c17:	8b 45 08             	mov    0x8(%ebp),%eax
c0028c1a:	85 c0                	test   %eax,%eax
c0028c1c:	78 03                	js     c0028c21 <nlz+0x5b>
    n++;
c0028c1e:	ff 45 fc             	incl   -0x4(%ebp)
  return n;
c0028c21:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028c24:	c9                   	leave  
c0028c25:	c3                   	ret    

c0028c26 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c0028c26:	55                   	push   %ebp
c0028c27:	89 e5                	mov    %esp,%ebp
c0028c29:	57                   	push   %edi
c0028c2a:	56                   	push   %esi
c0028c2b:	53                   	push   %ebx
c0028c2c:	83 ec 44             	sub    $0x44,%esp
c0028c2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0028c32:	89 45 b8             	mov    %eax,-0x48(%ebp)
c0028c35:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028c38:	89 45 bc             	mov    %eax,-0x44(%ebp)
c0028c3b:	8b 45 10             	mov    0x10(%ebp),%eax
c0028c3e:	89 45 b0             	mov    %eax,-0x50(%ebp)
c0028c41:	8b 45 14             	mov    0x14(%ebp),%eax
c0028c44:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if ((d >> 32) == 0) 
c0028c47:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028c4a:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028c4d:	89 d0                	mov    %edx,%eax
c0028c4f:	31 d2                	xor    %edx,%edx
c0028c51:	89 c7                	mov    %eax,%edi
c0028c53:	83 f7 00             	xor    $0x0,%edi
c0028c56:	89 f9                	mov    %edi,%ecx
c0028c58:	89 d0                	mov    %edx,%eax
c0028c5a:	80 f4 00             	xor    $0x0,%ah
c0028c5d:	89 c3                	mov    %eax,%ebx
c0028c5f:	89 d8                	mov    %ebx,%eax
c0028c61:	09 c8                	or     %ecx,%eax
c0028c63:	85 c0                	test   %eax,%eax
c0028c65:	0f 85 a3 00 00 00    	jne    c0028d0e <udiv64+0xe8>
             <=> [(bd - 1)/d] < b
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
c0028c6b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
c0028c72:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
      uint32_t n1 = n >> 32;
c0028c79:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028c7c:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028c7f:	89 d0                	mov    %edx,%eax
c0028c81:	31 d2                	xor    %edx,%edx
c0028c83:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      uint32_t n0 = n; 
c0028c86:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028c89:	89 45 d0             	mov    %eax,-0x30(%ebp)
      uint32_t d0 = d;
c0028c8c:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028c8f:	89 45 cc             	mov    %eax,-0x34(%ebp)

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0028c92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0028c95:	ba 00 00 00 00       	mov    $0x0,%edx
c0028c9a:	f7 75 cc             	divl   -0x34(%ebp)
c0028c9d:	89 d0                	mov    %edx,%eax
c0028c9f:	ba 00 00 00 00       	mov    $0x0,%edx
c0028ca4:	8b 4d d8             	mov    -0x28(%ebp),%ecx
c0028ca7:	89 cb                	mov    %ecx,%ebx
c0028ca9:	0f af da             	imul   %edx,%ebx
c0028cac:	8b 4d dc             	mov    -0x24(%ebp),%ecx
c0028caf:	0f af c8             	imul   %eax,%ecx
c0028cb2:	01 d9                	add    %ebx,%ecx
c0028cb4:	f7 65 d8             	mull   -0x28(%ebp)
c0028cb7:	01 d1                	add    %edx,%ecx
c0028cb9:	89 ca                	mov    %ecx,%edx
c0028cbb:	8b 4d d0             	mov    -0x30(%ebp),%ecx
c0028cbe:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028cc3:	01 c8                	add    %ecx,%eax
c0028cc5:	11 da                	adc    %ebx,%edx
c0028cc7:	83 ec 04             	sub    $0x4,%esp
c0028cca:	ff 75 cc             	push   -0x34(%ebp)
c0028ccd:	52                   	push   %edx
c0028cce:	50                   	push   %eax
c0028ccf:	e8 b9 fe ff ff       	call   c0028b8d <divl>
c0028cd4:	83 c4 10             	add    $0x10,%esp
c0028cd7:	89 c1                	mov    %eax,%ecx
c0028cd9:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028cde:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0028ce1:	ba 00 00 00 00       	mov    $0x0,%edx
c0028ce6:	f7 75 cc             	divl   -0x34(%ebp)
c0028ce9:	ba 00 00 00 00       	mov    $0x0,%edx
c0028cee:	8b 75 d8             	mov    -0x28(%ebp),%esi
c0028cf1:	89 f7                	mov    %esi,%edi
c0028cf3:	0f af fa             	imul   %edx,%edi
c0028cf6:	8b 75 dc             	mov    -0x24(%ebp),%esi
c0028cf9:	0f af f0             	imul   %eax,%esi
c0028cfc:	01 fe                	add    %edi,%esi
c0028cfe:	f7 65 d8             	mull   -0x28(%ebp)
c0028d01:	01 d6                	add    %edx,%esi
c0028d03:	89 f2                	mov    %esi,%edx
c0028d05:	01 c8                	add    %ecx,%eax
c0028d07:	11 da                	adc    %ebx,%edx
c0028d09:	e9 d9 00 00 00       	jmp    c0028de7 <udiv64+0x1c1>
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c0028d0e:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028d11:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028d14:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c0028d17:	89 d0                	mov    %edx,%eax
c0028d19:	1b 45 b4             	sbb    -0x4c(%ebp),%eax
c0028d1c:	73 0f                	jae    c0028d2d <udiv64+0x107>
        return 0;
c0028d1e:	b8 00 00 00 00       	mov    $0x0,%eax
c0028d23:	ba 00 00 00 00       	mov    $0x0,%edx
c0028d28:	e9 ba 00 00 00       	jmp    c0028de7 <udiv64+0x1c1>
      else 
        {
          uint32_t d1 = d >> 32;
c0028d2d:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028d30:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028d33:	89 d0                	mov    %edx,%eax
c0028d35:	31 d2                	xor    %edx,%edx
c0028d37:	89 45 ec             	mov    %eax,-0x14(%ebp)
          int s = nlz (d1);
c0028d3a:	83 ec 04             	sub    $0x4,%esp
c0028d3d:	ff 75 ec             	push   -0x14(%ebp)
c0028d40:	e8 81 fe ff ff       	call   c0028bc6 <nlz>
c0028d45:	83 c4 08             	add    $0x8,%esp
c0028d48:	89 45 e8             	mov    %eax,-0x18(%ebp)
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0028d4b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0028d4e:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028d51:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028d54:	0f a5 c2             	shld   %cl,%eax,%edx
c0028d57:	d3 e0                	shl    %cl,%eax
c0028d59:	f6 c1 20             	test   $0x20,%cl
c0028d5c:	74 04                	je     c0028d62 <udiv64+0x13c>
c0028d5e:	89 c2                	mov    %eax,%edx
c0028d60:	31 c0                	xor    %eax,%eax
c0028d62:	89 d0                	mov    %edx,%eax
c0028d64:	31 d2                	xor    %edx,%edx
c0028d66:	89 c1                	mov    %eax,%ecx
c0028d68:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028d6b:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028d6e:	0f ac d0 01          	shrd   $0x1,%edx,%eax
c0028d72:	d1 ea                	shr    %edx
c0028d74:	83 ec 04             	sub    $0x4,%esp
c0028d77:	51                   	push   %ecx
c0028d78:	52                   	push   %edx
c0028d79:	50                   	push   %eax
c0028d7a:	e8 0e fe ff ff       	call   c0028b8d <divl>
c0028d7f:	83 c4 10             	add    $0x10,%esp
c0028d82:	89 c2                	mov    %eax,%edx
c0028d84:	b8 1f 00 00 00       	mov    $0x1f,%eax
c0028d89:	2b 45 e8             	sub    -0x18(%ebp),%eax
c0028d8c:	88 c1                	mov    %al,%cl
c0028d8e:	d3 ea                	shr    %cl,%edx
c0028d90:	89 d0                	mov    %edx,%eax
c0028d92:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0028d95:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c0028d9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0028d9f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0028da2:	83 c0 ff             	add    $0xffffffff,%eax
c0028da5:	83 d2 ff             	adc    $0xffffffff,%edx
c0028da8:	8b 4d b0             	mov    -0x50(%ebp),%ecx
c0028dab:	89 cb                	mov    %ecx,%ebx
c0028dad:	0f af da             	imul   %edx,%ebx
c0028db0:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
c0028db3:	0f af c8             	imul   %eax,%ecx
c0028db6:	01 d9                	add    %ebx,%ecx
c0028db8:	f7 65 b0             	mull   -0x50(%ebp)
c0028dbb:	01 d1                	add    %edx,%ecx
c0028dbd:	89 ca                	mov    %ecx,%edx
c0028dbf:	8b 4d b8             	mov    -0x48(%ebp),%ecx
c0028dc2:	8b 5d bc             	mov    -0x44(%ebp),%ebx
c0028dc5:	29 c1                	sub    %eax,%ecx
c0028dc7:	19 d3                	sbb    %edx,%ebx
c0028dc9:	3b 4d b0             	cmp    -0x50(%ebp),%ecx
c0028dcc:	89 d8                	mov    %ebx,%eax
c0028dce:	1b 45 b4             	sbb    -0x4c(%ebp),%eax
c0028dd1:	73 0e                	jae    c0028de1 <udiv64+0x1bb>
c0028dd3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0028dd6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0028dd9:	83 c0 ff             	add    $0xffffffff,%eax
c0028ddc:	83 d2 ff             	adc    $0xffffffff,%edx
c0028ddf:	eb 06                	jmp    c0028de7 <udiv64+0x1c1>
c0028de1:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0028de4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
        }
    }
}
c0028de7:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0028dea:	5b                   	pop    %ebx
c0028deb:	5e                   	pop    %esi
c0028dec:	5f                   	pop    %edi
c0028ded:	5d                   	pop    %ebp
c0028dee:	c3                   	ret    

c0028def <umod64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
c0028def:	55                   	push   %ebp
c0028df0:	89 e5                	mov    %esp,%ebp
c0028df2:	53                   	push   %ebx
c0028df3:	83 ec 14             	sub    $0x14,%esp
c0028df6:	8b 45 08             	mov    0x8(%ebp),%eax
c0028df9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028dfc:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028dff:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028e02:	8b 45 10             	mov    0x10(%ebp),%eax
c0028e05:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028e08:	8b 45 14             	mov    0x14(%ebp),%eax
c0028e0b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * udiv64 (n, d);
c0028e0e:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c0028e11:	ff 75 ec             	push   -0x14(%ebp)
c0028e14:	ff 75 e8             	push   -0x18(%ebp)
c0028e17:	ff 75 f4             	push   -0xc(%ebp)
c0028e1a:	ff 75 f0             	push   -0x10(%ebp)
c0028e1d:	e8 04 fe ff ff       	call   c0028c26 <udiv64>
c0028e22:	83 c4 10             	add    $0x10,%esp
c0028e25:	89 c2                	mov    %eax,%edx
c0028e27:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028e2a:	0f af c2             	imul   %edx,%eax
c0028e2d:	29 c3                	sub    %eax,%ebx
c0028e2f:	89 da                	mov    %ebx,%edx
c0028e31:	89 d0                	mov    %edx,%eax
}
c0028e33:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028e36:	c9                   	leave  
c0028e37:	c3                   	ret    

c0028e38 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c0028e38:	55                   	push   %ebp
c0028e39:	89 e5                	mov    %esp,%ebp
c0028e3b:	83 ec 30             	sub    $0x30,%esp
c0028e3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028e41:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0028e44:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028e47:	89 45 dc             	mov    %eax,-0x24(%ebp)
c0028e4a:	8b 45 10             	mov    0x10(%ebp),%eax
c0028e4d:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0028e50:	8b 45 14             	mov    0x14(%ebp),%eax
c0028e53:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028e56:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0028e5a:	79 0f                	jns    c0028e6b <sdiv64+0x33>
c0028e5c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0028e5f:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0028e62:	f7 d8                	neg    %eax
c0028e64:	83 d2 00             	adc    $0x0,%edx
c0028e67:	f7 da                	neg    %edx
c0028e69:	eb 06                	jmp    c0028e71 <sdiv64+0x39>
c0028e6b:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0028e6e:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0028e71:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0028e74:	89 55 fc             	mov    %edx,-0x4(%ebp)
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0028e77:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0028e7b:	79 0f                	jns    c0028e8c <sdiv64+0x54>
c0028e7d:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0028e80:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0028e83:	f7 d8                	neg    %eax
c0028e85:	83 d2 00             	adc    $0x0,%edx
c0028e88:	f7 da                	neg    %edx
c0028e8a:	eb 06                	jmp    c0028e92 <sdiv64+0x5a>
c0028e8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0028e8f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0028e92:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028e95:	89 55 f4             	mov    %edx,-0xc(%ebp)
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0028e98:	ff 75 f4             	push   -0xc(%ebp)
c0028e9b:	ff 75 f0             	push   -0x10(%ebp)
c0028e9e:	ff 75 fc             	push   -0x4(%ebp)
c0028ea1:	ff 75 f8             	push   -0x8(%ebp)
c0028ea4:	e8 7d fd ff ff       	call   c0028c26 <udiv64>
c0028ea9:	83 c4 10             	add    $0x10,%esp
c0028eac:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028eaf:	89 55 ec             	mov    %edx,-0x14(%ebp)
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0028eb2:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0028eb5:	f7 d0                	not    %eax
c0028eb7:	c1 e8 1f             	shr    $0x1f,%eax
c0028eba:	88 c2                	mov    %al,%dl
c0028ebc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0028ebf:	c1 e8 1f             	shr    $0x1f,%eax
c0028ec2:	31 d0                	xor    %edx,%eax
c0028ec4:	84 c0                	test   %al,%al
c0028ec6:	74 08                	je     c0028ed0 <sdiv64+0x98>
c0028ec8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028ecb:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028ece:	eb 0d                	jmp    c0028edd <sdiv64+0xa5>
c0028ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028ed3:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028ed6:	f7 d8                	neg    %eax
c0028ed8:	83 d2 00             	adc    $0x0,%edx
c0028edb:	f7 da                	neg    %edx
}
c0028edd:	c9                   	leave  
c0028ede:	c3                   	ret    

c0028edf <smod64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
c0028edf:	55                   	push   %ebp
c0028ee0:	89 e5                	mov    %esp,%ebp
c0028ee2:	53                   	push   %ebx
c0028ee3:	83 ec 14             	sub    $0x14,%esp
c0028ee6:	8b 45 08             	mov    0x8(%ebp),%eax
c0028ee9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028eec:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028eef:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028ef2:	8b 45 10             	mov    0x10(%ebp),%eax
c0028ef5:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028ef8:	8b 45 14             	mov    0x14(%ebp),%eax
c0028efb:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * sdiv64 (n, d);
c0028efe:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c0028f01:	ff 75 ec             	push   -0x14(%ebp)
c0028f04:	ff 75 e8             	push   -0x18(%ebp)
c0028f07:	ff 75 f4             	push   -0xc(%ebp)
c0028f0a:	ff 75 f0             	push   -0x10(%ebp)
c0028f0d:	e8 26 ff ff ff       	call   c0028e38 <sdiv64>
c0028f12:	83 c4 10             	add    $0x10,%esp
c0028f15:	89 c2                	mov    %eax,%edx
c0028f17:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028f1a:	0f af c2             	imul   %edx,%eax
c0028f1d:	29 c3                	sub    %eax,%ebx
c0028f1f:	89 da                	mov    %ebx,%edx
c0028f21:	89 d0                	mov    %edx,%eax
}
c0028f23:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028f26:	c9                   	leave  
c0028f27:	c3                   	ret    

c0028f28 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c0028f28:	55                   	push   %ebp
c0028f29:	89 e5                	mov    %esp,%ebp
c0028f2b:	83 ec 10             	sub    $0x10,%esp
c0028f2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f31:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0028f34:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028f37:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0028f3a:	8b 45 10             	mov    0x10(%ebp),%eax
c0028f3d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028f40:	8b 45 14             	mov    0x14(%ebp),%eax
c0028f43:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return sdiv64 (n, d);
c0028f46:	ff 75 f4             	push   -0xc(%ebp)
c0028f49:	ff 75 f0             	push   -0x10(%ebp)
c0028f4c:	ff 75 fc             	push   -0x4(%ebp)
c0028f4f:	ff 75 f8             	push   -0x8(%ebp)
c0028f52:	e8 e1 fe ff ff       	call   c0028e38 <sdiv64>
c0028f57:	83 c4 10             	add    $0x10,%esp
}
c0028f5a:	c9                   	leave  
c0028f5b:	c3                   	ret    

c0028f5c <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c0028f5c:	55                   	push   %ebp
c0028f5d:	89 e5                	mov    %esp,%ebp
c0028f5f:	83 ec 10             	sub    $0x10,%esp
c0028f62:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f65:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0028f68:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028f6b:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0028f6e:	8b 45 10             	mov    0x10(%ebp),%eax
c0028f71:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028f74:	8b 45 14             	mov    0x14(%ebp),%eax
c0028f77:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return smod64 (n, d);
c0028f7a:	ff 75 f4             	push   -0xc(%ebp)
c0028f7d:	ff 75 f0             	push   -0x10(%ebp)
c0028f80:	ff 75 fc             	push   -0x4(%ebp)
c0028f83:	ff 75 f8             	push   -0x8(%ebp)
c0028f86:	e8 54 ff ff ff       	call   c0028edf <smod64>
c0028f8b:	83 c4 10             	add    $0x10,%esp
c0028f8e:	99                   	cltd   
}
c0028f8f:	c9                   	leave  
c0028f90:	c3                   	ret    

c0028f91 <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c0028f91:	55                   	push   %ebp
c0028f92:	89 e5                	mov    %esp,%ebp
c0028f94:	83 ec 10             	sub    $0x10,%esp
c0028f97:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f9a:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0028f9d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028fa0:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0028fa3:	8b 45 10             	mov    0x10(%ebp),%eax
c0028fa6:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028fa9:	8b 45 14             	mov    0x14(%ebp),%eax
c0028fac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return udiv64 (n, d);
c0028faf:	ff 75 f4             	push   -0xc(%ebp)
c0028fb2:	ff 75 f0             	push   -0x10(%ebp)
c0028fb5:	ff 75 fc             	push   -0x4(%ebp)
c0028fb8:	ff 75 f8             	push   -0x8(%ebp)
c0028fbb:	e8 66 fc ff ff       	call   c0028c26 <udiv64>
c0028fc0:	83 c4 10             	add    $0x10,%esp
}
c0028fc3:	c9                   	leave  
c0028fc4:	c3                   	ret    

c0028fc5 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c0028fc5:	55                   	push   %ebp
c0028fc6:	89 e5                	mov    %esp,%ebp
c0028fc8:	83 ec 10             	sub    $0x10,%esp
c0028fcb:	8b 45 08             	mov    0x8(%ebp),%eax
c0028fce:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0028fd1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028fd4:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0028fd7:	8b 45 10             	mov    0x10(%ebp),%eax
c0028fda:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028fdd:	8b 45 14             	mov    0x14(%ebp),%eax
c0028fe0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return umod64 (n, d);
c0028fe3:	ff 75 f4             	push   -0xc(%ebp)
c0028fe6:	ff 75 f0             	push   -0x10(%ebp)
c0028fe9:	ff 75 fc             	push   -0x4(%ebp)
c0028fec:	ff 75 f8             	push   -0x8(%ebp)
c0028fef:	e8 fb fd ff ff       	call   c0028def <umod64>
c0028ff4:	83 c4 10             	add    $0x10,%esp
c0028ff7:	ba 00 00 00 00       	mov    $0x0,%edx
}
c0028ffc:	c9                   	leave  
c0028ffd:	c3                   	ret    

c0028ffe <calculate_chksum>:
PACKED;

/* Returns the checksum for the given ustar format HEADER. */
static unsigned int
calculate_chksum (const struct ustar_header *h)
{
c0028ffe:	55                   	push   %ebp
c0028fff:	89 e5                	mov    %esp,%ebp
c0029001:	83 ec 20             	sub    $0x20,%esp
  const uint8_t *header = (const uint8_t *) h;
c0029004:	8b 45 08             	mov    0x8(%ebp),%eax
c0029007:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int chksum;
  size_t i;

  chksum = 0;
c002900a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0029011:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0029018:	eb 57                	jmp    c0029071 <calculate_chksum+0x73>
    {
      /* The ustar checksum is calculated as if the chksum field
         were all spaces. */
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
c002901a:	c7 45 f0 94 00 00 00 	movl   $0x94,-0x10(%ebp)
      const size_t chksum_end = chksum_start + sizeof h->chksum;
c0029021:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029024:	83 c0 08             	add    $0x8,%eax
c0029027:	89 45 ec             	mov    %eax,-0x14(%ebp)
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
c002902a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002902d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0029030:	72 0f                	jb     c0029041 <calculate_chksum+0x43>
c0029032:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029035:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0029038:	73 07                	jae    c0029041 <calculate_chksum+0x43>
c002903a:	b8 01 00 00 00       	mov    $0x1,%eax
c002903f:	eb 05                	jmp    c0029046 <calculate_chksum+0x48>
c0029041:	b8 00 00 00 00       	mov    $0x0,%eax
c0029046:	88 45 eb             	mov    %al,-0x15(%ebp)
c0029049:	80 65 eb 01          	andb   $0x1,-0x15(%ebp)
      chksum += in_chksum_field ? ' ' : header[i];
c002904d:	8a 45 eb             	mov    -0x15(%ebp),%al
c0029050:	83 f0 01             	xor    $0x1,%eax
c0029053:	84 c0                	test   %al,%al
c0029055:	74 0f                	je     c0029066 <calculate_chksum+0x68>
c0029057:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002905a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002905d:	01 d0                	add    %edx,%eax
c002905f:	8a 00                	mov    (%eax),%al
c0029061:	0f b6 c0             	movzbl %al,%eax
c0029064:	eb 05                	jmp    c002906b <calculate_chksum+0x6d>
c0029066:	b8 20 00 00 00       	mov    $0x20,%eax
c002906b:	01 45 fc             	add    %eax,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c002906e:	ff 45 f8             	incl   -0x8(%ebp)
c0029071:	81 7d f8 ff 01 00 00 	cmpl   $0x1ff,-0x8(%ebp)
c0029078:	76 a0                	jbe    c002901a <calculate_chksum+0x1c>
    }
  return chksum;
c002907a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c002907d:	c9                   	leave  
c002907e:	c3                   	ret    

c002907f <strip_antisocial_prefixes>:

   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
c002907f:	55                   	push   %ebp
c0029080:	89 e5                	mov    %esp,%ebp
c0029082:	83 ec 08             	sub    $0x8,%esp
  while (*file_name == '/'
c0029085:	eb 14                	jmp    c002909b <strip_antisocial_prefixes+0x1c>
         || !memcmp (file_name, "./", 2)
         || !memcmp (file_name, "../", 3))
    file_name = strchr (file_name, '/') + 1;
c0029087:	83 ec 08             	sub    $0x8,%esp
c002908a:	6a 2f                	push   $0x2f
c002908c:	ff 75 08             	push   0x8(%ebp)
c002908f:	e8 db f5 ff ff       	call   c002866f <strchr>
c0029094:	83 c4 10             	add    $0x10,%esp
c0029097:	40                   	inc    %eax
c0029098:	89 45 08             	mov    %eax,0x8(%ebp)
  while (*file_name == '/'
c002909b:	8b 45 08             	mov    0x8(%ebp),%eax
c002909e:	8a 00                	mov    (%eax),%al
c00290a0:	3c 2f                	cmp    $0x2f,%al
c00290a2:	74 e3                	je     c0029087 <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "./", 2)
c00290a4:	83 ec 04             	sub    $0x4,%esp
c00290a7:	6a 02                	push   $0x2
c00290a9:	68 50 0a 03 c0       	push   $0xc0030a50
c00290ae:	ff 75 08             	push   0x8(%ebp)
c00290b1:	e8 0d f4 ff ff       	call   c00284c3 <memcmp>
c00290b6:	83 c4 10             	add    $0x10,%esp
c00290b9:	85 c0                	test   %eax,%eax
c00290bb:	74 ca                	je     c0029087 <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "../", 3))
c00290bd:	83 ec 04             	sub    $0x4,%esp
c00290c0:	6a 03                	push   $0x3
c00290c2:	68 53 0a 03 c0       	push   $0xc0030a53
c00290c7:	ff 75 08             	push   0x8(%ebp)
c00290ca:	e8 f4 f3 ff ff       	call   c00284c3 <memcmp>
c00290cf:	83 c4 10             	add    $0x10,%esp
c00290d2:	85 c0                	test   %eax,%eax
c00290d4:	74 b1                	je     c0029087 <strip_antisocial_prefixes+0x8>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c00290d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00290d9:	8a 00                	mov    (%eax),%al
c00290db:	84 c0                	test   %al,%al
c00290dd:	74 1c                	je     c00290fb <strip_antisocial_prefixes+0x7c>
c00290df:	83 ec 08             	sub    $0x8,%esp
c00290e2:	68 57 0a 03 c0       	push   $0xc0030a57
c00290e7:	ff 75 08             	push   0x8(%ebp)
c00290ea:	e8 7e f4 ff ff       	call   c002856d <strcmp>
c00290ef:	83 c4 10             	add    $0x10,%esp
c00290f2:	85 c0                	test   %eax,%eax
c00290f4:	74 05                	je     c00290fb <strip_antisocial_prefixes+0x7c>
c00290f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00290f9:	eb 05                	jmp    c0029100 <strip_antisocial_prefixes+0x81>
c00290fb:	b8 5a 0a 03 c0       	mov    $0xc0030a5a,%eax
}
c0029100:	c9                   	leave  
c0029101:	c3                   	ret    

c0029102 <ustar_make_header>:
   If successful, returns true.  On failure (due to an
   excessively long file name), returns false. */
bool
ustar_make_header (const char *file_name, enum ustar_type type,
                   int size, char header[USTAR_HEADER_SIZE])
{
c0029102:	55                   	push   %ebp
c0029103:	89 e5                	mov    %esp,%ebp
c0029105:	83 ec 18             	sub    $0x18,%esp
  struct ustar_header *h = (struct ustar_header *) header;
c0029108:	8b 45 14             	mov    0x14(%ebp),%eax
c002910b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c002910e:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c0029112:	74 24                	je     c0029138 <ustar_make_header+0x36>
c0029114:	83 7d 0c 35          	cmpl   $0x35,0xc(%ebp)
c0029118:	74 1e                	je     c0029138 <ustar_make_header+0x36>
c002911a:	83 ec 0c             	sub    $0xc,%esp
c002911d:	68 5c 0a 03 c0       	push   $0xc0030a5c
c0029122:	68 8d 0a 03 c0       	push   $0xc0030a8d
c0029127:	68 90 0b 03 c0       	push   $0xc0030b90
c002912c:	6a 59                	push   $0x59
c002912e:	68 a4 0a 03 c0       	push   $0xc0030aa4
c0029133:	e8 e6 03 00 00       	call   c002951e <debug_panic>

  /* Check file name. */
  file_name = strip_antisocial_prefixes (file_name);
c0029138:	83 ec 0c             	sub    $0xc,%esp
c002913b:	ff 75 08             	push   0x8(%ebp)
c002913e:	e8 3c ff ff ff       	call   c002907f <strip_antisocial_prefixes>
c0029143:	83 c4 10             	add    $0x10,%esp
c0029146:	89 45 08             	mov    %eax,0x8(%ebp)
  if (strlen (file_name) > 99)
c0029149:	83 ec 0c             	sub    $0xc,%esp
c002914c:	ff 75 08             	push   0x8(%ebp)
c002914f:	e8 4f f8 ff ff       	call   c00289a3 <strlen>
c0029154:	83 c4 10             	add    $0x10,%esp
c0029157:	83 f8 63             	cmp    $0x63,%eax
c002915a:	76 1a                	jbe    c0029176 <ustar_make_header+0x74>
    {
      printf ("%s: file name too long\n", file_name);
c002915c:	83 ec 08             	sub    $0x8,%esp
c002915f:	ff 75 08             	push   0x8(%ebp)
c0029162:	68 b6 0a 03 c0       	push   $0xc0030ab6
c0029167:	e8 10 e0 ff ff       	call   c002717c <printf>
c002916c:	83 c4 10             	add    $0x10,%esp
      return false;
c002916f:	b0 00                	mov    $0x0,%al
c0029171:	e9 5f 01 00 00       	jmp    c00292d5 <ustar_make_header+0x1d3>
    }

  /* Fill in header except for final checksum. */
  memset (h, 0, sizeof *h);
c0029176:	83 ec 04             	sub    $0x4,%esp
c0029179:	68 00 02 00 00       	push   $0x200
c002917e:	6a 00                	push   $0x0
c0029180:	ff 75 f4             	push   -0xc(%ebp)
c0029183:	e8 c2 f7 ff ff       	call   c002894a <memset>
c0029188:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->name, file_name, sizeof h->name);
c002918b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002918e:	83 ec 04             	sub    $0x4,%esp
c0029191:	6a 64                	push   $0x64
c0029193:	ff 75 08             	push   0x8(%ebp)
c0029196:	50                   	push   %eax
c0029197:	e8 7d f8 ff ff       	call   c0028a19 <strlcpy>
c002919c:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c002919f:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c00291a3:	75 07                	jne    c00291ac <ustar_make_header+0xaa>
c00291a5:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c00291aa:	eb 05                	jmp    c00291b1 <ustar_make_header+0xaf>
c00291ac:	b8 ed 01 00 00       	mov    $0x1ed,%eax
c00291b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00291b4:	83 c2 64             	add    $0x64,%edx
c00291b7:	50                   	push   %eax
c00291b8:	68 ce 0a 03 c0       	push   $0xc0030ace
c00291bd:	6a 08                	push   $0x8
c00291bf:	52                   	push   %edx
c00291c0:	e8 8e df ff ff       	call   c0027153 <snprintf>
c00291c5:	83 c4 10             	add    $0x10,%esp
            type == USTAR_REGULAR ? 0644 : 0755);
  strlcpy (h->uid, "0000000", sizeof h->uid);
c00291c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00291cb:	83 c0 6c             	add    $0x6c,%eax
c00291ce:	83 ec 04             	sub    $0x4,%esp
c00291d1:	6a 08                	push   $0x8
c00291d3:	68 d3 0a 03 c0       	push   $0xc0030ad3
c00291d8:	50                   	push   %eax
c00291d9:	e8 3b f8 ff ff       	call   c0028a19 <strlcpy>
c00291de:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->gid, "0000000", sizeof h->gid);
c00291e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00291e4:	83 c0 74             	add    $0x74,%eax
c00291e7:	83 ec 04             	sub    $0x4,%esp
c00291ea:	6a 08                	push   $0x8
c00291ec:	68 d3 0a 03 c0       	push   $0xc0030ad3
c00291f1:	50                   	push   %eax
c00291f2:	e8 22 f8 ff ff       	call   c0028a19 <strlcpy>
c00291f7:	83 c4 10             	add    $0x10,%esp
  snprintf (h->size, sizeof h->size, "%011o", size);
c00291fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00291fd:	83 c0 7c             	add    $0x7c,%eax
c0029200:	ff 75 10             	push   0x10(%ebp)
c0029203:	68 db 0a 03 c0       	push   $0xc0030adb
c0029208:	6a 0c                	push   $0xc
c002920a:	50                   	push   %eax
c002920b:	e8 43 df ff ff       	call   c0027153 <snprintf>
c0029210:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c0029213:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029216:	05 88 00 00 00       	add    $0x88,%eax
c002921b:	68 00 8c b7 43       	push   $0x43b78c00
c0029220:	68 db 0a 03 c0       	push   $0xc0030adb
c0029225:	6a 0c                	push   $0xc
c0029227:	50                   	push   %eax
c0029228:	e8 26 df ff ff       	call   c0027153 <snprintf>
c002922d:	83 c4 10             	add    $0x10,%esp
  h->typeflag = type;
c0029230:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029233:	88 c2                	mov    %al,%dl
c0029235:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029238:	88 90 9c 00 00 00    	mov    %dl,0x9c(%eax)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c002923e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029241:	05 01 01 00 00       	add    $0x101,%eax
c0029246:	83 ec 04             	sub    $0x4,%esp
c0029249:	6a 06                	push   $0x6
c002924b:	68 e1 0a 03 c0       	push   $0xc0030ae1
c0029250:	50                   	push   %eax
c0029251:	e8 c3 f7 ff ff       	call   c0028a19 <strlcpy>
c0029256:	83 c4 10             	add    $0x10,%esp
  h->version[0] = h->version[1] = '0';
c0029259:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002925c:	c6 80 08 01 00 00 30 	movb   $0x30,0x108(%eax)
c0029263:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029266:	8a 90 08 01 00 00    	mov    0x108(%eax),%dl
c002926c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002926f:	88 90 07 01 00 00    	mov    %dl,0x107(%eax)
  strlcpy (h->gname, "root", sizeof h->gname);
c0029275:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029278:	05 29 01 00 00       	add    $0x129,%eax
c002927d:	83 ec 04             	sub    $0x4,%esp
c0029280:	6a 20                	push   $0x20
c0029282:	68 e7 0a 03 c0       	push   $0xc0030ae7
c0029287:	50                   	push   %eax
c0029288:	e8 8c f7 ff ff       	call   c0028a19 <strlcpy>
c002928d:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->uname, "root", sizeof h->uname);
c0029290:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029293:	05 09 01 00 00       	add    $0x109,%eax
c0029298:	83 ec 04             	sub    $0x4,%esp
c002929b:	6a 20                	push   $0x20
c002929d:	68 e7 0a 03 c0       	push   $0xc0030ae7
c00292a2:	50                   	push   %eax
c00292a3:	e8 71 f7 ff ff       	call   c0028a19 <strlcpy>
c00292a8:	83 c4 10             	add    $0x10,%esp

  /* Compute and fill in final checksum. */
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c00292ab:	83 ec 0c             	sub    $0xc,%esp
c00292ae:	ff 75 f4             	push   -0xc(%ebp)
c00292b1:	e8 48 fd ff ff       	call   c0028ffe <calculate_chksum>
c00292b6:	83 c4 10             	add    $0x10,%esp
c00292b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00292bc:	81 c2 94 00 00 00    	add    $0x94,%edx
c00292c2:	50                   	push   %eax
c00292c3:	68 ce 0a 03 c0       	push   $0xc0030ace
c00292c8:	6a 08                	push   $0x8
c00292ca:	52                   	push   %edx
c00292cb:	e8 83 de ff ff       	call   c0027153 <snprintf>
c00292d0:	83 c4 10             	add    $0x10,%esp

  return true;
c00292d3:	b0 01                	mov    $0x1,%al
}
c00292d5:	c9                   	leave  
c00292d6:	c3                   	ret    

c00292d7 <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c00292d7:	55                   	push   %ebp
c00292d8:	89 e5                	mov    %esp,%ebp
c00292da:	83 ec 10             	sub    $0x10,%esp
  size_t ofs;

  *value = 0;
c00292dd:	8b 45 10             	mov    0x10(%ebp),%eax
c00292e0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c00292e6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00292ed:	eb 5d                	jmp    c002934c <parse_octal_field+0x75>
    {
      char c = s[ofs];
c00292ef:	8b 55 08             	mov    0x8(%ebp),%edx
c00292f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00292f5:	01 d0                	add    %edx,%eax
c00292f7:	8a 00                	mov    (%eax),%al
c00292f9:	88 45 fb             	mov    %al,-0x5(%ebp)
      if (c >= '0' && c <= '7')
c00292fc:	80 7d fb 2f          	cmpb   $0x2f,-0x5(%ebp)
c0029300:	7e 31                	jle    c0029333 <parse_octal_field+0x5c>
c0029302:	80 7d fb 37          	cmpb   $0x37,-0x5(%ebp)
c0029306:	7f 2b                	jg     c0029333 <parse_octal_field+0x5c>
        {
          if (*value > ULONG_MAX / 8)
c0029308:	8b 45 10             	mov    0x10(%ebp),%eax
c002930b:	8b 00                	mov    (%eax),%eax
c002930d:	3d ff ff ff 1f       	cmp    $0x1fffffff,%eax
c0029312:	76 04                	jbe    c0029318 <parse_octal_field+0x41>
            {
              /* Overflow. */
              return false;
c0029314:	b0 00                	mov    $0x0,%al
c0029316:	eb 3e                	jmp    c0029356 <parse_octal_field+0x7f>
            }
          *value = c - '0' + *value * 8;
c0029318:	0f be 55 fb          	movsbl -0x5(%ebp),%edx
c002931c:	8b 45 10             	mov    0x10(%ebp),%eax
c002931f:	8b 00                	mov    (%eax),%eax
c0029321:	c1 e0 03             	shl    $0x3,%eax
c0029324:	01 d0                	add    %edx,%eax
c0029326:	8d 50 d0             	lea    -0x30(%eax),%edx
c0029329:	8b 45 10             	mov    0x10(%ebp),%eax
c002932c:	89 10                	mov    %edx,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c002932e:	ff 45 fc             	incl   -0x4(%ebp)
c0029331:	eb 19                	jmp    c002934c <parse_octal_field+0x75>
        }
      else if (c == ' ' || c == '\0')
c0029333:	80 7d fb 20          	cmpb   $0x20,-0x5(%ebp)
c0029337:	74 06                	je     c002933f <parse_octal_field+0x68>
c0029339:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c002933d:	75 09                	jne    c0029348 <parse_octal_field+0x71>
        {
          /* End of field, but disallow completely empty
             fields. */
          return ofs > 0;
c002933f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0029343:	0f 95 c0             	setne  %al
c0029346:	eb 0e                	jmp    c0029356 <parse_octal_field+0x7f>
        }
      else
        {
          /* Bad character. */
          return false;
c0029348:	b0 00                	mov    $0x0,%al
c002934a:	eb 0a                	jmp    c0029356 <parse_octal_field+0x7f>
  for (ofs = 0; ofs < size; ofs++)
c002934c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002934f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029352:	72 9b                	jb     c00292ef <parse_octal_field+0x18>
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c0029354:	b0 00                	mov    $0x0,%al
}
c0029356:	c9                   	leave  
c0029357:	c3                   	ret    

c0029358 <is_all_zeros>:

/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
c0029358:	55                   	push   %ebp
c0029359:	89 e5                	mov    %esp,%ebp
  while (cnt-- > 0)
c002935b:	eb 13                	jmp    c0029370 <is_all_zeros+0x18>
    if (*block++ != 0)
c002935d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029360:	8d 50 01             	lea    0x1(%eax),%edx
c0029363:	89 55 08             	mov    %edx,0x8(%ebp)
c0029366:	8a 00                	mov    (%eax),%al
c0029368:	84 c0                	test   %al,%al
c002936a:	74 04                	je     c0029370 <is_all_zeros+0x18>
      return false;
c002936c:	b0 00                	mov    $0x0,%al
c002936e:	eb 0f                	jmp    c002937f <is_all_zeros+0x27>
  while (cnt-- > 0)
c0029370:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029373:	8d 50 ff             	lea    -0x1(%eax),%edx
c0029376:	89 55 0c             	mov    %edx,0xc(%ebp)
c0029379:	85 c0                	test   %eax,%eax
c002937b:	75 e0                	jne    c002935d <is_all_zeros+0x5>
  return true;
c002937d:	b0 01                	mov    $0x1,%al
}
c002937f:	5d                   	pop    %ebp
c0029380:	c3                   	ret    

c0029381 <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c0029381:	55                   	push   %ebp
c0029382:	89 e5                	mov    %esp,%ebp
c0029384:	83 ec 18             	sub    $0x18,%esp
  const struct ustar_header *h = (const struct ustar_header *) header;
c0029387:	8b 45 08             	mov    0x8(%ebp),%eax
c002938a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned long int chksum, size_ul;

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
c002938d:	68 00 02 00 00       	push   $0x200
c0029392:	ff 75 08             	push   0x8(%ebp)
c0029395:	e8 be ff ff ff       	call   c0029358 <is_all_zeros>
c002939a:	83 c4 08             	add    $0x8,%esp
c002939d:	84 c0                	test   %al,%al
c002939f:	74 25                	je     c00293c6 <ustar_parse_header+0x45>
    {
      *file_name = NULL;
c00293a1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00293a4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c00293aa:	8b 45 10             	mov    0x10(%ebp),%eax
c00293ad:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c00293b3:	8b 45 14             	mov    0x14(%ebp),%eax
c00293b6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c00293bc:	b8 00 00 00 00       	mov    $0x0,%eax
c00293c1:	e9 56 01 00 00       	jmp    c002951c <ustar_parse_header+0x19b>
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
c00293c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00293c9:	05 01 01 00 00       	add    $0x101,%eax
c00293ce:	83 ec 04             	sub    $0x4,%esp
c00293d1:	6a 06                	push   $0x6
c00293d3:	68 e1 0a 03 c0       	push   $0xc0030ae1
c00293d8:	50                   	push   %eax
c00293d9:	e8 e5 f0 ff ff       	call   c00284c3 <memcmp>
c00293de:	83 c4 10             	add    $0x10,%esp
c00293e1:	85 c0                	test   %eax,%eax
c00293e3:	74 0a                	je     c00293ef <ustar_parse_header+0x6e>
    return "not a ustar archive";
c00293e5:	b8 ec 0a 03 c0       	mov    $0xc0030aec,%eax
c00293ea:	e9 2d 01 00 00       	jmp    c002951c <ustar_parse_header+0x19b>
  else if (h->version[0] != '0' || h->version[1] != '0')
c00293ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00293f2:	8a 80 07 01 00 00    	mov    0x107(%eax),%al
c00293f8:	3c 30                	cmp    $0x30,%al
c00293fa:	75 0d                	jne    c0029409 <ustar_parse_header+0x88>
c00293fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00293ff:	8a 80 08 01 00 00    	mov    0x108(%eax),%al
c0029405:	3c 30                	cmp    $0x30,%al
c0029407:	74 0a                	je     c0029413 <ustar_parse_header+0x92>
    return "invalid ustar version";
c0029409:	b8 00 0b 03 c0       	mov    $0xc0030b00,%eax
c002940e:	e9 09 01 00 00       	jmp    c002951c <ustar_parse_header+0x19b>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0029413:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029416:	8d 90 94 00 00 00    	lea    0x94(%eax),%edx
c002941c:	83 ec 04             	sub    $0x4,%esp
c002941f:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0029422:	50                   	push   %eax
c0029423:	6a 08                	push   $0x8
c0029425:	52                   	push   %edx
c0029426:	e8 ac fe ff ff       	call   c00292d7 <parse_octal_field>
c002942b:	83 c4 10             	add    $0x10,%esp
c002942e:	83 f0 01             	xor    $0x1,%eax
c0029431:	84 c0                	test   %al,%al
c0029433:	74 0a                	je     c002943f <ustar_parse_header+0xbe>
    return "corrupt chksum field";
c0029435:	b8 16 0b 03 c0       	mov    $0xc0030b16,%eax
c002943a:	e9 dd 00 00 00       	jmp    c002951c <ustar_parse_header+0x19b>
  else if (chksum != calculate_chksum (h))
c002943f:	83 ec 0c             	sub    $0xc,%esp
c0029442:	ff 75 f4             	push   -0xc(%ebp)
c0029445:	e8 b4 fb ff ff       	call   c0028ffe <calculate_chksum>
c002944a:	83 c4 10             	add    $0x10,%esp
c002944d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0029450:	39 d0                	cmp    %edx,%eax
c0029452:	74 0a                	je     c002945e <ustar_parse_header+0xdd>
    return "checksum mismatch";
c0029454:	b8 2b 0b 03 c0       	mov    $0xc0030b2b,%eax
c0029459:	e9 be 00 00 00       	jmp    c002951c <ustar_parse_header+0x19b>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c002945e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029461:	8a 40 63             	mov    0x63(%eax),%al
c0029464:	84 c0                	test   %al,%al
c0029466:	75 0d                	jne    c0029475 <ustar_parse_header+0xf4>
c0029468:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002946b:	8a 80 59 01 00 00    	mov    0x159(%eax),%al
c0029471:	84 c0                	test   %al,%al
c0029473:	74 0a                	je     c002947f <ustar_parse_header+0xfe>
    return "file name too long";
c0029475:	b8 3d 0b 03 c0       	mov    $0xc0030b3d,%eax
c002947a:	e9 9d 00 00 00       	jmp    c002951c <ustar_parse_header+0x19b>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c002947f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029482:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c0029488:	3c 30                	cmp    $0x30,%al
c002948a:	74 14                	je     c00294a0 <ustar_parse_header+0x11f>
c002948c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002948f:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c0029495:	3c 35                	cmp    $0x35,%al
c0029497:	74 07                	je     c00294a0 <ustar_parse_header+0x11f>
    return "unimplemented file type";
c0029499:	b8 50 0b 03 c0       	mov    $0xc0030b50,%eax
c002949e:	eb 7c                	jmp    c002951c <ustar_parse_header+0x19b>
  if (h->typeflag == USTAR_REGULAR)
c00294a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294a3:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c00294a9:	3c 30                	cmp    $0x30,%al
c00294ab:	75 34                	jne    c00294e1 <ustar_parse_header+0x160>
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c00294ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294b0:	8d 50 7c             	lea    0x7c(%eax),%edx
c00294b3:	83 ec 04             	sub    $0x4,%esp
c00294b6:	8d 45 ec             	lea    -0x14(%ebp),%eax
c00294b9:	50                   	push   %eax
c00294ba:	6a 0c                	push   $0xc
c00294bc:	52                   	push   %edx
c00294bd:	e8 15 fe ff ff       	call   c00292d7 <parse_octal_field>
c00294c2:	83 c4 10             	add    $0x10,%esp
c00294c5:	83 f0 01             	xor    $0x1,%eax
c00294c8:	84 c0                	test   %al,%al
c00294ca:	74 07                	je     c00294d3 <ustar_parse_header+0x152>
        return "corrupt file size field";
c00294cc:	b8 68 0b 03 c0       	mov    $0xc0030b68,%eax
c00294d1:	eb 49                	jmp    c002951c <ustar_parse_header+0x19b>
      else if (size_ul > INT_MAX)
c00294d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00294d6:	85 c0                	test   %eax,%eax
c00294d8:	79 0e                	jns    c00294e8 <ustar_parse_header+0x167>
        return "file too large";
c00294da:	b8 80 0b 03 c0       	mov    $0xc0030b80,%eax
c00294df:	eb 3b                	jmp    c002951c <ustar_parse_header+0x19b>
    }
  else
    size_ul = 0;
c00294e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
c00294e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294eb:	83 ec 0c             	sub    $0xc,%esp
c00294ee:	50                   	push   %eax
c00294ef:	e8 8b fb ff ff       	call   c002907f <strip_antisocial_prefixes>
c00294f4:	83 c4 10             	add    $0x10,%esp
c00294f7:	8b 55 0c             	mov    0xc(%ebp),%edx
c00294fa:	89 02                	mov    %eax,(%edx)
  *type = h->typeflag;
c00294fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294ff:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c0029505:	0f be d0             	movsbl %al,%edx
c0029508:	8b 45 10             	mov    0x10(%ebp),%eax
c002950b:	89 10                	mov    %edx,(%eax)
  *size = size_ul;
c002950d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029510:	89 c2                	mov    %eax,%edx
c0029512:	8b 45 14             	mov    0x14(%ebp),%eax
c0029515:	89 10                	mov    %edx,(%eax)
  return NULL;
c0029517:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002951c:	c9                   	leave  
c002951d:	c3                   	ret    

c002951e <debug_panic>:
/* Halts the OS, printing the source file name, line number, and
   function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
c002951e:	55                   	push   %ebp
c002951f:	89 e5                	mov    %esp,%ebp
c0029521:	83 ec 18             	sub    $0x18,%esp
  static int level;
  va_list args;

  intr_disable ();
c0029524:	e8 74 7e ff ff       	call   c002139d <intr_disable>
  console_panic ();
c0029529:	e8 7c 20 00 00       	call   c002b5aa <console_panic>

  level++;
c002952e:	a1 c4 53 03 c0       	mov    0xc00353c4,%eax
c0029533:	40                   	inc    %eax
c0029534:	a3 c4 53 03 c0       	mov    %eax,0xc00353c4
  if (level == 1) 
c0029539:	a1 c4 53 03 c0       	mov    0xc00353c4,%eax
c002953e:	83 f8 01             	cmp    $0x1,%eax
c0029541:	75 42                	jne    c0029585 <debug_panic+0x67>
    {
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c0029543:	ff 75 10             	push   0x10(%ebp)
c0029546:	ff 75 0c             	push   0xc(%ebp)
c0029549:	ff 75 08             	push   0x8(%ebp)
c002954c:	68 a4 0b 03 c0       	push   $0xc0030ba4
c0029551:	e8 26 dc ff ff       	call   c002717c <printf>
c0029556:	83 c4 10             	add    $0x10,%esp

      va_start (args, message);
c0029559:	8d 45 18             	lea    0x18(%ebp),%eax
c002955c:	89 45 f4             	mov    %eax,-0xc(%ebp)
      vprintf (message, args);
c002955f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029562:	83 ec 08             	sub    $0x8,%esp
c0029565:	50                   	push   %eax
c0029566:	ff 75 14             	push   0x14(%ebp)
c0029569:	e8 42 21 00 00       	call   c002b6b0 <vprintf>
c002956e:	83 c4 10             	add    $0x10,%esp
      printf ("\n");
c0029571:	83 ec 0c             	sub    $0xc,%esp
c0029574:	6a 0a                	push   $0xa
c0029576:	e8 ed 21 00 00       	call   c002b768 <putchar>
c002957b:	83 c4 10             	add    $0x10,%esp
      va_end (args);

      debug_backtrace ();
c002957e:	e8 eb d8 ff ff       	call   c0026e6e <debug_backtrace>
c0029583:	eb 20                	jmp    c00295a5 <debug_panic+0x87>
    }
  else if (level == 2)
c0029585:	a1 c4 53 03 c0       	mov    0xc00353c4,%eax
c002958a:	83 f8 02             	cmp    $0x2,%eax
c002958d:	75 16                	jne    c00295a5 <debug_panic+0x87>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c002958f:	ff 75 10             	push   0x10(%ebp)
c0029592:	ff 75 0c             	push   0xc(%ebp)
c0029595:	ff 75 08             	push   0x8(%ebp)
c0029598:	68 c4 0b 03 c0       	push   $0xc0030bc4
c002959d:	e8 da db ff ff       	call   c002717c <printf>
c00295a2:	83 c4 10             	add    $0x10,%esp
  else 
    {
      /* Don't print anything: that's probably why we recursed. */
    }

  serial_flush ();
c00295a5:	e8 99 b4 ff ff       	call   c0024a43 <serial_flush>
  shutdown ();
c00295aa:	e8 2b d6 ff ff       	call   c0026bda <shutdown>
  for (;;);
c00295af:	eb fe                	jmp    c00295af <debug_panic+0x91>

c00295b1 <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c00295b1:	55                   	push   %ebp
c00295b2:	89 e5                	mov    %esp,%ebp
c00295b4:	83 ec 18             	sub    $0x18,%esp
  void *retaddr = NULL, **frame = NULL;
c00295b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00295be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  const char *status = "UNKNOWN";
c00295c5:	c7 45 ec ee 0b 03 c0 	movl   $0xc0030bee,-0x14(%ebp)

  switch (t->status) {
c00295cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00295cf:	8b 40 04             	mov    0x4(%eax),%eax
c00295d2:	83 f8 02             	cmp    $0x2,%eax
c00295d5:	74 22                	je     c00295f9 <print_stacktrace+0x48>
c00295d7:	83 f8 02             	cmp    $0x2,%eax
c00295da:	77 26                	ja     c0029602 <print_stacktrace+0x51>
c00295dc:	85 c0                	test   %eax,%eax
c00295de:	74 07                	je     c00295e7 <print_stacktrace+0x36>
c00295e0:	83 f8 01             	cmp    $0x1,%eax
c00295e3:	74 0b                	je     c00295f0 <print_stacktrace+0x3f>
    case THREAD_BLOCKED:  
      status = "BLOCKED";
      break;

    default:
      break;
c00295e5:	eb 1b                	jmp    c0029602 <print_stacktrace+0x51>
      status = "RUNNING";
c00295e7:	c7 45 ec f6 0b 03 c0 	movl   $0xc0030bf6,-0x14(%ebp)
      break;
c00295ee:	eb 13                	jmp    c0029603 <print_stacktrace+0x52>
      status = "READY";
c00295f0:	c7 45 ec fe 0b 03 c0 	movl   $0xc0030bfe,-0x14(%ebp)
      break;
c00295f7:	eb 0a                	jmp    c0029603 <print_stacktrace+0x52>
      status = "BLOCKED";
c00295f9:	c7 45 ec 04 0c 03 c0 	movl   $0xc0030c04,-0x14(%ebp)
      break;
c0029600:	eb 01                	jmp    c0029603 <print_stacktrace+0x52>
      break;
c0029602:	90                   	nop
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c0029603:	8b 45 08             	mov    0x8(%ebp),%eax
c0029606:	83 c0 08             	add    $0x8,%eax
c0029609:	83 ec 04             	sub    $0x4,%esp
c002960c:	ff 75 ec             	push   -0x14(%ebp)
c002960f:	50                   	push   %eax
c0029610:	68 0c 0c 03 c0       	push   $0xc0030c0c
c0029615:	e8 62 db ff ff       	call   c002717c <printf>
c002961a:	83 c4 10             	add    $0x10,%esp

  if (t == thread_current()) 
c002961d:	e8 56 76 ff ff       	call   c0020c78 <thread_current>
c0029622:	39 45 08             	cmp    %eax,0x8(%ebp)
c0029625:	75 0e                	jne    c0029635 <print_stacktrace+0x84>
    {
      frame = __builtin_frame_address (1);
c0029627:	8b 45 00             	mov    0x0(%ebp),%eax
c002962a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = __builtin_return_address (0);
c002962d:	8b 45 04             	mov    0x4(%ebp),%eax
c0029630:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029633:	eb 4d                	jmp    c0029682 <print_stacktrace+0xd1>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c0029635:	8b 45 08             	mov    0x8(%ebp),%eax
c0029638:	8b 40 18             	mov    0x18(%eax),%eax
c002963b:	89 45 e8             	mov    %eax,-0x18(%ebp)
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c002963e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029641:	8b 40 18             	mov    0x18(%eax),%eax
c0029644:	8b 55 08             	mov    0x8(%ebp),%edx
c0029647:	81 c2 00 10 00 00    	add    $0x1000,%edx
c002964d:	39 d0                	cmp    %edx,%eax
c002964f:	74 0d                	je     c002965e <print_stacktrace+0xad>
c0029651:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029654:	8b 40 10             	mov    0x10(%eax),%eax
c0029657:	3d 03 13 02 c0       	cmp    $0xc0021303,%eax
c002965c:	75 12                	jne    c0029670 <print_stacktrace+0xbf>
        {
          printf (" thread was never scheduled.\n");
c002965e:	83 ec 0c             	sub    $0xc,%esp
c0029661:	68 33 0c 03 c0       	push   $0xc0030c33
c0029666:	e8 78 20 00 00       	call   c002b6e3 <puts>
c002966b:	83 c4 10             	add    $0x10,%esp
          return;
c002966e:	eb 6b                	jmp    c00296db <print_stacktrace+0x12a>
        }

      frame = (void **) saved_frame->ebp;
c0029670:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029673:	8b 40 08             	mov    0x8(%eax),%eax
c0029676:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = (void *) saved_frame->eip;
c0029679:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002967c:	8b 40 10             	mov    0x10(%eax),%eax
c002967f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

  printf (" %p", retaddr);
c0029682:	83 ec 08             	sub    $0x8,%esp
c0029685:	ff 75 f4             	push   -0xc(%ebp)
c0029688:	68 50 0c 03 c0       	push   $0xc0030c50
c002968d:	e8 ea da ff ff       	call   c002717c <printf>
c0029692:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0029695:	eb 21                	jmp    c00296b8 <print_stacktrace+0x107>
    printf (" %p", frame[1]);
c0029697:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002969a:	83 c0 04             	add    $0x4,%eax
c002969d:	8b 00                	mov    (%eax),%eax
c002969f:	83 ec 08             	sub    $0x8,%esp
c00296a2:	50                   	push   %eax
c00296a3:	68 50 0c 03 c0       	push   $0xc0030c50
c00296a8:	e8 cf da ff ff       	call   c002717c <printf>
c00296ad:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c00296b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00296b3:	8b 00                	mov    (%eax),%eax
c00296b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00296b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00296bb:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c00296c0:	76 09                	jbe    c00296cb <print_stacktrace+0x11a>
c00296c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00296c5:	8b 00                	mov    (%eax),%eax
c00296c7:	85 c0                	test   %eax,%eax
c00296c9:	75 cc                	jne    c0029697 <print_stacktrace+0xe6>
  printf (".\n");
c00296cb:	83 ec 0c             	sub    $0xc,%esp
c00296ce:	68 54 0c 03 c0       	push   $0xc0030c54
c00296d3:	e8 0b 20 00 00       	call   c002b6e3 <puts>
c00296d8:	83 c4 10             	add    $0x10,%esp
}
c00296db:	c9                   	leave  
c00296dc:	c3                   	ret    

c00296dd <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c00296dd:	55                   	push   %ebp
c00296de:	89 e5                	mov    %esp,%ebp
c00296e0:	83 ec 18             	sub    $0x18,%esp
  enum intr_level oldlevel = intr_disable ();
c00296e3:	e8 b5 7c ff ff       	call   c002139d <intr_disable>
c00296e8:	89 45 f4             	mov    %eax,-0xc(%ebp)

  thread_foreach (print_stacktrace, 0);
c00296eb:	83 ec 08             	sub    $0x8,%esp
c00296ee:	6a 00                	push   $0x0
c00296f0:	68 b1 95 02 c0       	push   $0xc00295b1
c00296f5:	e8 f8 76 ff ff       	call   c0020df2 <thread_foreach>
c00296fa:	83 c4 10             	add    $0x10,%esp
  intr_set_level (oldlevel);
c00296fd:	83 ec 0c             	sub    $0xc,%esp
c0029700:	ff 75 f4             	push   -0xc(%ebp)
c0029703:	e8 3d 7c ff ff       	call   c0021345 <intr_set_level>
c0029708:	83 c4 10             	add    $0x10,%esp
}
c002970b:	90                   	nop
c002970c:	c9                   	leave  
c002970d:	c3                   	ret    

c002970e <is_head>:
                       list_less_func *less, void *aux) UNUSED;

/* Returns true if ELEM is a head, false otherwise. */
static inline bool
is_head (struct list_elem *elem)
{
c002970e:	55                   	push   %ebp
c002970f:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029711:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029715:	74 1a                	je     c0029731 <is_head+0x23>
c0029717:	8b 45 08             	mov    0x8(%ebp),%eax
c002971a:	8b 00                	mov    (%eax),%eax
c002971c:	85 c0                	test   %eax,%eax
c002971e:	75 11                	jne    c0029731 <is_head+0x23>
c0029720:	8b 45 08             	mov    0x8(%ebp),%eax
c0029723:	8b 40 04             	mov    0x4(%eax),%eax
c0029726:	85 c0                	test   %eax,%eax
c0029728:	74 07                	je     c0029731 <is_head+0x23>
c002972a:	b8 01 00 00 00       	mov    $0x1,%eax
c002972f:	eb 05                	jmp    c0029736 <is_head+0x28>
c0029731:	b8 00 00 00 00       	mov    $0x0,%eax
c0029736:	83 e0 01             	and    $0x1,%eax
}
c0029739:	5d                   	pop    %ebp
c002973a:	c3                   	ret    

c002973b <is_interior>:

/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
c002973b:	55                   	push   %ebp
c002973c:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c002973e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029742:	74 1a                	je     c002975e <is_interior+0x23>
c0029744:	8b 45 08             	mov    0x8(%ebp),%eax
c0029747:	8b 00                	mov    (%eax),%eax
c0029749:	85 c0                	test   %eax,%eax
c002974b:	74 11                	je     c002975e <is_interior+0x23>
c002974d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029750:	8b 40 04             	mov    0x4(%eax),%eax
c0029753:	85 c0                	test   %eax,%eax
c0029755:	74 07                	je     c002975e <is_interior+0x23>
c0029757:	b8 01 00 00 00       	mov    $0x1,%eax
c002975c:	eb 05                	jmp    c0029763 <is_interior+0x28>
c002975e:	b8 00 00 00 00       	mov    $0x0,%eax
c0029763:	83 e0 01             	and    $0x1,%eax
}
c0029766:	5d                   	pop    %ebp
c0029767:	c3                   	ret    

c0029768 <is_tail>:

/* Returns true if ELEM is a tail, false otherwise. */
static inline bool
is_tail (struct list_elem *elem)
{
c0029768:	55                   	push   %ebp
c0029769:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c002976b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002976f:	74 1a                	je     c002978b <is_tail+0x23>
c0029771:	8b 45 08             	mov    0x8(%ebp),%eax
c0029774:	8b 00                	mov    (%eax),%eax
c0029776:	85 c0                	test   %eax,%eax
c0029778:	74 11                	je     c002978b <is_tail+0x23>
c002977a:	8b 45 08             	mov    0x8(%ebp),%eax
c002977d:	8b 40 04             	mov    0x4(%eax),%eax
c0029780:	85 c0                	test   %eax,%eax
c0029782:	75 07                	jne    c002978b <is_tail+0x23>
c0029784:	b8 01 00 00 00       	mov    $0x1,%eax
c0029789:	eb 05                	jmp    c0029790 <is_tail+0x28>
c002978b:	b8 00 00 00 00       	mov    $0x0,%eax
c0029790:	83 e0 01             	and    $0x1,%eax
}
c0029793:	5d                   	pop    %ebp
c0029794:	c3                   	ret    

c0029795 <list_init>:

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c0029795:	55                   	push   %ebp
c0029796:	89 e5                	mov    %esp,%ebp
c0029798:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002979b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002979f:	75 1e                	jne    c00297bf <list_init+0x2a>
c00297a1:	83 ec 0c             	sub    $0xc,%esp
c00297a4:	68 58 0c 03 c0       	push   $0xc0030c58
c00297a9:	68 65 0c 03 c0       	push   $0xc0030c65
c00297ae:	68 30 0e 03 c0       	push   $0xc0030e30
c00297b3:	6a 3f                	push   $0x3f
c00297b5:	68 7c 0c 03 c0       	push   $0xc0030c7c
c00297ba:	e8 5f fd ff ff       	call   c002951e <debug_panic>
  list->head.prev = NULL;
c00297bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00297c2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c00297c8:	8b 45 08             	mov    0x8(%ebp),%eax
c00297cb:	8d 50 08             	lea    0x8(%eax),%edx
c00297ce:	8b 45 08             	mov    0x8(%ebp),%eax
c00297d1:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c00297d4:	8b 55 08             	mov    0x8(%ebp),%edx
c00297d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00297da:	89 50 08             	mov    %edx,0x8(%eax)
  list->tail.next = NULL;
c00297dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00297e0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c00297e7:	90                   	nop
c00297e8:	c9                   	leave  
c00297e9:	c3                   	ret    

c00297ea <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c00297ea:	55                   	push   %ebp
c00297eb:	89 e5                	mov    %esp,%ebp
c00297ed:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c00297f0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00297f4:	75 1e                	jne    c0029814 <list_begin+0x2a>
c00297f6:	83 ec 0c             	sub    $0xc,%esp
c00297f9:	68 58 0c 03 c0       	push   $0xc0030c58
c00297fe:	68 65 0c 03 c0       	push   $0xc0030c65
c0029803:	68 3c 0e 03 c0       	push   $0xc0030e3c
c0029808:	6a 4a                	push   $0x4a
c002980a:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002980f:	e8 0a fd ff ff       	call   c002951e <debug_panic>
  return list->head.next;
c0029814:	8b 45 08             	mov    0x8(%ebp),%eax
c0029817:	8b 40 04             	mov    0x4(%eax),%eax
}
c002981a:	c9                   	leave  
c002981b:	c3                   	ret    

c002981c <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c002981c:	55                   	push   %ebp
c002981d:	89 e5                	mov    %esp,%ebp
c002981f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_head (elem) || is_interior (elem));
c0029822:	ff 75 08             	push   0x8(%ebp)
c0029825:	e8 e4 fe ff ff       	call   c002970e <is_head>
c002982a:	83 c4 04             	add    $0x4,%esp
c002982d:	84 c0                	test   %al,%al
c002982f:	75 2d                	jne    c002985e <list_next+0x42>
c0029831:	ff 75 08             	push   0x8(%ebp)
c0029834:	e8 02 ff ff ff       	call   c002973b <is_interior>
c0029839:	83 c4 04             	add    $0x4,%esp
c002983c:	84 c0                	test   %al,%al
c002983e:	75 1e                	jne    c002985e <list_next+0x42>
c0029840:	83 ec 0c             	sub    $0xc,%esp
c0029843:	68 94 0c 03 c0       	push   $0xc0030c94
c0029848:	68 65 0c 03 c0       	push   $0xc0030c65
c002984d:	68 48 0e 03 c0       	push   $0xc0030e48
c0029852:	6a 54                	push   $0x54
c0029854:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029859:	e8 c0 fc ff ff       	call   c002951e <debug_panic>
  return elem->next;
c002985e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029861:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029864:	c9                   	leave  
c0029865:	c3                   	ret    

c0029866 <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c0029866:	55                   	push   %ebp
c0029867:	89 e5                	mov    %esp,%ebp
c0029869:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002986c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029870:	75 1e                	jne    c0029890 <list_end+0x2a>
c0029872:	83 ec 0c             	sub    $0xc,%esp
c0029875:	68 58 0c 03 c0       	push   $0xc0030c58
c002987a:	68 65 0c 03 c0       	push   $0xc0030c65
c002987f:	68 54 0e 03 c0       	push   $0xc0030e54
c0029884:	6a 60                	push   $0x60
c0029886:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002988b:	e8 8e fc ff ff       	call   c002951e <debug_panic>
  return &list->tail;
c0029890:	8b 45 08             	mov    0x8(%ebp),%eax
c0029893:	83 c0 08             	add    $0x8,%eax
}
c0029896:	c9                   	leave  
c0029897:	c3                   	ret    

c0029898 <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c0029898:	55                   	push   %ebp
c0029899:	89 e5                	mov    %esp,%ebp
c002989b:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002989e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00298a2:	75 1e                	jne    c00298c2 <list_rbegin+0x2a>
c00298a4:	83 ec 0c             	sub    $0xc,%esp
c00298a7:	68 58 0c 03 c0       	push   $0xc0030c58
c00298ac:	68 65 0c 03 c0       	push   $0xc0030c65
c00298b1:	68 60 0e 03 c0       	push   $0xc0030e60
c00298b6:	6a 69                	push   $0x69
c00298b8:	68 7c 0c 03 c0       	push   $0xc0030c7c
c00298bd:	e8 5c fc ff ff       	call   c002951e <debug_panic>
  return list->tail.prev;
c00298c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00298c5:	8b 40 08             	mov    0x8(%eax),%eax
}
c00298c8:	c9                   	leave  
c00298c9:	c3                   	ret    

c00298ca <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c00298ca:	55                   	push   %ebp
c00298cb:	89 e5                	mov    %esp,%ebp
c00298cd:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem) || is_tail (elem));
c00298d0:	ff 75 08             	push   0x8(%ebp)
c00298d3:	e8 63 fe ff ff       	call   c002973b <is_interior>
c00298d8:	83 c4 04             	add    $0x4,%esp
c00298db:	84 c0                	test   %al,%al
c00298dd:	75 2d                	jne    c002990c <list_prev+0x42>
c00298df:	ff 75 08             	push   0x8(%ebp)
c00298e2:	e8 81 fe ff ff       	call   c0029768 <is_tail>
c00298e7:	83 c4 04             	add    $0x4,%esp
c00298ea:	84 c0                	test   %al,%al
c00298ec:	75 1e                	jne    c002990c <list_prev+0x42>
c00298ee:	83 ec 0c             	sub    $0xc,%esp
c00298f1:	68 bc 0c 03 c0       	push   $0xc0030cbc
c00298f6:	68 65 0c 03 c0       	push   $0xc0030c65
c00298fb:	68 6c 0e 03 c0       	push   $0xc0030e6c
c0029900:	6a 73                	push   $0x73
c0029902:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029907:	e8 12 fc ff ff       	call   c002951e <debug_panic>
  return elem->prev;
c002990c:	8b 45 08             	mov    0x8(%ebp),%eax
c002990f:	8b 00                	mov    (%eax),%eax
}
c0029911:	c9                   	leave  
c0029912:	c3                   	ret    

c0029913 <list_rend>:
          ...do something with f...
        }
*/
struct list_elem *
list_rend (struct list *list) 
{
c0029913:	55                   	push   %ebp
c0029914:	89 e5                	mov    %esp,%ebp
c0029916:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029919:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002991d:	75 21                	jne    c0029940 <list_rend+0x2d>
c002991f:	83 ec 0c             	sub    $0xc,%esp
c0029922:	68 58 0c 03 c0       	push   $0xc0030c58
c0029927:	68 65 0c 03 c0       	push   $0xc0030c65
c002992c:	68 78 0e 03 c0       	push   $0xc0030e78
c0029931:	68 87 00 00 00       	push   $0x87
c0029936:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002993b:	e8 de fb ff ff       	call   c002951e <debug_panic>
  return &list->head;
c0029940:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029943:	c9                   	leave  
c0029944:	c3                   	ret    

c0029945 <list_head>:
          ...
        }
*/
struct list_elem *
list_head (struct list *list) 
{
c0029945:	55                   	push   %ebp
c0029946:	89 e5                	mov    %esp,%ebp
c0029948:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002994b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002994f:	75 21                	jne    c0029972 <list_head+0x2d>
c0029951:	83 ec 0c             	sub    $0xc,%esp
c0029954:	68 58 0c 03 c0       	push   $0xc0030c58
c0029959:	68 65 0c 03 c0       	push   $0xc0030c65
c002995e:	68 84 0e 03 c0       	push   $0xc0030e84
c0029963:	68 99 00 00 00       	push   $0x99
c0029968:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002996d:	e8 ac fb ff ff       	call   c002951e <debug_panic>
  return &list->head;
c0029972:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029975:	c9                   	leave  
c0029976:	c3                   	ret    

c0029977 <list_tail>:

/* Return's LIST's tail. */
struct list_elem *
list_tail (struct list *list) 
{
c0029977:	55                   	push   %ebp
c0029978:	89 e5                	mov    %esp,%ebp
c002997a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002997d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029981:	75 21                	jne    c00299a4 <list_tail+0x2d>
c0029983:	83 ec 0c             	sub    $0xc,%esp
c0029986:	68 58 0c 03 c0       	push   $0xc0030c58
c002998b:	68 65 0c 03 c0       	push   $0xc0030c65
c0029990:	68 90 0e 03 c0       	push   $0xc0030e90
c0029995:	68 a1 00 00 00       	push   $0xa1
c002999a:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002999f:	e8 7a fb ff ff       	call   c002951e <debug_panic>
  return &list->tail;
c00299a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00299a7:	83 c0 08             	add    $0x8,%eax
}
c00299aa:	c9                   	leave  
c00299ab:	c3                   	ret    

c00299ac <list_insert>:
/* Inserts ELEM just before BEFORE, which may be either an
   interior element or a tail.  The latter case is equivalent to
   list_push_back(). */
void
list_insert (struct list_elem *before, struct list_elem *elem)
{
c00299ac:	55                   	push   %ebp
c00299ad:	89 e5                	mov    %esp,%ebp
c00299af:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c00299b2:	ff 75 08             	push   0x8(%ebp)
c00299b5:	e8 81 fd ff ff       	call   c002973b <is_interior>
c00299ba:	83 c4 04             	add    $0x4,%esp
c00299bd:	84 c0                	test   %al,%al
c00299bf:	75 30                	jne    c00299f1 <list_insert+0x45>
c00299c1:	ff 75 08             	push   0x8(%ebp)
c00299c4:	e8 9f fd ff ff       	call   c0029768 <is_tail>
c00299c9:	83 c4 04             	add    $0x4,%esp
c00299cc:	84 c0                	test   %al,%al
c00299ce:	75 21                	jne    c00299f1 <list_insert+0x45>
c00299d0:	83 ec 0c             	sub    $0xc,%esp
c00299d3:	68 e4 0c 03 c0       	push   $0xc0030ce4
c00299d8:	68 65 0c 03 c0       	push   $0xc0030c65
c00299dd:	68 9c 0e 03 c0       	push   $0xc0030e9c
c00299e2:	68 ab 00 00 00       	push   $0xab
c00299e7:	68 7c 0c 03 c0       	push   $0xc0030c7c
c00299ec:	e8 2d fb ff ff       	call   c002951e <debug_panic>
  ASSERT (elem != NULL);
c00299f1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00299f5:	75 21                	jne    c0029a18 <list_insert+0x6c>
c00299f7:	83 ec 0c             	sub    $0xc,%esp
c00299fa:	68 0d 0d 03 c0       	push   $0xc0030d0d
c00299ff:	68 65 0c 03 c0       	push   $0xc0030c65
c0029a04:	68 9c 0e 03 c0       	push   $0xc0030e9c
c0029a09:	68 ac 00 00 00       	push   $0xac
c0029a0e:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029a13:	e8 06 fb ff ff       	call   c002951e <debug_panic>

  elem->prev = before->prev;
c0029a18:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a1b:	8b 10                	mov    (%eax),%edx
c0029a1d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029a20:	89 10                	mov    %edx,(%eax)
  elem->next = before;
c0029a22:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029a25:	8b 55 08             	mov    0x8(%ebp),%edx
c0029a28:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = elem;
c0029a2b:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a2e:	8b 00                	mov    (%eax),%eax
c0029a30:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029a33:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = elem;
c0029a36:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a39:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029a3c:	89 10                	mov    %edx,(%eax)
}
c0029a3e:	90                   	nop
c0029a3f:	c9                   	leave  
c0029a40:	c3                   	ret    

c0029a41 <list_splice>:
   current list, then inserts them just before BEFORE, which may
   be either an interior element or a tail. */
void
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
c0029a41:	55                   	push   %ebp
c0029a42:	89 e5                	mov    %esp,%ebp
c0029a44:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c0029a47:	ff 75 08             	push   0x8(%ebp)
c0029a4a:	e8 ec fc ff ff       	call   c002973b <is_interior>
c0029a4f:	83 c4 04             	add    $0x4,%esp
c0029a52:	84 c0                	test   %al,%al
c0029a54:	75 30                	jne    c0029a86 <list_splice+0x45>
c0029a56:	ff 75 08             	push   0x8(%ebp)
c0029a59:	e8 0a fd ff ff       	call   c0029768 <is_tail>
c0029a5e:	83 c4 04             	add    $0x4,%esp
c0029a61:	84 c0                	test   %al,%al
c0029a63:	75 21                	jne    c0029a86 <list_splice+0x45>
c0029a65:	83 ec 0c             	sub    $0xc,%esp
c0029a68:	68 e4 0c 03 c0       	push   $0xc0030ce4
c0029a6d:	68 65 0c 03 c0       	push   $0xc0030c65
c0029a72:	68 a8 0e 03 c0       	push   $0xc0030ea8
c0029a77:	68 bb 00 00 00       	push   $0xbb
c0029a7c:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029a81:	e8 98 fa ff ff       	call   c002951e <debug_panic>
  if (first == last)
c0029a86:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029a89:	3b 45 10             	cmp    0x10(%ebp),%eax
c0029a8c:	0f 84 ba 00 00 00    	je     c0029b4c <list_splice+0x10b>
    return;
  last = list_prev (last);
c0029a92:	83 ec 0c             	sub    $0xc,%esp
c0029a95:	ff 75 10             	push   0x10(%ebp)
c0029a98:	e8 2d fe ff ff       	call   c00298ca <list_prev>
c0029a9d:	83 c4 10             	add    $0x10,%esp
c0029aa0:	89 45 10             	mov    %eax,0x10(%ebp)

  ASSERT (is_interior (first));
c0029aa3:	83 ec 0c             	sub    $0xc,%esp
c0029aa6:	ff 75 0c             	push   0xc(%ebp)
c0029aa9:	e8 8d fc ff ff       	call   c002973b <is_interior>
c0029aae:	83 c4 10             	add    $0x10,%esp
c0029ab1:	84 c0                	test   %al,%al
c0029ab3:	75 21                	jne    c0029ad6 <list_splice+0x95>
c0029ab5:	83 ec 0c             	sub    $0xc,%esp
c0029ab8:	68 1a 0d 03 c0       	push   $0xc0030d1a
c0029abd:	68 65 0c 03 c0       	push   $0xc0030c65
c0029ac2:	68 a8 0e 03 c0       	push   $0xc0030ea8
c0029ac7:	68 c0 00 00 00       	push   $0xc0
c0029acc:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029ad1:	e8 48 fa ff ff       	call   c002951e <debug_panic>
  ASSERT (is_interior (last));
c0029ad6:	83 ec 0c             	sub    $0xc,%esp
c0029ad9:	ff 75 10             	push   0x10(%ebp)
c0029adc:	e8 5a fc ff ff       	call   c002973b <is_interior>
c0029ae1:	83 c4 10             	add    $0x10,%esp
c0029ae4:	84 c0                	test   %al,%al
c0029ae6:	75 21                	jne    c0029b09 <list_splice+0xc8>
c0029ae8:	83 ec 0c             	sub    $0xc,%esp
c0029aeb:	68 2e 0d 03 c0       	push   $0xc0030d2e
c0029af0:	68 65 0c 03 c0       	push   $0xc0030c65
c0029af5:	68 a8 0e 03 c0       	push   $0xc0030ea8
c0029afa:	68 c1 00 00 00       	push   $0xc1
c0029aff:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029b04:	e8 15 fa ff ff       	call   c002951e <debug_panic>

  /* Cleanly remove FIRST...LAST from its current list. */
  first->prev->next = last->next;
c0029b09:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029b0c:	8b 00                	mov    (%eax),%eax
c0029b0e:	8b 55 10             	mov    0x10(%ebp),%edx
c0029b11:	8b 52 04             	mov    0x4(%edx),%edx
c0029b14:	89 50 04             	mov    %edx,0x4(%eax)
  last->next->prev = first->prev;
c0029b17:	8b 45 10             	mov    0x10(%ebp),%eax
c0029b1a:	8b 40 04             	mov    0x4(%eax),%eax
c0029b1d:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029b20:	8b 12                	mov    (%edx),%edx
c0029b22:	89 10                	mov    %edx,(%eax)

  /* Splice FIRST...LAST into new list. */
  first->prev = before->prev;
c0029b24:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b27:	8b 10                	mov    (%eax),%edx
c0029b29:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029b2c:	89 10                	mov    %edx,(%eax)
  last->next = before;
c0029b2e:	8b 45 10             	mov    0x10(%ebp),%eax
c0029b31:	8b 55 08             	mov    0x8(%ebp),%edx
c0029b34:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = first;
c0029b37:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b3a:	8b 00                	mov    (%eax),%eax
c0029b3c:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029b3f:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = last;
c0029b42:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b45:	8b 55 10             	mov    0x10(%ebp),%edx
c0029b48:	89 10                	mov    %edx,(%eax)
c0029b4a:	eb 01                	jmp    c0029b4d <list_splice+0x10c>
    return;
c0029b4c:	90                   	nop
}
c0029b4d:	c9                   	leave  
c0029b4e:	c3                   	ret    

c0029b4f <list_push_front>:

/* Inserts ELEM at the beginning of LIST, so that it becomes the
   front in LIST. */
void
list_push_front (struct list *list, struct list_elem *elem)
{
c0029b4f:	55                   	push   %ebp
c0029b50:	89 e5                	mov    %esp,%ebp
c0029b52:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_begin (list), elem);
c0029b55:	83 ec 0c             	sub    $0xc,%esp
c0029b58:	ff 75 08             	push   0x8(%ebp)
c0029b5b:	e8 8a fc ff ff       	call   c00297ea <list_begin>
c0029b60:	83 c4 10             	add    $0x10,%esp
c0029b63:	83 ec 08             	sub    $0x8,%esp
c0029b66:	ff 75 0c             	push   0xc(%ebp)
c0029b69:	50                   	push   %eax
c0029b6a:	e8 3d fe ff ff       	call   c00299ac <list_insert>
c0029b6f:	83 c4 10             	add    $0x10,%esp
}
c0029b72:	90                   	nop
c0029b73:	c9                   	leave  
c0029b74:	c3                   	ret    

c0029b75 <list_push_back>:

/* Inserts ELEM at the end of LIST, so that it becomes the
   back in LIST. */
void
list_push_back (struct list *list, struct list_elem *elem)
{
c0029b75:	55                   	push   %ebp
c0029b76:	89 e5                	mov    %esp,%ebp
c0029b78:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_end (list), elem);
c0029b7b:	83 ec 0c             	sub    $0xc,%esp
c0029b7e:	ff 75 08             	push   0x8(%ebp)
c0029b81:	e8 e0 fc ff ff       	call   c0029866 <list_end>
c0029b86:	83 c4 10             	add    $0x10,%esp
c0029b89:	83 ec 08             	sub    $0x8,%esp
c0029b8c:	ff 75 0c             	push   0xc(%ebp)
c0029b8f:	50                   	push   %eax
c0029b90:	e8 17 fe ff ff       	call   c00299ac <list_insert>
c0029b95:	83 c4 10             	add    $0x10,%esp
}
c0029b98:	90                   	nop
c0029b99:	c9                   	leave  
c0029b9a:	c3                   	ret    

c0029b9b <list_remove>:
       ...do something with e...
     }
*/
struct list_elem *
list_remove (struct list_elem *elem)
{
c0029b9b:	55                   	push   %ebp
c0029b9c:	89 e5                	mov    %esp,%ebp
c0029b9e:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem));
c0029ba1:	ff 75 08             	push   0x8(%ebp)
c0029ba4:	e8 92 fb ff ff       	call   c002973b <is_interior>
c0029ba9:	83 c4 04             	add    $0x4,%esp
c0029bac:	84 c0                	test   %al,%al
c0029bae:	75 21                	jne    c0029bd1 <list_remove+0x36>
c0029bb0:	83 ec 0c             	sub    $0xc,%esp
c0029bb3:	68 41 0d 03 c0       	push   $0xc0030d41
c0029bb8:	68 65 0c 03 c0       	push   $0xc0030c65
c0029bbd:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029bc2:	68 fb 00 00 00       	push   $0xfb
c0029bc7:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029bcc:	e8 4d f9 ff ff       	call   c002951e <debug_panic>
  elem->prev->next = elem->next;
c0029bd1:	8b 45 08             	mov    0x8(%ebp),%eax
c0029bd4:	8b 00                	mov    (%eax),%eax
c0029bd6:	8b 55 08             	mov    0x8(%ebp),%edx
c0029bd9:	8b 52 04             	mov    0x4(%edx),%edx
c0029bdc:	89 50 04             	mov    %edx,0x4(%eax)
  elem->next->prev = elem->prev;
c0029bdf:	8b 45 08             	mov    0x8(%ebp),%eax
c0029be2:	8b 40 04             	mov    0x4(%eax),%eax
c0029be5:	8b 55 08             	mov    0x8(%ebp),%edx
c0029be8:	8b 12                	mov    (%edx),%edx
c0029bea:	89 10                	mov    %edx,(%eax)
  return elem->next;
c0029bec:	8b 45 08             	mov    0x8(%ebp),%eax
c0029bef:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029bf2:	c9                   	leave  
c0029bf3:	c3                   	ret    

c0029bf4 <list_pop_front>:

/* Removes the front element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_front (struct list *list)
{
c0029bf4:	55                   	push   %ebp
c0029bf5:	89 e5                	mov    %esp,%ebp
c0029bf7:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *front = list_front (list);
c0029bfa:	83 ec 0c             	sub    $0xc,%esp
c0029bfd:	ff 75 08             	push   0x8(%ebp)
c0029c00:	e8 43 00 00 00       	call   c0029c48 <list_front>
c0029c05:	83 c4 10             	add    $0x10,%esp
c0029c08:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (front);
c0029c0b:	83 ec 0c             	sub    $0xc,%esp
c0029c0e:	ff 75 f4             	push   -0xc(%ebp)
c0029c11:	e8 85 ff ff ff       	call   c0029b9b <list_remove>
c0029c16:	83 c4 10             	add    $0x10,%esp
  return front;
c0029c19:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0029c1c:	c9                   	leave  
c0029c1d:	c3                   	ret    

c0029c1e <list_pop_back>:

/* Removes the back element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_back (struct list *list)
{
c0029c1e:	55                   	push   %ebp
c0029c1f:	89 e5                	mov    %esp,%ebp
c0029c21:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *back = list_back (list);
c0029c24:	83 ec 0c             	sub    $0xc,%esp
c0029c27:	ff 75 08             	push   0x8(%ebp)
c0029c2a:	e8 5d 00 00 00       	call   c0029c8c <list_back>
c0029c2f:	83 c4 10             	add    $0x10,%esp
c0029c32:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (back);
c0029c35:	83 ec 0c             	sub    $0xc,%esp
c0029c38:	ff 75 f4             	push   -0xc(%ebp)
c0029c3b:	e8 5b ff ff ff       	call   c0029b9b <list_remove>
c0029c40:	83 c4 10             	add    $0x10,%esp
  return back;
c0029c43:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0029c46:	c9                   	leave  
c0029c47:	c3                   	ret    

c0029c48 <list_front>:

/* Returns the front element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_front (struct list *list)
{
c0029c48:	55                   	push   %ebp
c0029c49:	89 e5                	mov    %esp,%ebp
c0029c4b:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c0029c4e:	83 ec 0c             	sub    $0xc,%esp
c0029c51:	ff 75 08             	push   0x8(%ebp)
c0029c54:	e8 c3 00 00 00       	call   c0029d1c <list_empty>
c0029c59:	83 c4 10             	add    $0x10,%esp
c0029c5c:	83 f0 01             	xor    $0x1,%eax
c0029c5f:	84 c0                	test   %al,%al
c0029c61:	75 21                	jne    c0029c84 <list_front+0x3c>
c0029c63:	83 ec 0c             	sub    $0xc,%esp
c0029c66:	68 54 0d 03 c0       	push   $0xc0030d54
c0029c6b:	68 65 0c 03 c0       	push   $0xc0030c65
c0029c70:	68 c0 0e 03 c0       	push   $0xc0030ec0
c0029c75:	68 1a 01 00 00       	push   $0x11a
c0029c7a:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029c7f:	e8 9a f8 ff ff       	call   c002951e <debug_panic>
  return list->head.next;
c0029c84:	8b 45 08             	mov    0x8(%ebp),%eax
c0029c87:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029c8a:	c9                   	leave  
c0029c8b:	c3                   	ret    

c0029c8c <list_back>:

/* Returns the back element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_back (struct list *list)
{
c0029c8c:	55                   	push   %ebp
c0029c8d:	89 e5                	mov    %esp,%ebp
c0029c8f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c0029c92:	83 ec 0c             	sub    $0xc,%esp
c0029c95:	ff 75 08             	push   0x8(%ebp)
c0029c98:	e8 7f 00 00 00       	call   c0029d1c <list_empty>
c0029c9d:	83 c4 10             	add    $0x10,%esp
c0029ca0:	83 f0 01             	xor    $0x1,%eax
c0029ca3:	84 c0                	test   %al,%al
c0029ca5:	75 21                	jne    c0029cc8 <list_back+0x3c>
c0029ca7:	83 ec 0c             	sub    $0xc,%esp
c0029caa:	68 54 0d 03 c0       	push   $0xc0030d54
c0029caf:	68 65 0c 03 c0       	push   $0xc0030c65
c0029cb4:	68 cc 0e 03 c0       	push   $0xc0030ecc
c0029cb9:	68 23 01 00 00       	push   $0x123
c0029cbe:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029cc3:	e8 56 f8 ff ff       	call   c002951e <debug_panic>
  return list->tail.prev;
c0029cc8:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ccb:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029cce:	c9                   	leave  
c0029ccf:	c3                   	ret    

c0029cd0 <list_size>:

/* Returns the number of elements in LIST.
   Runs in O(n) in the number of elements. */
size_t
list_size (struct list *list)
{
c0029cd0:	55                   	push   %ebp
c0029cd1:	89 e5                	mov    %esp,%ebp
c0029cd3:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;
  size_t cnt = 0;
c0029cd6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029cdd:	83 ec 0c             	sub    $0xc,%esp
c0029ce0:	ff 75 08             	push   0x8(%ebp)
c0029ce3:	e8 02 fb ff ff       	call   c00297ea <list_begin>
c0029ce8:	83 c4 10             	add    $0x10,%esp
c0029ceb:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029cee:	eb 14                	jmp    c0029d04 <list_size+0x34>
    cnt++;
c0029cf0:	ff 45 f0             	incl   -0x10(%ebp)
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029cf3:	83 ec 0c             	sub    $0xc,%esp
c0029cf6:	ff 75 f4             	push   -0xc(%ebp)
c0029cf9:	e8 1e fb ff ff       	call   c002981c <list_next>
c0029cfe:	83 c4 10             	add    $0x10,%esp
c0029d01:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029d04:	83 ec 0c             	sub    $0xc,%esp
c0029d07:	ff 75 08             	push   0x8(%ebp)
c0029d0a:	e8 57 fb ff ff       	call   c0029866 <list_end>
c0029d0f:	83 c4 10             	add    $0x10,%esp
c0029d12:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0029d15:	75 d9                	jne    c0029cf0 <list_size+0x20>
  return cnt;
c0029d17:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0029d1a:	c9                   	leave  
c0029d1b:	c3                   	ret    

c0029d1c <list_empty>:

/* Returns true if LIST is empty, false otherwise. */
bool
list_empty (struct list *list)
{
c0029d1c:	55                   	push   %ebp
c0029d1d:	89 e5                	mov    %esp,%ebp
c0029d1f:	53                   	push   %ebx
c0029d20:	83 ec 04             	sub    $0x4,%esp
  return list_begin (list) == list_end (list);
c0029d23:	83 ec 0c             	sub    $0xc,%esp
c0029d26:	ff 75 08             	push   0x8(%ebp)
c0029d29:	e8 bc fa ff ff       	call   c00297ea <list_begin>
c0029d2e:	83 c4 10             	add    $0x10,%esp
c0029d31:	89 c3                	mov    %eax,%ebx
c0029d33:	83 ec 0c             	sub    $0xc,%esp
c0029d36:	ff 75 08             	push   0x8(%ebp)
c0029d39:	e8 28 fb ff ff       	call   c0029866 <list_end>
c0029d3e:	83 c4 10             	add    $0x10,%esp
c0029d41:	39 c3                	cmp    %eax,%ebx
c0029d43:	0f 94 c0             	sete   %al
}
c0029d46:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029d49:	c9                   	leave  
c0029d4a:	c3                   	ret    

c0029d4b <swap>:

/* Swaps the `struct list_elem *'s that A and B point to. */
static void
swap (struct list_elem **a, struct list_elem **b) 
{
c0029d4b:	55                   	push   %ebp
c0029d4c:	89 e5                	mov    %esp,%ebp
c0029d4e:	83 ec 10             	sub    $0x10,%esp
  struct list_elem *t = *a;
c0029d51:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d54:	8b 00                	mov    (%eax),%eax
c0029d56:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *a = *b;
c0029d59:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029d5c:	8b 10                	mov    (%eax),%edx
c0029d5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d61:	89 10                	mov    %edx,(%eax)
  *b = t;
c0029d63:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029d66:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0029d69:	89 10                	mov    %edx,(%eax)
}
c0029d6b:	90                   	nop
c0029d6c:	c9                   	leave  
c0029d6d:	c3                   	ret    

c0029d6e <list_reverse>:

/* Reverses the order of LIST. */
void
list_reverse (struct list *list)
{
c0029d6e:	55                   	push   %ebp
c0029d6f:	89 e5                	mov    %esp,%ebp
c0029d71:	83 ec 18             	sub    $0x18,%esp
  if (!list_empty (list)) 
c0029d74:	83 ec 0c             	sub    $0xc,%esp
c0029d77:	ff 75 08             	push   0x8(%ebp)
c0029d7a:	e8 9d ff ff ff       	call   c0029d1c <list_empty>
c0029d7f:	83 c4 10             	add    $0x10,%esp
c0029d82:	83 f0 01             	xor    $0x1,%eax
c0029d85:	84 c0                	test   %al,%al
c0029d87:	74 79                	je     c0029e02 <list_reverse+0x94>
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0029d89:	83 ec 0c             	sub    $0xc,%esp
c0029d8c:	ff 75 08             	push   0x8(%ebp)
c0029d8f:	e8 56 fa ff ff       	call   c00297ea <list_begin>
c0029d94:	83 c4 10             	add    $0x10,%esp
c0029d97:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029d9a:	eb 1e                	jmp    c0029dba <list_reverse+0x4c>
        swap (&e->prev, &e->next);
c0029d9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029d9f:	8d 50 04             	lea    0x4(%eax),%edx
c0029da2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029da5:	83 ec 08             	sub    $0x8,%esp
c0029da8:	52                   	push   %edx
c0029da9:	50                   	push   %eax
c0029daa:	e8 9c ff ff ff       	call   c0029d4b <swap>
c0029daf:	83 c4 10             	add    $0x10,%esp
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0029db2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029db5:	8b 00                	mov    (%eax),%eax
c0029db7:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029dba:	83 ec 0c             	sub    $0xc,%esp
c0029dbd:	ff 75 08             	push   0x8(%ebp)
c0029dc0:	e8 a1 fa ff ff       	call   c0029866 <list_end>
c0029dc5:	83 c4 10             	add    $0x10,%esp
c0029dc8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0029dcb:	75 cf                	jne    c0029d9c <list_reverse+0x2e>
      swap (&list->head.next, &list->tail.prev);
c0029dcd:	8b 45 08             	mov    0x8(%ebp),%eax
c0029dd0:	8d 50 08             	lea    0x8(%eax),%edx
c0029dd3:	8b 45 08             	mov    0x8(%ebp),%eax
c0029dd6:	83 c0 04             	add    $0x4,%eax
c0029dd9:	83 ec 08             	sub    $0x8,%esp
c0029ddc:	52                   	push   %edx
c0029ddd:	50                   	push   %eax
c0029dde:	e8 68 ff ff ff       	call   c0029d4b <swap>
c0029de3:	83 c4 10             	add    $0x10,%esp
      swap (&list->head.next->prev, &list->tail.prev->next);
c0029de6:	8b 45 08             	mov    0x8(%ebp),%eax
c0029de9:	8b 40 08             	mov    0x8(%eax),%eax
c0029dec:	8d 50 04             	lea    0x4(%eax),%edx
c0029def:	8b 45 08             	mov    0x8(%ebp),%eax
c0029df2:	8b 40 04             	mov    0x4(%eax),%eax
c0029df5:	83 ec 08             	sub    $0x8,%esp
c0029df8:	52                   	push   %edx
c0029df9:	50                   	push   %eax
c0029dfa:	e8 4c ff ff ff       	call   c0029d4b <swap>
c0029dff:	83 c4 10             	add    $0x10,%esp
    }
}
c0029e02:	90                   	nop
c0029e03:	c9                   	leave  
c0029e04:	c3                   	ret    

c0029e05 <is_sorted>:
/* Returns true only if the list elements A through B (exclusive)
   are in order according to LESS given auxiliary data AUX. */
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
c0029e05:	55                   	push   %ebp
c0029e06:	89 e5                	mov    %esp,%ebp
c0029e08:	83 ec 08             	sub    $0x8,%esp
  if (a != b)
c0029e0b:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e0e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029e11:	74 43                	je     c0029e56 <is_sorted+0x51>
    while ((a = list_next (a)) != b) 
c0029e13:	eb 28                	jmp    c0029e3d <is_sorted+0x38>
      if (less (a, list_prev (a), aux))
c0029e15:	83 ec 0c             	sub    $0xc,%esp
c0029e18:	ff 75 08             	push   0x8(%ebp)
c0029e1b:	e8 aa fa ff ff       	call   c00298ca <list_prev>
c0029e20:	83 c4 10             	add    $0x10,%esp
c0029e23:	83 ec 04             	sub    $0x4,%esp
c0029e26:	ff 75 14             	push   0x14(%ebp)
c0029e29:	50                   	push   %eax
c0029e2a:	ff 75 08             	push   0x8(%ebp)
c0029e2d:	8b 45 10             	mov    0x10(%ebp),%eax
c0029e30:	ff d0                	call   *%eax
c0029e32:	83 c4 10             	add    $0x10,%esp
c0029e35:	84 c0                	test   %al,%al
c0029e37:	74 04                	je     c0029e3d <is_sorted+0x38>
        return false;
c0029e39:	b0 00                	mov    $0x0,%al
c0029e3b:	eb 1b                	jmp    c0029e58 <is_sorted+0x53>
    while ((a = list_next (a)) != b) 
c0029e3d:	83 ec 0c             	sub    $0xc,%esp
c0029e40:	ff 75 08             	push   0x8(%ebp)
c0029e43:	e8 d4 f9 ff ff       	call   c002981c <list_next>
c0029e48:	83 c4 10             	add    $0x10,%esp
c0029e4b:	89 45 08             	mov    %eax,0x8(%ebp)
c0029e4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e51:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029e54:	75 bf                	jne    c0029e15 <is_sorted+0x10>
  return true;
c0029e56:	b0 01                	mov    $0x1,%al
}
c0029e58:	c9                   	leave  
c0029e59:	c3                   	ret    

c0029e5a <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c0029e5a:	55                   	push   %ebp
c0029e5b:	89 e5                	mov    %esp,%ebp
c0029e5d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c0029e60:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029e64:	75 21                	jne    c0029e87 <find_end_of_run+0x2d>
c0029e66:	83 ec 0c             	sub    $0xc,%esp
c0029e69:	68 67 0d 03 c0       	push   $0xc0030d67
c0029e6e:	68 65 0c 03 c0       	push   $0xc0030c65
c0029e73:	68 d8 0e 03 c0       	push   $0xc0030ed8
c0029e78:	68 69 01 00 00       	push   $0x169
c0029e7d:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029e82:	e8 97 f6 ff ff       	call   c002951e <debug_panic>
  ASSERT (b != NULL);
c0029e87:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0029e8b:	75 21                	jne    c0029eae <find_end_of_run+0x54>
c0029e8d:	83 ec 0c             	sub    $0xc,%esp
c0029e90:	68 71 0d 03 c0       	push   $0xc0030d71
c0029e95:	68 65 0c 03 c0       	push   $0xc0030c65
c0029e9a:	68 d8 0e 03 c0       	push   $0xc0030ed8
c0029e9f:	68 6a 01 00 00       	push   $0x16a
c0029ea4:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029ea9:	e8 70 f6 ff ff       	call   c002951e <debug_panic>
  ASSERT (less != NULL);
c0029eae:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0029eb2:	75 21                	jne    c0029ed5 <find_end_of_run+0x7b>
c0029eb4:	83 ec 0c             	sub    $0xc,%esp
c0029eb7:	68 7b 0d 03 c0       	push   $0xc0030d7b
c0029ebc:	68 65 0c 03 c0       	push   $0xc0030c65
c0029ec1:	68 d8 0e 03 c0       	push   $0xc0030ed8
c0029ec6:	68 6b 01 00 00       	push   $0x16b
c0029ecb:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029ed0:	e8 49 f6 ff ff       	call   c002951e <debug_panic>
  ASSERT (a != b);
c0029ed5:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ed8:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029edb:	75 21                	jne    c0029efe <find_end_of_run+0xa4>
c0029edd:	83 ec 0c             	sub    $0xc,%esp
c0029ee0:	68 88 0d 03 c0       	push   $0xc0030d88
c0029ee5:	68 65 0c 03 c0       	push   $0xc0030c65
c0029eea:	68 d8 0e 03 c0       	push   $0xc0030ed8
c0029eef:	68 6c 01 00 00       	push   $0x16c
c0029ef4:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029ef9:	e8 20 f6 ff ff       	call   c002951e <debug_panic>
  
  do 
    {
      a = list_next (a);
c0029efe:	83 ec 0c             	sub    $0xc,%esp
c0029f01:	ff 75 08             	push   0x8(%ebp)
c0029f04:	e8 13 f9 ff ff       	call   c002981c <list_next>
c0029f09:	83 c4 10             	add    $0x10,%esp
c0029f0c:	89 45 08             	mov    %eax,0x8(%ebp)
    }
  while (a != b && !less (a, list_prev (a), aux));
c0029f0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f12:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029f15:	74 27                	je     c0029f3e <find_end_of_run+0xe4>
c0029f17:	83 ec 0c             	sub    $0xc,%esp
c0029f1a:	ff 75 08             	push   0x8(%ebp)
c0029f1d:	e8 a8 f9 ff ff       	call   c00298ca <list_prev>
c0029f22:	83 c4 10             	add    $0x10,%esp
c0029f25:	83 ec 04             	sub    $0x4,%esp
c0029f28:	ff 75 14             	push   0x14(%ebp)
c0029f2b:	50                   	push   %eax
c0029f2c:	ff 75 08             	push   0x8(%ebp)
c0029f2f:	8b 45 10             	mov    0x10(%ebp),%eax
c0029f32:	ff d0                	call   *%eax
c0029f34:	83 c4 10             	add    $0x10,%esp
c0029f37:	83 f0 01             	xor    $0x1,%eax
c0029f3a:	84 c0                	test   %al,%al
c0029f3c:	75 c0                	jne    c0029efe <find_end_of_run+0xa4>
  return a;
c0029f3e:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029f41:	c9                   	leave  
c0029f42:	c3                   	ret    

c0029f43 <inplace_merge>:
   AUX.  The output range will be sorted the same way. */
static void
inplace_merge (struct list_elem *a0, struct list_elem *a1b0,
               struct list_elem *b1,
               list_less_func *less, void *aux)
{
c0029f43:	55                   	push   %ebp
c0029f44:	89 e5                	mov    %esp,%ebp
c0029f46:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a0 != NULL);
c0029f49:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029f4d:	75 21                	jne    c0029f70 <inplace_merge+0x2d>
c0029f4f:	83 ec 0c             	sub    $0xc,%esp
c0029f52:	68 8f 0d 03 c0       	push   $0xc0030d8f
c0029f57:	68 65 0c 03 c0       	push   $0xc0030c65
c0029f5c:	68 e8 0e 03 c0       	push   $0xc0030ee8
c0029f61:	68 80 01 00 00       	push   $0x180
c0029f66:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029f6b:	e8 ae f5 ff ff       	call   c002951e <debug_panic>
  ASSERT (a1b0 != NULL);
c0029f70:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0029f74:	75 21                	jne    c0029f97 <inplace_merge+0x54>
c0029f76:	83 ec 0c             	sub    $0xc,%esp
c0029f79:	68 9a 0d 03 c0       	push   $0xc0030d9a
c0029f7e:	68 65 0c 03 c0       	push   $0xc0030c65
c0029f83:	68 e8 0e 03 c0       	push   $0xc0030ee8
c0029f88:	68 81 01 00 00       	push   $0x181
c0029f8d:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029f92:	e8 87 f5 ff ff       	call   c002951e <debug_panic>
  ASSERT (b1 != NULL);
c0029f97:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0029f9b:	75 21                	jne    c0029fbe <inplace_merge+0x7b>
c0029f9d:	83 ec 0c             	sub    $0xc,%esp
c0029fa0:	68 a7 0d 03 c0       	push   $0xc0030da7
c0029fa5:	68 65 0c 03 c0       	push   $0xc0030c65
c0029faa:	68 e8 0e 03 c0       	push   $0xc0030ee8
c0029faf:	68 82 01 00 00       	push   $0x182
c0029fb4:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029fb9:	e8 60 f5 ff ff       	call   c002951e <debug_panic>
  ASSERT (less != NULL);
c0029fbe:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0029fc2:	75 21                	jne    c0029fe5 <inplace_merge+0xa2>
c0029fc4:	83 ec 0c             	sub    $0xc,%esp
c0029fc7:	68 7b 0d 03 c0       	push   $0xc0030d7b
c0029fcc:	68 65 0c 03 c0       	push   $0xc0030c65
c0029fd1:	68 e8 0e 03 c0       	push   $0xc0030ee8
c0029fd6:	68 83 01 00 00       	push   $0x183
c0029fdb:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029fe0:	e8 39 f5 ff ff       	call   c002951e <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c0029fe5:	ff 75 18             	push   0x18(%ebp)
c0029fe8:	ff 75 14             	push   0x14(%ebp)
c0029feb:	ff 75 0c             	push   0xc(%ebp)
c0029fee:	ff 75 08             	push   0x8(%ebp)
c0029ff1:	e8 0f fe ff ff       	call   c0029e05 <is_sorted>
c0029ff6:	83 c4 10             	add    $0x10,%esp
c0029ff9:	84 c0                	test   %al,%al
c0029ffb:	75 21                	jne    c002a01e <inplace_merge+0xdb>
c0029ffd:	83 ec 0c             	sub    $0xc,%esp
c002a000:	68 b4 0d 03 c0       	push   $0xc0030db4
c002a005:	68 65 0c 03 c0       	push   $0xc0030c65
c002a00a:	68 e8 0e 03 c0       	push   $0xc0030ee8
c002a00f:	68 84 01 00 00       	push   $0x184
c002a014:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a019:	e8 00 f5 ff ff       	call   c002951e <debug_panic>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c002a01e:	ff 75 18             	push   0x18(%ebp)
c002a021:	ff 75 14             	push   0x14(%ebp)
c002a024:	ff 75 10             	push   0x10(%ebp)
c002a027:	ff 75 0c             	push   0xc(%ebp)
c002a02a:	e8 d6 fd ff ff       	call   c0029e05 <is_sorted>
c002a02f:	83 c4 10             	add    $0x10,%esp
c002a032:	84 c0                	test   %al,%al
c002a034:	0f 85 80 00 00 00    	jne    c002a0ba <inplace_merge+0x177>
c002a03a:	83 ec 0c             	sub    $0xc,%esp
c002a03d:	68 d4 0d 03 c0       	push   $0xc0030dd4
c002a042:	68 65 0c 03 c0       	push   $0xc0030c65
c002a047:	68 e8 0e 03 c0       	push   $0xc0030ee8
c002a04c:	68 85 01 00 00       	push   $0x185
c002a051:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a056:	e8 c3 f4 ff ff       	call   c002951e <debug_panic>

  while (a0 != a1b0 && a1b0 != b1)
    if (!less (a1b0, a0, aux)) 
c002a05b:	83 ec 04             	sub    $0x4,%esp
c002a05e:	ff 75 18             	push   0x18(%ebp)
c002a061:	ff 75 08             	push   0x8(%ebp)
c002a064:	ff 75 0c             	push   0xc(%ebp)
c002a067:	8b 45 14             	mov    0x14(%ebp),%eax
c002a06a:	ff d0                	call   *%eax
c002a06c:	83 c4 10             	add    $0x10,%esp
c002a06f:	83 f0 01             	xor    $0x1,%eax
c002a072:	84 c0                	test   %al,%al
c002a074:	74 13                	je     c002a089 <inplace_merge+0x146>
      a0 = list_next (a0);
c002a076:	83 ec 0c             	sub    $0xc,%esp
c002a079:	ff 75 08             	push   0x8(%ebp)
c002a07c:	e8 9b f7 ff ff       	call   c002981c <list_next>
c002a081:	83 c4 10             	add    $0x10,%esp
c002a084:	89 45 08             	mov    %eax,0x8(%ebp)
c002a087:	eb 31                	jmp    c002a0ba <inplace_merge+0x177>
    else 
      {
        a1b0 = list_next (a1b0);
c002a089:	83 ec 0c             	sub    $0xc,%esp
c002a08c:	ff 75 0c             	push   0xc(%ebp)
c002a08f:	e8 88 f7 ff ff       	call   c002981c <list_next>
c002a094:	83 c4 10             	add    $0x10,%esp
c002a097:	89 45 0c             	mov    %eax,0xc(%ebp)
        list_splice (a0, list_prev (a1b0), a1b0);
c002a09a:	83 ec 0c             	sub    $0xc,%esp
c002a09d:	ff 75 0c             	push   0xc(%ebp)
c002a0a0:	e8 25 f8 ff ff       	call   c00298ca <list_prev>
c002a0a5:	83 c4 10             	add    $0x10,%esp
c002a0a8:	83 ec 04             	sub    $0x4,%esp
c002a0ab:	ff 75 0c             	push   0xc(%ebp)
c002a0ae:	50                   	push   %eax
c002a0af:	ff 75 08             	push   0x8(%ebp)
c002a0b2:	e8 8a f9 ff ff       	call   c0029a41 <list_splice>
c002a0b7:	83 c4 10             	add    $0x10,%esp
  while (a0 != a1b0 && a1b0 != b1)
c002a0ba:	8b 45 08             	mov    0x8(%ebp),%eax
c002a0bd:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a0c0:	74 08                	je     c002a0ca <inplace_merge+0x187>
c002a0c2:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a0c5:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a0c8:	75 91                	jne    c002a05b <inplace_merge+0x118>
      }
}
c002a0ca:	90                   	nop
c002a0cb:	c9                   	leave  
c002a0cc:	c3                   	ret    

c002a0cd <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c002a0cd:	55                   	push   %ebp
c002a0ce:	89 e5                	mov    %esp,%ebp
c002a0d0:	53                   	push   %ebx
c002a0d1:	83 ec 14             	sub    $0x14,%esp
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c002a0d4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a0d8:	75 21                	jne    c002a0fb <list_sort+0x2e>
c002a0da:	83 ec 0c             	sub    $0xc,%esp
c002a0dd:	68 58 0c 03 c0       	push   $0xc0030c58
c002a0e2:	68 65 0c 03 c0       	push   $0xc0030c65
c002a0e7:	68 f8 0e 03 c0       	push   $0xc0030ef8
c002a0ec:	68 99 01 00 00       	push   $0x199
c002a0f1:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a0f6:	e8 23 f4 ff ff       	call   c002951e <debug_panic>
  ASSERT (less != NULL);
c002a0fb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a0ff:	75 21                	jne    c002a122 <list_sort+0x55>
c002a101:	83 ec 0c             	sub    $0xc,%esp
c002a104:	68 7b 0d 03 c0       	push   $0xc0030d7b
c002a109:	68 65 0c 03 c0       	push   $0xc0030c65
c002a10e:	68 f8 0e 03 c0       	push   $0xc0030ef8
c002a113:	68 9a 01 00 00       	push   $0x19a
c002a118:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a11d:	e8 fc f3 ff ff       	call   c002951e <debug_panic>
    {
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
c002a122:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a129:	83 ec 0c             	sub    $0xc,%esp
c002a12c:	ff 75 08             	push   0x8(%ebp)
c002a12f:	e8 b6 f6 ff ff       	call   c00297ea <list_begin>
c002a134:	83 c4 10             	add    $0x10,%esp
c002a137:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a13a:	eb 7c                	jmp    c002a1b8 <list_sort+0xeb>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c002a13c:	ff 45 f4             	incl   -0xc(%ebp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c002a13f:	83 ec 0c             	sub    $0xc,%esp
c002a142:	ff 75 08             	push   0x8(%ebp)
c002a145:	e8 1c f7 ff ff       	call   c0029866 <list_end>
c002a14a:	83 c4 10             	add    $0x10,%esp
c002a14d:	ff 75 10             	push   0x10(%ebp)
c002a150:	ff 75 0c             	push   0xc(%ebp)
c002a153:	50                   	push   %eax
c002a154:	ff 75 f0             	push   -0x10(%ebp)
c002a157:	e8 fe fc ff ff       	call   c0029e5a <find_end_of_run>
c002a15c:	83 c4 10             	add    $0x10,%esp
c002a15f:	89 45 ec             	mov    %eax,-0x14(%ebp)
          if (a1b0 == list_end (list))
c002a162:	83 ec 0c             	sub    $0xc,%esp
c002a165:	ff 75 08             	push   0x8(%ebp)
c002a168:	e8 f9 f6 ff ff       	call   c0029866 <list_end>
c002a16d:	83 c4 10             	add    $0x10,%esp
c002a170:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c002a173:	74 5c                	je     c002a1d1 <list_sort+0x104>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c002a175:	83 ec 0c             	sub    $0xc,%esp
c002a178:	ff 75 08             	push   0x8(%ebp)
c002a17b:	e8 e6 f6 ff ff       	call   c0029866 <list_end>
c002a180:	83 c4 10             	add    $0x10,%esp
c002a183:	ff 75 10             	push   0x10(%ebp)
c002a186:	ff 75 0c             	push   0xc(%ebp)
c002a189:	50                   	push   %eax
c002a18a:	ff 75 ec             	push   -0x14(%ebp)
c002a18d:	e8 c8 fc ff ff       	call   c0029e5a <find_end_of_run>
c002a192:	83 c4 10             	add    $0x10,%esp
c002a195:	89 45 e8             	mov    %eax,-0x18(%ebp)

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
c002a198:	83 ec 0c             	sub    $0xc,%esp
c002a19b:	ff 75 10             	push   0x10(%ebp)
c002a19e:	ff 75 0c             	push   0xc(%ebp)
c002a1a1:	ff 75 e8             	push   -0x18(%ebp)
c002a1a4:	ff 75 ec             	push   -0x14(%ebp)
c002a1a7:	ff 75 f0             	push   -0x10(%ebp)
c002a1aa:	e8 94 fd ff ff       	call   c0029f43 <inplace_merge>
c002a1af:	83 c4 20             	add    $0x20,%esp
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a1b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002a1b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a1b8:	83 ec 0c             	sub    $0xc,%esp
c002a1bb:	ff 75 08             	push   0x8(%ebp)
c002a1be:	e8 a3 f6 ff ff       	call   c0029866 <list_end>
c002a1c3:	83 c4 10             	add    $0x10,%esp
c002a1c6:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002a1c9:	0f 85 6d ff ff ff    	jne    c002a13c <list_sort+0x6f>
c002a1cf:	eb 01                	jmp    c002a1d2 <list_sort+0x105>
            break;
c002a1d1:	90                   	nop
        }
    }
  while (output_run_cnt > 1);
c002a1d2:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002a1d6:	0f 87 46 ff ff ff    	ja     c002a122 <list_sort+0x55>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c002a1dc:	83 ec 0c             	sub    $0xc,%esp
c002a1df:	ff 75 08             	push   0x8(%ebp)
c002a1e2:	e8 7f f6 ff ff       	call   c0029866 <list_end>
c002a1e7:	83 c4 10             	add    $0x10,%esp
c002a1ea:	89 c3                	mov    %eax,%ebx
c002a1ec:	83 ec 0c             	sub    $0xc,%esp
c002a1ef:	ff 75 08             	push   0x8(%ebp)
c002a1f2:	e8 f3 f5 ff ff       	call   c00297ea <list_begin>
c002a1f7:	83 c4 10             	add    $0x10,%esp
c002a1fa:	ff 75 10             	push   0x10(%ebp)
c002a1fd:	ff 75 0c             	push   0xc(%ebp)
c002a200:	53                   	push   %ebx
c002a201:	50                   	push   %eax
c002a202:	e8 fe fb ff ff       	call   c0029e05 <is_sorted>
c002a207:	83 c4 10             	add    $0x10,%esp
c002a20a:	84 c0                	test   %al,%al
c002a20c:	75 21                	jne    c002a22f <list_sort+0x162>
c002a20e:	83 ec 0c             	sub    $0xc,%esp
c002a211:	68 f4 0d 03 c0       	push   $0xc0030df4
c002a216:	68 65 0c 03 c0       	push   $0xc0030c65
c002a21b:	68 f8 0e 03 c0       	push   $0xc0030ef8
c002a220:	68 b7 01 00 00       	push   $0x1b7
c002a225:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a22a:	e8 ef f2 ff ff       	call   c002951e <debug_panic>
}
c002a22f:	90                   	nop
c002a230:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a233:	c9                   	leave  
c002a234:	c3                   	ret    

c002a235 <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c002a235:	55                   	push   %ebp
c002a236:	89 e5                	mov    %esp,%ebp
c002a238:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (list != NULL);
c002a23b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a23f:	75 21                	jne    c002a262 <list_insert_ordered+0x2d>
c002a241:	83 ec 0c             	sub    $0xc,%esp
c002a244:	68 58 0c 03 c0       	push   $0xc0030c58
c002a249:	68 65 0c 03 c0       	push   $0xc0030c65
c002a24e:	68 04 0f 03 c0       	push   $0xc0030f04
c002a253:	68 c3 01 00 00       	push   $0x1c3
c002a258:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a25d:	e8 bc f2 ff ff       	call   c002951e <debug_panic>
  ASSERT (elem != NULL);
c002a262:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a266:	75 21                	jne    c002a289 <list_insert_ordered+0x54>
c002a268:	83 ec 0c             	sub    $0xc,%esp
c002a26b:	68 0d 0d 03 c0       	push   $0xc0030d0d
c002a270:	68 65 0c 03 c0       	push   $0xc0030c65
c002a275:	68 04 0f 03 c0       	push   $0xc0030f04
c002a27a:	68 c4 01 00 00       	push   $0x1c4
c002a27f:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a284:	e8 95 f2 ff ff       	call   c002951e <debug_panic>
  ASSERT (less != NULL);
c002a289:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a28d:	75 21                	jne    c002a2b0 <list_insert_ordered+0x7b>
c002a28f:	83 ec 0c             	sub    $0xc,%esp
c002a292:	68 7b 0d 03 c0       	push   $0xc0030d7b
c002a297:	68 65 0c 03 c0       	push   $0xc0030c65
c002a29c:	68 04 0f 03 c0       	push   $0xc0030f04
c002a2a1:	68 c5 01 00 00       	push   $0x1c5
c002a2a6:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a2ab:	e8 6e f2 ff ff       	call   c002951e <debug_panic>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a2b0:	83 ec 0c             	sub    $0xc,%esp
c002a2b3:	ff 75 08             	push   0x8(%ebp)
c002a2b6:	e8 2f f5 ff ff       	call   c00297ea <list_begin>
c002a2bb:	83 c4 10             	add    $0x10,%esp
c002a2be:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a2c1:	eb 29                	jmp    c002a2ec <list_insert_ordered+0xb7>
    if (less (elem, e, aux))
c002a2c3:	83 ec 04             	sub    $0x4,%esp
c002a2c6:	ff 75 14             	push   0x14(%ebp)
c002a2c9:	ff 75 f4             	push   -0xc(%ebp)
c002a2cc:	ff 75 0c             	push   0xc(%ebp)
c002a2cf:	8b 45 10             	mov    0x10(%ebp),%eax
c002a2d2:	ff d0                	call   *%eax
c002a2d4:	83 c4 10             	add    $0x10,%esp
c002a2d7:	84 c0                	test   %al,%al
c002a2d9:	75 26                	jne    c002a301 <list_insert_ordered+0xcc>
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a2db:	83 ec 0c             	sub    $0xc,%esp
c002a2de:	ff 75 f4             	push   -0xc(%ebp)
c002a2e1:	e8 36 f5 ff ff       	call   c002981c <list_next>
c002a2e6:	83 c4 10             	add    $0x10,%esp
c002a2e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a2ec:	83 ec 0c             	sub    $0xc,%esp
c002a2ef:	ff 75 08             	push   0x8(%ebp)
c002a2f2:	e8 6f f5 ff ff       	call   c0029866 <list_end>
c002a2f7:	83 c4 10             	add    $0x10,%esp
c002a2fa:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002a2fd:	75 c4                	jne    c002a2c3 <list_insert_ordered+0x8e>
c002a2ff:	eb 01                	jmp    c002a302 <list_insert_ordered+0xcd>
      break;
c002a301:	90                   	nop
  return list_insert (e, elem);
c002a302:	83 ec 08             	sub    $0x8,%esp
c002a305:	ff 75 0c             	push   0xc(%ebp)
c002a308:	ff 75 f4             	push   -0xc(%ebp)
c002a30b:	e8 9c f6 ff ff       	call   c00299ac <list_insert>
c002a310:	83 c4 10             	add    $0x10,%esp
}
c002a313:	c9                   	leave  
c002a314:	c3                   	ret    

c002a315 <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c002a315:	55                   	push   %ebp
c002a316:	89 e5                	mov    %esp,%ebp
c002a318:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c002a31b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a31f:	75 21                	jne    c002a342 <list_unique+0x2d>
c002a321:	83 ec 0c             	sub    $0xc,%esp
c002a324:	68 58 0c 03 c0       	push   $0xc0030c58
c002a329:	68 65 0c 03 c0       	push   $0xc0030c65
c002a32e:	68 18 0f 03 c0       	push   $0xc0030f18
c002a333:	68 d7 01 00 00       	push   $0x1d7
c002a338:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a33d:	e8 dc f1 ff ff       	call   c002951e <debug_panic>
  ASSERT (less != NULL);
c002a342:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a346:	75 21                	jne    c002a369 <list_unique+0x54>
c002a348:	83 ec 0c             	sub    $0xc,%esp
c002a34b:	68 7b 0d 03 c0       	push   $0xc0030d7b
c002a350:	68 65 0c 03 c0       	push   $0xc0030c65
c002a355:	68 18 0f 03 c0       	push   $0xc0030f18
c002a35a:	68 d8 01 00 00       	push   $0x1d8
c002a35f:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a364:	e8 b5 f1 ff ff       	call   c002951e <debug_panic>
  if (list_empty (list))
c002a369:	83 ec 0c             	sub    $0xc,%esp
c002a36c:	ff 75 08             	push   0x8(%ebp)
c002a36f:	e8 a8 f9 ff ff       	call   c0029d1c <list_empty>
c002a374:	83 c4 10             	add    $0x10,%esp
c002a377:	84 c0                	test   %al,%al
c002a379:	0f 85 a0 00 00 00    	jne    c002a41f <list_unique+0x10a>
    return;

  elem = list_begin (list);
c002a37f:	83 ec 0c             	sub    $0xc,%esp
c002a382:	ff 75 08             	push   0x8(%ebp)
c002a385:	e8 60 f4 ff ff       	call   c00297ea <list_begin>
c002a38a:	83 c4 10             	add    $0x10,%esp
c002a38d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002a390:	eb 63                	jmp    c002a3f5 <list_unique+0xe0>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c002a392:	83 ec 04             	sub    $0x4,%esp
c002a395:	ff 75 14             	push   0x14(%ebp)
c002a398:	ff 75 f0             	push   -0x10(%ebp)
c002a39b:	ff 75 f4             	push   -0xc(%ebp)
c002a39e:	8b 45 10             	mov    0x10(%ebp),%eax
c002a3a1:	ff d0                	call   *%eax
c002a3a3:	83 c4 10             	add    $0x10,%esp
c002a3a6:	83 f0 01             	xor    $0x1,%eax
c002a3a9:	84 c0                	test   %al,%al
c002a3ab:	74 42                	je     c002a3ef <list_unique+0xda>
c002a3ad:	83 ec 04             	sub    $0x4,%esp
c002a3b0:	ff 75 14             	push   0x14(%ebp)
c002a3b3:	ff 75 f4             	push   -0xc(%ebp)
c002a3b6:	ff 75 f0             	push   -0x10(%ebp)
c002a3b9:	8b 45 10             	mov    0x10(%ebp),%eax
c002a3bc:	ff d0                	call   *%eax
c002a3be:	83 c4 10             	add    $0x10,%esp
c002a3c1:	83 f0 01             	xor    $0x1,%eax
c002a3c4:	84 c0                	test   %al,%al
c002a3c6:	74 27                	je     c002a3ef <list_unique+0xda>
      {
        list_remove (next);
c002a3c8:	83 ec 0c             	sub    $0xc,%esp
c002a3cb:	ff 75 f0             	push   -0x10(%ebp)
c002a3ce:	e8 c8 f7 ff ff       	call   c0029b9b <list_remove>
c002a3d3:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002a3d6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a3da:	74 19                	je     c002a3f5 <list_unique+0xe0>
          list_push_back (duplicates, next);
c002a3dc:	83 ec 08             	sub    $0x8,%esp
c002a3df:	ff 75 f0             	push   -0x10(%ebp)
c002a3e2:	ff 75 0c             	push   0xc(%ebp)
c002a3e5:	e8 8b f7 ff ff       	call   c0029b75 <list_push_back>
c002a3ea:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002a3ed:	eb 06                	jmp    c002a3f5 <list_unique+0xe0>
      }
    else
      elem = next;
c002a3ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a3f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002a3f5:	83 ec 0c             	sub    $0xc,%esp
c002a3f8:	ff 75 f4             	push   -0xc(%ebp)
c002a3fb:	e8 1c f4 ff ff       	call   c002981c <list_next>
c002a400:	83 c4 10             	add    $0x10,%esp
c002a403:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a406:	83 ec 0c             	sub    $0xc,%esp
c002a409:	ff 75 08             	push   0x8(%ebp)
c002a40c:	e8 55 f4 ff ff       	call   c0029866 <list_end>
c002a411:	83 c4 10             	add    $0x10,%esp
c002a414:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002a417:	0f 85 75 ff ff ff    	jne    c002a392 <list_unique+0x7d>
c002a41d:	eb 01                	jmp    c002a420 <list_unique+0x10b>
    return;
c002a41f:	90                   	nop
}
c002a420:	c9                   	leave  
c002a421:	c3                   	ret    

c002a422 <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c002a422:	55                   	push   %ebp
c002a423:	89 e5                	mov    %esp,%ebp
c002a425:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *max = list_begin (list);
c002a428:	83 ec 0c             	sub    $0xc,%esp
c002a42b:	ff 75 08             	push   0x8(%ebp)
c002a42e:	e8 b7 f3 ff ff       	call   c00297ea <list_begin>
c002a433:	83 c4 10             	add    $0x10,%esp
c002a436:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (max != list_end (list)) 
c002a439:	83 ec 0c             	sub    $0xc,%esp
c002a43c:	ff 75 08             	push   0x8(%ebp)
c002a43f:	e8 22 f4 ff ff       	call   c0029866 <list_end>
c002a444:	83 c4 10             	add    $0x10,%esp
c002a447:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002a44a:	74 55                	je     c002a4a1 <list_max+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002a44c:	83 ec 0c             	sub    $0xc,%esp
c002a44f:	ff 75 f4             	push   -0xc(%ebp)
c002a452:	e8 c5 f3 ff ff       	call   c002981c <list_next>
c002a457:	83 c4 10             	add    $0x10,%esp
c002a45a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a45d:	eb 2f                	jmp    c002a48e <list_max+0x6c>
        if (less (max, e, aux))
c002a45f:	83 ec 04             	sub    $0x4,%esp
c002a462:	ff 75 10             	push   0x10(%ebp)
c002a465:	ff 75 f0             	push   -0x10(%ebp)
c002a468:	ff 75 f4             	push   -0xc(%ebp)
c002a46b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a46e:	ff d0                	call   *%eax
c002a470:	83 c4 10             	add    $0x10,%esp
c002a473:	84 c0                	test   %al,%al
c002a475:	74 06                	je     c002a47d <list_max+0x5b>
          max = e; 
c002a477:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a47a:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002a47d:	83 ec 0c             	sub    $0xc,%esp
c002a480:	ff 75 f0             	push   -0x10(%ebp)
c002a483:	e8 94 f3 ff ff       	call   c002981c <list_next>
c002a488:	83 c4 10             	add    $0x10,%esp
c002a48b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a48e:	83 ec 0c             	sub    $0xc,%esp
c002a491:	ff 75 08             	push   0x8(%ebp)
c002a494:	e8 cd f3 ff ff       	call   c0029866 <list_end>
c002a499:	83 c4 10             	add    $0x10,%esp
c002a49c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002a49f:	75 be                	jne    c002a45f <list_max+0x3d>
    }
  return max;
c002a4a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a4a4:	c9                   	leave  
c002a4a5:	c3                   	ret    

c002a4a6 <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c002a4a6:	55                   	push   %ebp
c002a4a7:	89 e5                	mov    %esp,%ebp
c002a4a9:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *min = list_begin (list);
c002a4ac:	83 ec 0c             	sub    $0xc,%esp
c002a4af:	ff 75 08             	push   0x8(%ebp)
c002a4b2:	e8 33 f3 ff ff       	call   c00297ea <list_begin>
c002a4b7:	83 c4 10             	add    $0x10,%esp
c002a4ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (min != list_end (list)) 
c002a4bd:	83 ec 0c             	sub    $0xc,%esp
c002a4c0:	ff 75 08             	push   0x8(%ebp)
c002a4c3:	e8 9e f3 ff ff       	call   c0029866 <list_end>
c002a4c8:	83 c4 10             	add    $0x10,%esp
c002a4cb:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002a4ce:	74 55                	je     c002a525 <list_min+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002a4d0:	83 ec 0c             	sub    $0xc,%esp
c002a4d3:	ff 75 f4             	push   -0xc(%ebp)
c002a4d6:	e8 41 f3 ff ff       	call   c002981c <list_next>
c002a4db:	83 c4 10             	add    $0x10,%esp
c002a4de:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a4e1:	eb 2f                	jmp    c002a512 <list_min+0x6c>
        if (less (e, min, aux))
c002a4e3:	83 ec 04             	sub    $0x4,%esp
c002a4e6:	ff 75 10             	push   0x10(%ebp)
c002a4e9:	ff 75 f4             	push   -0xc(%ebp)
c002a4ec:	ff 75 f0             	push   -0x10(%ebp)
c002a4ef:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a4f2:	ff d0                	call   *%eax
c002a4f4:	83 c4 10             	add    $0x10,%esp
c002a4f7:	84 c0                	test   %al,%al
c002a4f9:	74 06                	je     c002a501 <list_min+0x5b>
          min = e; 
c002a4fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a4fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002a501:	83 ec 0c             	sub    $0xc,%esp
c002a504:	ff 75 f0             	push   -0x10(%ebp)
c002a507:	e8 10 f3 ff ff       	call   c002981c <list_next>
c002a50c:	83 c4 10             	add    $0x10,%esp
c002a50f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a512:	83 ec 0c             	sub    $0xc,%esp
c002a515:	ff 75 08             	push   0x8(%ebp)
c002a518:	e8 49 f3 ff ff       	call   c0029866 <list_end>
c002a51d:	83 c4 10             	add    $0x10,%esp
c002a520:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002a523:	75 be                	jne    c002a4e3 <list_min+0x3d>
    }
  return min;
c002a525:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a528:	c9                   	leave  
c002a529:	c3                   	ret    

c002a52a <elem_idx>:

/* Returns the index of the element that contains the bit
   numbered BIT_IDX. */
static inline size_t
elem_idx (size_t bit_idx) 
{
c002a52a:	55                   	push   %ebp
c002a52b:	89 e5                	mov    %esp,%ebp
  return bit_idx / ELEM_BITS;
c002a52d:	8b 45 08             	mov    0x8(%ebp),%eax
c002a530:	c1 e8 05             	shr    $0x5,%eax
}
c002a533:	5d                   	pop    %ebp
c002a534:	c3                   	ret    

c002a535 <bit_mask>:

/* Returns an elem_type where only the bit corresponding to
   BIT_IDX is turned on. */
static inline elem_type
bit_mask (size_t bit_idx) 
{
c002a535:	55                   	push   %ebp
c002a536:	89 e5                	mov    %esp,%ebp
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a538:	8b 45 08             	mov    0x8(%ebp),%eax
c002a53b:	83 e0 1f             	and    $0x1f,%eax
c002a53e:	ba 01 00 00 00       	mov    $0x1,%edx
c002a543:	88 c1                	mov    %al,%cl
c002a545:	d3 e2                	shl    %cl,%edx
c002a547:	89 d0                	mov    %edx,%eax
}
c002a549:	5d                   	pop    %ebp
c002a54a:	c3                   	ret    

c002a54b <elem_cnt>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
c002a54b:	55                   	push   %ebp
c002a54c:	89 e5                	mov    %esp,%ebp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a54e:	8b 45 08             	mov    0x8(%ebp),%eax
c002a551:	83 c0 1f             	add    $0x1f,%eax
c002a554:	c1 e8 05             	shr    $0x5,%eax
}
c002a557:	5d                   	pop    %ebp
c002a558:	c3                   	ret    

c002a559 <byte_cnt>:

/* Returns the number of bytes required for BIT_CNT bits. */
static inline size_t
byte_cnt (size_t bit_cnt)
{
c002a559:	55                   	push   %ebp
c002a55a:	89 e5                	mov    %esp,%ebp
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a55c:	ff 75 08             	push   0x8(%ebp)
c002a55f:	e8 e7 ff ff ff       	call   c002a54b <elem_cnt>
c002a564:	83 c4 04             	add    $0x4,%esp
c002a567:	c1 e0 02             	shl    $0x2,%eax
}
c002a56a:	c9                   	leave  
c002a56b:	c3                   	ret    

c002a56c <bitmap_create>:
   BIT_CNT (or more) bits.  Returns a null pointer if memory allocation fails.
   The caller is responsible for freeing the bitmap, with bitmap_destroy(),
   when it is no longer needed. */
struct bitmap *
bitmap_create (size_t bit_cnt) 
{
c002a56c:	55                   	push   %ebp
c002a56d:	89 e5                	mov    %esp,%ebp
c002a56f:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = malloc (sizeof *b);
c002a572:	83 ec 0c             	sub    $0xc,%esp
c002a575:	6a 08                	push   $0x8
c002a577:	e8 e7 8e ff ff       	call   c0023463 <malloc>
c002a57c:	83 c4 10             	add    $0x10,%esp
c002a57f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (b != NULL)
c002a582:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002a586:	74 5d                	je     c002a5e5 <bitmap_create+0x79>
    {
      b->bit_cnt = bit_cnt;
c002a588:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a58b:	8b 55 08             	mov    0x8(%ebp),%edx
c002a58e:	89 10                	mov    %edx,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002a590:	83 ec 0c             	sub    $0xc,%esp
c002a593:	ff 75 08             	push   0x8(%ebp)
c002a596:	e8 be ff ff ff       	call   c002a559 <byte_cnt>
c002a59b:	83 c4 10             	add    $0x10,%esp
c002a59e:	83 ec 0c             	sub    $0xc,%esp
c002a5a1:	50                   	push   %eax
c002a5a2:	e8 bc 8e ff ff       	call   c0023463 <malloc>
c002a5a7:	83 c4 10             	add    $0x10,%esp
c002a5aa:	89 c2                	mov    %eax,%edx
c002a5ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a5af:	89 50 04             	mov    %edx,0x4(%eax)
      if (b->bits != NULL || bit_cnt == 0)
c002a5b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a5b5:	8b 40 04             	mov    0x4(%eax),%eax
c002a5b8:	85 c0                	test   %eax,%eax
c002a5ba:	75 06                	jne    c002a5c2 <bitmap_create+0x56>
c002a5bc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a5c0:	75 15                	jne    c002a5d7 <bitmap_create+0x6b>
        {
          bitmap_set_all (b, false);
c002a5c2:	83 ec 08             	sub    $0x8,%esp
c002a5c5:	6a 00                	push   $0x0
c002a5c7:	ff 75 f4             	push   -0xc(%ebp)
c002a5ca:	e8 92 02 00 00       	call   c002a861 <bitmap_set_all>
c002a5cf:	83 c4 10             	add    $0x10,%esp
          return b;
c002a5d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a5d5:	eb 13                	jmp    c002a5ea <bitmap_create+0x7e>
        }
      free (b);
c002a5d7:	83 ec 0c             	sub    $0xc,%esp
c002a5da:	ff 75 f4             	push   -0xc(%ebp)
c002a5dd:	e8 7d 91 ff ff       	call   c002375f <free>
c002a5e2:	83 c4 10             	add    $0x10,%esp
    }
  return NULL;
c002a5e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002a5ea:	c9                   	leave  
c002a5eb:	c3                   	ret    

c002a5ec <bitmap_create_in_buf>:
/* Creates and returns a bitmap with BIT_CNT bits in the
   BLOCK_SIZE bytes of storage preallocated at BLOCK.
   BLOCK_SIZE must be at least bitmap_needed_bytes(BIT_CNT). */
struct bitmap *
bitmap_create_in_buf (size_t bit_cnt, void *block, size_t block_size UNUSED)
{
c002a5ec:	55                   	push   %ebp
c002a5ed:	89 e5                	mov    %esp,%ebp
c002a5ef:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = block;
c002a5f2:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a5f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a5f8:	83 ec 0c             	sub    $0xc,%esp
c002a5fb:	ff 75 08             	push   0x8(%ebp)
c002a5fe:	e8 4f 00 00 00       	call   c002a652 <bitmap_buf_size>
c002a603:	83 c4 10             	add    $0x10,%esp
c002a606:	39 45 10             	cmp    %eax,0x10(%ebp)
c002a609:	73 1e                	jae    c002a629 <bitmap_create_in_buf+0x3d>
c002a60b:	83 ec 0c             	sub    $0xc,%esp
c002a60e:	68 24 0f 03 c0       	push   $0xc0030f24
c002a613:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a618:	68 c8 0f 03 c0       	push   $0xc0030fc8
c002a61d:	6a 68                	push   $0x68
c002a61f:	68 63 0f 03 c0       	push   $0xc0030f63
c002a624:	e8 f5 ee ff ff       	call   c002951e <debug_panic>

  b->bit_cnt = bit_cnt;
c002a629:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a62c:	8b 55 08             	mov    0x8(%ebp),%edx
c002a62f:	89 10                	mov    %edx,(%eax)
  b->bits = (elem_type *) (b + 1);
c002a631:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a634:	8d 50 08             	lea    0x8(%eax),%edx
c002a637:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a63a:	89 50 04             	mov    %edx,0x4(%eax)
  bitmap_set_all (b, false);
c002a63d:	83 ec 08             	sub    $0x8,%esp
c002a640:	6a 00                	push   $0x0
c002a642:	ff 75 f4             	push   -0xc(%ebp)
c002a645:	e8 17 02 00 00       	call   c002a861 <bitmap_set_all>
c002a64a:	83 c4 10             	add    $0x10,%esp
  return b;
c002a64d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a650:	c9                   	leave  
c002a651:	c3                   	ret    

c002a652 <bitmap_buf_size>:

/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
c002a652:	55                   	push   %ebp
c002a653:	89 e5                	mov    %esp,%ebp
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c002a655:	ff 75 08             	push   0x8(%ebp)
c002a658:	e8 fc fe ff ff       	call   c002a559 <byte_cnt>
c002a65d:	83 c4 04             	add    $0x4,%esp
c002a660:	83 c0 08             	add    $0x8,%eax
}
c002a663:	c9                   	leave  
c002a664:	c3                   	ret    

c002a665 <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c002a665:	55                   	push   %ebp
c002a666:	89 e5                	mov    %esp,%ebp
c002a668:	83 ec 08             	sub    $0x8,%esp
  if (b != NULL) 
c002a66b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a66f:	74 20                	je     c002a691 <bitmap_destroy+0x2c>
    {
      free (b->bits);
c002a671:	8b 45 08             	mov    0x8(%ebp),%eax
c002a674:	8b 40 04             	mov    0x4(%eax),%eax
c002a677:	83 ec 0c             	sub    $0xc,%esp
c002a67a:	50                   	push   %eax
c002a67b:	e8 df 90 ff ff       	call   c002375f <free>
c002a680:	83 c4 10             	add    $0x10,%esp
      free (b);
c002a683:	83 ec 0c             	sub    $0xc,%esp
c002a686:	ff 75 08             	push   0x8(%ebp)
c002a689:	e8 d1 90 ff ff       	call   c002375f <free>
c002a68e:	83 c4 10             	add    $0x10,%esp
    }
}
c002a691:	90                   	nop
c002a692:	c9                   	leave  
c002a693:	c3                   	ret    

c002a694 <bitmap_size>:
/* Bitmap size. */

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
c002a694:	55                   	push   %ebp
c002a695:	89 e5                	mov    %esp,%ebp
  return b->bit_cnt;
c002a697:	8b 45 08             	mov    0x8(%ebp),%eax
c002a69a:	8b 00                	mov    (%eax),%eax
}
c002a69c:	5d                   	pop    %ebp
c002a69d:	c3                   	ret    

c002a69e <bitmap_set>:
/* Setting and testing single bits. */

/* Atomically sets the bit numbered IDX in B to VALUE. */
void
bitmap_set (struct bitmap *b, size_t idx, bool value) 
{
c002a69e:	55                   	push   %ebp
c002a69f:	89 e5                	mov    %esp,%ebp
c002a6a1:	83 ec 18             	sub    $0x18,%esp
c002a6a4:	8b 45 10             	mov    0x10(%ebp),%eax
c002a6a7:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002a6aa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a6ae:	75 21                	jne    c002a6d1 <bitmap_set+0x33>
c002a6b0:	83 ec 0c             	sub    $0xc,%esp
c002a6b3:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002a6b8:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a6bd:	68 e0 0f 03 c0       	push   $0xc0030fe0
c002a6c2:	68 93 00 00 00       	push   $0x93
c002a6c7:	68 63 0f 03 c0       	push   $0xc0030f63
c002a6cc:	e8 4d ee ff ff       	call   c002951e <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a6d1:	8b 45 08             	mov    0x8(%ebp),%eax
c002a6d4:	8b 00                	mov    (%eax),%eax
c002a6d6:	39 45 0c             	cmp    %eax,0xc(%ebp)
c002a6d9:	72 21                	jb     c002a6fc <bitmap_set+0x5e>
c002a6db:	83 ec 0c             	sub    $0xc,%esp
c002a6de:	68 87 0f 03 c0       	push   $0xc0030f87
c002a6e3:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a6e8:	68 e0 0f 03 c0       	push   $0xc0030fe0
c002a6ed:	68 94 00 00 00       	push   $0x94
c002a6f2:	68 63 0f 03 c0       	push   $0xc0030f63
c002a6f7:	e8 22 ee ff ff       	call   c002951e <debug_panic>
  if (value)
c002a6fc:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c002a700:	74 13                	je     c002a715 <bitmap_set+0x77>
    bitmap_mark (b, idx);
c002a702:	83 ec 08             	sub    $0x8,%esp
c002a705:	ff 75 0c             	push   0xc(%ebp)
c002a708:	ff 75 08             	push   0x8(%ebp)
c002a70b:	e8 19 00 00 00       	call   c002a729 <bitmap_mark>
c002a710:	83 c4 10             	add    $0x10,%esp
  else
    bitmap_reset (b, idx);
}
c002a713:	eb 11                	jmp    c002a726 <bitmap_set+0x88>
    bitmap_reset (b, idx);
c002a715:	83 ec 08             	sub    $0x8,%esp
c002a718:	ff 75 0c             	push   0xc(%ebp)
c002a71b:	ff 75 08             	push   0x8(%ebp)
c002a71e:	e8 3e 00 00 00       	call   c002a761 <bitmap_reset>
c002a723:	83 c4 10             	add    $0x10,%esp
}
c002a726:	90                   	nop
c002a727:	c9                   	leave  
c002a728:	c3                   	ret    

c002a729 <bitmap_mark>:

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c002a729:	55                   	push   %ebp
c002a72a:	89 e5                	mov    %esp,%ebp
c002a72c:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a72f:	ff 75 0c             	push   0xc(%ebp)
c002a732:	e8 f3 fd ff ff       	call   c002a52a <elem_idx>
c002a737:	83 c4 04             	add    $0x4,%esp
c002a73a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002a73d:	ff 75 0c             	push   0xc(%ebp)
c002a740:	e8 f0 fd ff ff       	call   c002a535 <bit_mask>
c002a745:	83 c4 04             	add    $0x4,%esp
c002a748:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a74b:	8b 45 08             	mov    0x8(%ebp),%eax
c002a74e:	8b 40 04             	mov    0x4(%eax),%eax
c002a751:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a754:	c1 e2 02             	shl    $0x2,%edx
c002a757:	01 c2                	add    %eax,%edx
c002a759:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002a75c:	09 02                	or     %eax,(%edx)
}
c002a75e:	90                   	nop
c002a75f:	c9                   	leave  
c002a760:	c3                   	ret    

c002a761 <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c002a761:	55                   	push   %ebp
c002a762:	89 e5                	mov    %esp,%ebp
c002a764:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a767:	ff 75 0c             	push   0xc(%ebp)
c002a76a:	e8 bb fd ff ff       	call   c002a52a <elem_idx>
c002a76f:	83 c4 04             	add    $0x4,%esp
c002a772:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002a775:	ff 75 0c             	push   0xc(%ebp)
c002a778:	e8 b8 fd ff ff       	call   c002a535 <bit_mask>
c002a77d:	83 c4 04             	add    $0x4,%esp
c002a780:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002a783:	8b 45 08             	mov    0x8(%ebp),%eax
c002a786:	8b 40 04             	mov    0x4(%eax),%eax
c002a789:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a78c:	c1 e2 02             	shl    $0x2,%edx
c002a78f:	01 d0                	add    %edx,%eax
c002a791:	8b 55 f8             	mov    -0x8(%ebp),%edx
c002a794:	f7 d2                	not    %edx
c002a796:	21 10                	and    %edx,(%eax)
}
c002a798:	90                   	nop
c002a799:	c9                   	leave  
c002a79a:	c3                   	ret    

c002a79b <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c002a79b:	55                   	push   %ebp
c002a79c:	89 e5                	mov    %esp,%ebp
c002a79e:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a7a1:	ff 75 0c             	push   0xc(%ebp)
c002a7a4:	e8 81 fd ff ff       	call   c002a52a <elem_idx>
c002a7a9:	83 c4 04             	add    $0x4,%esp
c002a7ac:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002a7af:	ff 75 0c             	push   0xc(%ebp)
c002a7b2:	e8 7e fd ff ff       	call   c002a535 <bit_mask>
c002a7b7:	83 c4 04             	add    $0x4,%esp
c002a7ba:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a7bd:	8b 45 08             	mov    0x8(%ebp),%eax
c002a7c0:	8b 40 04             	mov    0x4(%eax),%eax
c002a7c3:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a7c6:	c1 e2 02             	shl    $0x2,%edx
c002a7c9:	01 c2                	add    %eax,%edx
c002a7cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002a7ce:	31 02                	xor    %eax,(%edx)
}
c002a7d0:	90                   	nop
c002a7d1:	c9                   	leave  
c002a7d2:	c3                   	ret    

c002a7d3 <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c002a7d3:	55                   	push   %ebp
c002a7d4:	89 e5                	mov    %esp,%ebp
c002a7d6:	53                   	push   %ebx
c002a7d7:	83 ec 04             	sub    $0x4,%esp
  ASSERT (b != NULL);
c002a7da:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a7de:	75 21                	jne    c002a801 <bitmap_test+0x2e>
c002a7e0:	83 ec 0c             	sub    $0xc,%esp
c002a7e3:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002a7e8:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a7ed:	68 ec 0f 03 c0       	push   $0xc0030fec
c002a7f2:	68 c8 00 00 00       	push   $0xc8
c002a7f7:	68 63 0f 03 c0       	push   $0xc0030f63
c002a7fc:	e8 1d ed ff ff       	call   c002951e <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a801:	8b 45 08             	mov    0x8(%ebp),%eax
c002a804:	8b 00                	mov    (%eax),%eax
c002a806:	39 45 0c             	cmp    %eax,0xc(%ebp)
c002a809:	72 21                	jb     c002a82c <bitmap_test+0x59>
c002a80b:	83 ec 0c             	sub    $0xc,%esp
c002a80e:	68 87 0f 03 c0       	push   $0xc0030f87
c002a813:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a818:	68 ec 0f 03 c0       	push   $0xc0030fec
c002a81d:	68 c9 00 00 00       	push   $0xc9
c002a822:	68 63 0f 03 c0       	push   $0xc0030f63
c002a827:	e8 f2 ec ff ff       	call   c002951e <debug_panic>
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002a82c:	8b 45 08             	mov    0x8(%ebp),%eax
c002a82f:	8b 58 04             	mov    0x4(%eax),%ebx
c002a832:	83 ec 0c             	sub    $0xc,%esp
c002a835:	ff 75 0c             	push   0xc(%ebp)
c002a838:	e8 ed fc ff ff       	call   c002a52a <elem_idx>
c002a83d:	83 c4 10             	add    $0x10,%esp
c002a840:	c1 e0 02             	shl    $0x2,%eax
c002a843:	01 d8                	add    %ebx,%eax
c002a845:	8b 18                	mov    (%eax),%ebx
c002a847:	83 ec 0c             	sub    $0xc,%esp
c002a84a:	ff 75 0c             	push   0xc(%ebp)
c002a84d:	e8 e3 fc ff ff       	call   c002a535 <bit_mask>
c002a852:	83 c4 10             	add    $0x10,%esp
c002a855:	21 d8                	and    %ebx,%eax
c002a857:	85 c0                	test   %eax,%eax
c002a859:	0f 95 c0             	setne  %al
}
c002a85c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a85f:	c9                   	leave  
c002a860:	c3                   	ret    

c002a861 <bitmap_set_all>:
/* Setting and testing multiple bits. */

/* Sets all bits in B to VALUE. */
void
bitmap_set_all (struct bitmap *b, bool value) 
{
c002a861:	55                   	push   %ebp
c002a862:	89 e5                	mov    %esp,%ebp
c002a864:	53                   	push   %ebx
c002a865:	83 ec 14             	sub    $0x14,%esp
c002a868:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a86b:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002a86e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a872:	75 21                	jne    c002a895 <bitmap_set_all+0x34>
c002a874:	83 ec 0c             	sub    $0xc,%esp
c002a877:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002a87c:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a881:	68 f8 0f 03 c0       	push   $0xc0030ff8
c002a886:	68 d3 00 00 00       	push   $0xd3
c002a88b:	68 63 0f 03 c0       	push   $0xc0030f63
c002a890:	e8 89 ec ff ff       	call   c002951e <debug_panic>

  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002a895:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c002a899:	83 ec 0c             	sub    $0xc,%esp
c002a89c:	ff 75 08             	push   0x8(%ebp)
c002a89f:	e8 f0 fd ff ff       	call   c002a694 <bitmap_size>
c002a8a4:	83 c4 10             	add    $0x10,%esp
c002a8a7:	53                   	push   %ebx
c002a8a8:	50                   	push   %eax
c002a8a9:	6a 00                	push   $0x0
c002a8ab:	ff 75 08             	push   0x8(%ebp)
c002a8ae:	e8 09 00 00 00       	call   c002a8bc <bitmap_set_multiple>
c002a8b3:	83 c4 10             	add    $0x10,%esp
}
c002a8b6:	90                   	nop
c002a8b7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a8ba:	c9                   	leave  
c002a8bb:	c3                   	ret    

c002a8bc <bitmap_set_multiple>:

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a8bc:	55                   	push   %ebp
c002a8bd:	89 e5                	mov    %esp,%ebp
c002a8bf:	83 ec 28             	sub    $0x28,%esp
c002a8c2:	8b 45 14             	mov    0x14(%ebp),%eax
c002a8c5:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002a8c8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a8cc:	75 21                	jne    c002a8ef <bitmap_set_multiple+0x33>
c002a8ce:	83 ec 0c             	sub    $0xc,%esp
c002a8d1:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002a8d6:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a8db:	68 08 10 03 c0       	push   $0xc0031008
c002a8e0:	68 de 00 00 00       	push   $0xde
c002a8e5:	68 63 0f 03 c0       	push   $0xc0030f63
c002a8ea:	e8 2f ec ff ff       	call   c002951e <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a8ef:	8b 45 08             	mov    0x8(%ebp),%eax
c002a8f2:	8b 00                	mov    (%eax),%eax
c002a8f4:	39 45 0c             	cmp    %eax,0xc(%ebp)
c002a8f7:	76 21                	jbe    c002a91a <bitmap_set_multiple+0x5e>
c002a8f9:	83 ec 0c             	sub    $0xc,%esp
c002a8fc:	68 98 0f 03 c0       	push   $0xc0030f98
c002a901:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a906:	68 08 10 03 c0       	push   $0xc0031008
c002a90b:	68 df 00 00 00       	push   $0xdf
c002a910:	68 63 0f 03 c0       	push   $0xc0030f63
c002a915:	e8 04 ec ff ff       	call   c002951e <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a91a:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a91d:	8b 45 10             	mov    0x10(%ebp),%eax
c002a920:	01 c2                	add    %eax,%edx
c002a922:	8b 45 08             	mov    0x8(%ebp),%eax
c002a925:	8b 00                	mov    (%eax),%eax
c002a927:	39 c2                	cmp    %eax,%edx
c002a929:	76 21                	jbe    c002a94c <bitmap_set_multiple+0x90>
c002a92b:	83 ec 0c             	sub    $0xc,%esp
c002a92e:	68 ac 0f 03 c0       	push   $0xc0030fac
c002a933:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a938:	68 08 10 03 c0       	push   $0xc0031008
c002a93d:	68 e0 00 00 00       	push   $0xe0
c002a942:	68 63 0f 03 c0       	push   $0xc0030f63
c002a947:	e8 d2 eb ff ff       	call   c002951e <debug_panic>

  for (i = 0; i < cnt; i++)
c002a94c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002a953:	eb 1f                	jmp    c002a974 <bitmap_set_multiple+0xb8>
    bitmap_set (b, start + i, value);
c002a955:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002a959:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002a95c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002a95f:	01 ca                	add    %ecx,%edx
c002a961:	83 ec 04             	sub    $0x4,%esp
c002a964:	50                   	push   %eax
c002a965:	52                   	push   %edx
c002a966:	ff 75 08             	push   0x8(%ebp)
c002a969:	e8 30 fd ff ff       	call   c002a69e <bitmap_set>
c002a96e:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < cnt; i++)
c002a971:	ff 45 f4             	incl   -0xc(%ebp)
c002a974:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a977:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a97a:	72 d9                	jb     c002a955 <bitmap_set_multiple+0x99>
}
c002a97c:	90                   	nop
c002a97d:	90                   	nop
c002a97e:	c9                   	leave  
c002a97f:	c3                   	ret    

c002a980 <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a980:	55                   	push   %ebp
c002a981:	89 e5                	mov    %esp,%ebp
c002a983:	83 ec 28             	sub    $0x28,%esp
c002a986:	8b 45 14             	mov    0x14(%ebp),%eax
c002a989:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002a98c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a990:	75 21                	jne    c002a9b3 <bitmap_count+0x33>
c002a992:	83 ec 0c             	sub    $0xc,%esp
c002a995:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002a99a:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a99f:	68 1c 10 03 c0       	push   $0xc003101c
c002a9a4:	68 ed 00 00 00       	push   $0xed
c002a9a9:	68 63 0f 03 c0       	push   $0xc0030f63
c002a9ae:	e8 6b eb ff ff       	call   c002951e <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a9b3:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9b6:	8b 00                	mov    (%eax),%eax
c002a9b8:	39 45 0c             	cmp    %eax,0xc(%ebp)
c002a9bb:	76 21                	jbe    c002a9de <bitmap_count+0x5e>
c002a9bd:	83 ec 0c             	sub    $0xc,%esp
c002a9c0:	68 98 0f 03 c0       	push   $0xc0030f98
c002a9c5:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a9ca:	68 1c 10 03 c0       	push   $0xc003101c
c002a9cf:	68 ee 00 00 00       	push   $0xee
c002a9d4:	68 63 0f 03 c0       	push   $0xc0030f63
c002a9d9:	e8 40 eb ff ff       	call   c002951e <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a9de:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a9e1:	8b 45 10             	mov    0x10(%ebp),%eax
c002a9e4:	01 c2                	add    %eax,%edx
c002a9e6:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9e9:	8b 00                	mov    (%eax),%eax
c002a9eb:	39 c2                	cmp    %eax,%edx
c002a9ed:	76 21                	jbe    c002aa10 <bitmap_count+0x90>
c002a9ef:	83 ec 0c             	sub    $0xc,%esp
c002a9f2:	68 ac 0f 03 c0       	push   $0xc0030fac
c002a9f7:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a9fc:	68 1c 10 03 c0       	push   $0xc003101c
c002aa01:	68 ef 00 00 00       	push   $0xef
c002aa06:	68 63 0f 03 c0       	push   $0xc0030f63
c002aa0b:	e8 0e eb ff ff       	call   c002951e <debug_panic>

  value_cnt = 0;
c002aa10:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002aa17:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002aa1e:	eb 22                	jmp    c002aa42 <bitmap_count+0xc2>
    if (bitmap_test (b, start + i) == value)
c002aa20:	8b 55 0c             	mov    0xc(%ebp),%edx
c002aa23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aa26:	01 d0                	add    %edx,%eax
c002aa28:	83 ec 08             	sub    $0x8,%esp
c002aa2b:	50                   	push   %eax
c002aa2c:	ff 75 08             	push   0x8(%ebp)
c002aa2f:	e8 9f fd ff ff       	call   c002a7d3 <bitmap_test>
c002aa34:	83 c4 10             	add    $0x10,%esp
c002aa37:	38 45 e4             	cmp    %al,-0x1c(%ebp)
c002aa3a:	75 03                	jne    c002aa3f <bitmap_count+0xbf>
      value_cnt++;
c002aa3c:	ff 45 f0             	incl   -0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002aa3f:	ff 45 f4             	incl   -0xc(%ebp)
c002aa42:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aa45:	3b 45 10             	cmp    0x10(%ebp),%eax
c002aa48:	72 d6                	jb     c002aa20 <bitmap_count+0xa0>
  return value_cnt;
c002aa4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002aa4d:	c9                   	leave  
c002aa4e:	c3                   	ret    

c002aa4f <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002aa4f:	55                   	push   %ebp
c002aa50:	89 e5                	mov    %esp,%ebp
c002aa52:	83 ec 28             	sub    $0x28,%esp
c002aa55:	8b 45 14             	mov    0x14(%ebp),%eax
c002aa58:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002aa5b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002aa5f:	75 21                	jne    c002aa82 <bitmap_contains+0x33>
c002aa61:	83 ec 0c             	sub    $0xc,%esp
c002aa64:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002aa69:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002aa6e:	68 2c 10 03 c0       	push   $0xc003102c
c002aa73:	68 ff 00 00 00       	push   $0xff
c002aa78:	68 63 0f 03 c0       	push   $0xc0030f63
c002aa7d:	e8 9c ea ff ff       	call   c002951e <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002aa82:	8b 45 08             	mov    0x8(%ebp),%eax
c002aa85:	8b 00                	mov    (%eax),%eax
c002aa87:	39 45 0c             	cmp    %eax,0xc(%ebp)
c002aa8a:	76 21                	jbe    c002aaad <bitmap_contains+0x5e>
c002aa8c:	83 ec 0c             	sub    $0xc,%esp
c002aa8f:	68 98 0f 03 c0       	push   $0xc0030f98
c002aa94:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002aa99:	68 2c 10 03 c0       	push   $0xc003102c
c002aa9e:	68 00 01 00 00       	push   $0x100
c002aaa3:	68 63 0f 03 c0       	push   $0xc0030f63
c002aaa8:	e8 71 ea ff ff       	call   c002951e <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002aaad:	8b 55 0c             	mov    0xc(%ebp),%edx
c002aab0:	8b 45 10             	mov    0x10(%ebp),%eax
c002aab3:	01 c2                	add    %eax,%edx
c002aab5:	8b 45 08             	mov    0x8(%ebp),%eax
c002aab8:	8b 00                	mov    (%eax),%eax
c002aaba:	39 c2                	cmp    %eax,%edx
c002aabc:	76 21                	jbe    c002aadf <bitmap_contains+0x90>
c002aabe:	83 ec 0c             	sub    $0xc,%esp
c002aac1:	68 ac 0f 03 c0       	push   $0xc0030fac
c002aac6:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002aacb:	68 2c 10 03 c0       	push   $0xc003102c
c002aad0:	68 01 01 00 00       	push   $0x101
c002aad5:	68 63 0f 03 c0       	push   $0xc0030f63
c002aada:	e8 3f ea ff ff       	call   c002951e <debug_panic>

  for (i = 0; i < cnt; i++)
c002aadf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002aae6:	eb 23                	jmp    c002ab0b <bitmap_contains+0xbc>
    if (bitmap_test (b, start + i) == value)
c002aae8:	8b 55 0c             	mov    0xc(%ebp),%edx
c002aaeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aaee:	01 d0                	add    %edx,%eax
c002aaf0:	83 ec 08             	sub    $0x8,%esp
c002aaf3:	50                   	push   %eax
c002aaf4:	ff 75 08             	push   0x8(%ebp)
c002aaf7:	e8 d7 fc ff ff       	call   c002a7d3 <bitmap_test>
c002aafc:	83 c4 10             	add    $0x10,%esp
c002aaff:	38 45 e4             	cmp    %al,-0x1c(%ebp)
c002ab02:	75 04                	jne    c002ab08 <bitmap_contains+0xb9>
      return true;
c002ab04:	b0 01                	mov    $0x1,%al
c002ab06:	eb 0d                	jmp    c002ab15 <bitmap_contains+0xc6>
  for (i = 0; i < cnt; i++)
c002ab08:	ff 45 f4             	incl   -0xc(%ebp)
c002ab0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ab0e:	3b 45 10             	cmp    0x10(%ebp),%eax
c002ab11:	72 d5                	jb     c002aae8 <bitmap_contains+0x99>
  return false;
c002ab13:	b0 00                	mov    $0x0,%al
}
c002ab15:	c9                   	leave  
c002ab16:	c3                   	ret    

c002ab17 <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002ab17:	55                   	push   %ebp
c002ab18:	89 e5                	mov    %esp,%ebp
c002ab1a:	83 ec 08             	sub    $0x8,%esp
  return bitmap_contains (b, start, cnt, true);
c002ab1d:	6a 01                	push   $0x1
c002ab1f:	ff 75 10             	push   0x10(%ebp)
c002ab22:	ff 75 0c             	push   0xc(%ebp)
c002ab25:	ff 75 08             	push   0x8(%ebp)
c002ab28:	e8 22 ff ff ff       	call   c002aa4f <bitmap_contains>
c002ab2d:	83 c4 10             	add    $0x10,%esp
}
c002ab30:	c9                   	leave  
c002ab31:	c3                   	ret    

c002ab32 <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002ab32:	55                   	push   %ebp
c002ab33:	89 e5                	mov    %esp,%ebp
c002ab35:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, true);
c002ab38:	6a 01                	push   $0x1
c002ab3a:	ff 75 10             	push   0x10(%ebp)
c002ab3d:	ff 75 0c             	push   0xc(%ebp)
c002ab40:	ff 75 08             	push   0x8(%ebp)
c002ab43:	e8 07 ff ff ff       	call   c002aa4f <bitmap_contains>
c002ab48:	83 c4 10             	add    $0x10,%esp
c002ab4b:	0f b6 c0             	movzbl %al,%eax
c002ab4e:	85 c0                	test   %eax,%eax
c002ab50:	0f 95 c0             	setne  %al
c002ab53:	83 f0 01             	xor    $0x1,%eax
c002ab56:	0f b6 c0             	movzbl %al,%eax
c002ab59:	83 e0 01             	and    $0x1,%eax
}
c002ab5c:	c9                   	leave  
c002ab5d:	c3                   	ret    

c002ab5e <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002ab5e:	55                   	push   %ebp
c002ab5f:	89 e5                	mov    %esp,%ebp
c002ab61:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, false);
c002ab64:	6a 00                	push   $0x0
c002ab66:	ff 75 10             	push   0x10(%ebp)
c002ab69:	ff 75 0c             	push   0xc(%ebp)
c002ab6c:	ff 75 08             	push   0x8(%ebp)
c002ab6f:	e8 db fe ff ff       	call   c002aa4f <bitmap_contains>
c002ab74:	83 c4 10             	add    $0x10,%esp
c002ab77:	0f b6 c0             	movzbl %al,%eax
c002ab7a:	85 c0                	test   %eax,%eax
c002ab7c:	0f 95 c0             	setne  %al
c002ab7f:	83 f0 01             	xor    $0x1,%eax
c002ab82:	0f b6 c0             	movzbl %al,%eax
c002ab85:	83 e0 01             	and    $0x1,%eax
}
c002ab88:	c9                   	leave  
c002ab89:	c3                   	ret    

c002ab8a <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002ab8a:	55                   	push   %ebp
c002ab8b:	89 e5                	mov    %esp,%ebp
c002ab8d:	83 ec 28             	sub    $0x28,%esp
c002ab90:	8b 45 14             	mov    0x14(%ebp),%eax
c002ab93:	88 45 e4             	mov    %al,-0x1c(%ebp)
  ASSERT (b != NULL);
c002ab96:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ab9a:	75 21                	jne    c002abbd <bitmap_scan+0x33>
c002ab9c:	83 ec 0c             	sub    $0xc,%esp
c002ab9f:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002aba4:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002aba9:	68 3c 10 03 c0       	push   $0xc003103c
c002abae:	68 2a 01 00 00       	push   $0x12a
c002abb3:	68 63 0f 03 c0       	push   $0xc0030f63
c002abb8:	e8 61 e9 ff ff       	call   c002951e <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002abbd:	8b 45 08             	mov    0x8(%ebp),%eax
c002abc0:	8b 00                	mov    (%eax),%eax
c002abc2:	39 45 0c             	cmp    %eax,0xc(%ebp)
c002abc5:	76 21                	jbe    c002abe8 <bitmap_scan+0x5e>
c002abc7:	83 ec 0c             	sub    $0xc,%esp
c002abca:	68 98 0f 03 c0       	push   $0xc0030f98
c002abcf:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002abd4:	68 3c 10 03 c0       	push   $0xc003103c
c002abd9:	68 2b 01 00 00       	push   $0x12b
c002abde:	68 63 0f 03 c0       	push   $0xc0030f63
c002abe3:	e8 36 e9 ff ff       	call   c002951e <debug_panic>

  if (cnt <= b->bit_cnt) 
c002abe8:	8b 45 08             	mov    0x8(%ebp),%eax
c002abeb:	8b 00                	mov    (%eax),%eax
c002abed:	39 45 10             	cmp    %eax,0x10(%ebp)
c002abf0:	77 51                	ja     c002ac43 <bitmap_scan+0xb9>
    {
      size_t last = b->bit_cnt - cnt;
c002abf2:	8b 45 08             	mov    0x8(%ebp),%eax
c002abf5:	8b 00                	mov    (%eax),%eax
c002abf7:	2b 45 10             	sub    0x10(%ebp),%eax
c002abfa:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t i;
      for (i = start; i <= last; i++)
c002abfd:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ac00:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002ac03:	eb 36                	jmp    c002ac3b <bitmap_scan+0xb1>
        if (!bitmap_contains (b, i, cnt, !value))
c002ac05:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002ac09:	85 c0                	test   %eax,%eax
c002ac0b:	0f 95 c0             	setne  %al
c002ac0e:	83 f0 01             	xor    $0x1,%eax
c002ac11:	0f b6 c0             	movzbl %al,%eax
c002ac14:	83 e0 01             	and    $0x1,%eax
c002ac17:	0f b6 c0             	movzbl %al,%eax
c002ac1a:	50                   	push   %eax
c002ac1b:	ff 75 10             	push   0x10(%ebp)
c002ac1e:	ff 75 f4             	push   -0xc(%ebp)
c002ac21:	ff 75 08             	push   0x8(%ebp)
c002ac24:	e8 26 fe ff ff       	call   c002aa4f <bitmap_contains>
c002ac29:	83 c4 10             	add    $0x10,%esp
c002ac2c:	83 f0 01             	xor    $0x1,%eax
c002ac2f:	84 c0                	test   %al,%al
c002ac31:	74 05                	je     c002ac38 <bitmap_scan+0xae>
          return i; 
c002ac33:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ac36:	eb 10                	jmp    c002ac48 <bitmap_scan+0xbe>
      for (i = start; i <= last; i++)
c002ac38:	ff 45 f4             	incl   -0xc(%ebp)
c002ac3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ac3e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002ac41:	76 c2                	jbe    c002ac05 <bitmap_scan+0x7b>
    }
  return BITMAP_ERROR;
c002ac43:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002ac48:	c9                   	leave  
c002ac49:	c3                   	ret    

c002ac4a <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002ac4a:	55                   	push   %ebp
c002ac4b:	89 e5                	mov    %esp,%ebp
c002ac4d:	83 ec 28             	sub    $0x28,%esp
c002ac50:	8b 45 14             	mov    0x14(%ebp),%eax
c002ac53:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t idx = bitmap_scan (b, start, cnt, value);
c002ac56:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002ac5a:	50                   	push   %eax
c002ac5b:	ff 75 10             	push   0x10(%ebp)
c002ac5e:	ff 75 0c             	push   0xc(%ebp)
c002ac61:	ff 75 08             	push   0x8(%ebp)
c002ac64:	e8 21 ff ff ff       	call   c002ab8a <bitmap_scan>
c002ac69:	83 c4 10             	add    $0x10,%esp
c002ac6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (idx != BITMAP_ERROR) 
c002ac6f:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002ac73:	74 27                	je     c002ac9c <bitmap_scan_and_flip+0x52>
    bitmap_set_multiple (b, idx, cnt, !value);
c002ac75:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002ac79:	85 c0                	test   %eax,%eax
c002ac7b:	0f 95 c0             	setne  %al
c002ac7e:	83 f0 01             	xor    $0x1,%eax
c002ac81:	0f b6 c0             	movzbl %al,%eax
c002ac84:	83 e0 01             	and    $0x1,%eax
c002ac87:	0f b6 c0             	movzbl %al,%eax
c002ac8a:	50                   	push   %eax
c002ac8b:	ff 75 10             	push   0x10(%ebp)
c002ac8e:	ff 75 f4             	push   -0xc(%ebp)
c002ac91:	ff 75 08             	push   0x8(%ebp)
c002ac94:	e8 23 fc ff ff       	call   c002a8bc <bitmap_set_multiple>
c002ac99:	83 c4 10             	add    $0x10,%esp
  return idx;
c002ac9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002ac9f:	c9                   	leave  
c002aca0:	c3                   	ret    

c002aca1 <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002aca1:	55                   	push   %ebp
c002aca2:	89 e5                	mov    %esp,%ebp
c002aca4:	83 ec 08             	sub    $0x8,%esp
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002aca7:	8b 45 08             	mov    0x8(%ebp),%eax
c002acaa:	8b 00                	mov    (%eax),%eax
c002acac:	50                   	push   %eax
c002acad:	e8 a7 f8 ff ff       	call   c002a559 <byte_cnt>
c002acb2:	83 c4 04             	add    $0x4,%esp
c002acb5:	8b 55 08             	mov    0x8(%ebp),%edx
c002acb8:	8b 52 04             	mov    0x4(%edx),%edx
c002acbb:	6a 00                	push   $0x0
c002acbd:	50                   	push   %eax
c002acbe:	52                   	push   %edx
c002acbf:	6a 00                	push   $0x0
c002acc1:	e8 e6 cf ff ff       	call   c0027cac <hex_dump>
c002acc6:	83 c4 10             	add    $0x10,%esp
}
c002acc9:	90                   	nop
c002acca:	c9                   	leave  
c002accb:	c3                   	ret    

c002accc <hash_init>:
/* Initializes hash table H to compute hash values using HASH and
   compare hash elements using LESS, given auxiliary data AUX. */
bool
hash_init (struct hash *h,
           hash_hash_func *hash, hash_less_func *less, void *aux) 
{
c002accc:	55                   	push   %ebp
c002accd:	89 e5                	mov    %esp,%ebp
c002accf:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt = 0;
c002acd2:	8b 45 08             	mov    0x8(%ebp),%eax
c002acd5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  h->bucket_cnt = 4;
c002acdb:	8b 45 08             	mov    0x8(%ebp),%eax
c002acde:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002ace5:	8b 45 08             	mov    0x8(%ebp),%eax
c002ace8:	8b 40 04             	mov    0x4(%eax),%eax
c002aceb:	c1 e0 04             	shl    $0x4,%eax
c002acee:	83 ec 0c             	sub    $0xc,%esp
c002acf1:	50                   	push   %eax
c002acf2:	e8 6c 87 ff ff       	call   c0023463 <malloc>
c002acf7:	83 c4 10             	add    $0x10,%esp
c002acfa:	89 c2                	mov    %eax,%edx
c002acfc:	8b 45 08             	mov    0x8(%ebp),%eax
c002acff:	89 50 08             	mov    %edx,0x8(%eax)
  h->hash = hash;
c002ad02:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad05:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ad08:	89 50 0c             	mov    %edx,0xc(%eax)
  h->less = less;
c002ad0b:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad0e:	8b 55 10             	mov    0x10(%ebp),%edx
c002ad11:	89 50 10             	mov    %edx,0x10(%eax)
  h->aux = aux;
c002ad14:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad17:	8b 55 14             	mov    0x14(%ebp),%edx
c002ad1a:	89 50 14             	mov    %edx,0x14(%eax)

  if (h->buckets != NULL) 
c002ad1d:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad20:	8b 40 08             	mov    0x8(%eax),%eax
c002ad23:	85 c0                	test   %eax,%eax
c002ad25:	74 14                	je     c002ad3b <hash_init+0x6f>
    {
      hash_clear (h, NULL);
c002ad27:	83 ec 08             	sub    $0x8,%esp
c002ad2a:	6a 00                	push   $0x0
c002ad2c:	ff 75 08             	push   0x8(%ebp)
c002ad2f:	e8 0b 00 00 00       	call   c002ad3f <hash_clear>
c002ad34:	83 c4 10             	add    $0x10,%esp
      return true;
c002ad37:	b0 01                	mov    $0x1,%al
c002ad39:	eb 02                	jmp    c002ad3d <hash_init+0x71>
    }
  else
    return false;
c002ad3b:	b0 00                	mov    $0x0,%al
}
c002ad3d:	c9                   	leave  
c002ad3e:	c3                   	ret    

c002ad3f <hash_clear>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), yields undefined behavior,
   whether done in DESTRUCTOR or elsewhere. */
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
c002ad3f:	55                   	push   %ebp
c002ad40:	89 e5                	mov    %esp,%ebp
c002ad42:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c002ad45:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002ad4c:	eb 71                	jmp    c002adbf <hash_clear+0x80>
    {
      struct list *bucket = &h->buckets[i];
c002ad4e:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad51:	8b 40 08             	mov    0x8(%eax),%eax
c002ad54:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002ad57:	c1 e2 04             	shl    $0x4,%edx
c002ad5a:	01 d0                	add    %edx,%eax
c002ad5c:	89 45 f0             	mov    %eax,-0x10(%ebp)

      if (destructor != NULL) 
c002ad5f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002ad63:	74 49                	je     c002adae <hash_clear+0x6f>
        while (!list_empty (bucket)) 
c002ad65:	eb 32                	jmp    c002ad99 <hash_clear+0x5a>
          {
            struct list_elem *list_elem = list_pop_front (bucket);
c002ad67:	83 ec 0c             	sub    $0xc,%esp
c002ad6a:	ff 75 f0             	push   -0x10(%ebp)
c002ad6d:	e8 82 ee ff ff       	call   c0029bf4 <list_pop_front>
c002ad72:	83 c4 10             	add    $0x10,%esp
c002ad75:	89 45 ec             	mov    %eax,-0x14(%ebp)
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
c002ad78:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002ad7b:	83 c0 04             	add    $0x4,%eax
c002ad7e:	83 e8 04             	sub    $0x4,%eax
c002ad81:	89 45 e8             	mov    %eax,-0x18(%ebp)
            destructor (hash_elem, h->aux);
c002ad84:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad87:	8b 40 14             	mov    0x14(%eax),%eax
c002ad8a:	83 ec 08             	sub    $0x8,%esp
c002ad8d:	50                   	push   %eax
c002ad8e:	ff 75 e8             	push   -0x18(%ebp)
c002ad91:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ad94:	ff d0                	call   *%eax
c002ad96:	83 c4 10             	add    $0x10,%esp
        while (!list_empty (bucket)) 
c002ad99:	83 ec 0c             	sub    $0xc,%esp
c002ad9c:	ff 75 f0             	push   -0x10(%ebp)
c002ad9f:	e8 78 ef ff ff       	call   c0029d1c <list_empty>
c002ada4:	83 c4 10             	add    $0x10,%esp
c002ada7:	83 f0 01             	xor    $0x1,%eax
c002adaa:	84 c0                	test   %al,%al
c002adac:	75 b9                	jne    c002ad67 <hash_clear+0x28>
          }

      list_init (bucket); 
c002adae:	83 ec 0c             	sub    $0xc,%esp
c002adb1:	ff 75 f0             	push   -0x10(%ebp)
c002adb4:	e8 dc e9 ff ff       	call   c0029795 <list_init>
c002adb9:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
c002adbc:	ff 45 f4             	incl   -0xc(%ebp)
c002adbf:	8b 45 08             	mov    0x8(%ebp),%eax
c002adc2:	8b 40 04             	mov    0x4(%eax),%eax
c002adc5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002adc8:	72 84                	jb     c002ad4e <hash_clear+0xf>
    }    

  h->elem_cnt = 0;
c002adca:	8b 45 08             	mov    0x8(%ebp),%eax
c002adcd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c002add3:	90                   	nop
c002add4:	c9                   	leave  
c002add5:	c3                   	ret    

c002add6 <hash_destroy>:
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done in DESTRUCTOR or
   elsewhere. */
void
hash_destroy (struct hash *h, hash_action_func *destructor) 
{
c002add6:	55                   	push   %ebp
c002add7:	89 e5                	mov    %esp,%ebp
c002add9:	83 ec 08             	sub    $0x8,%esp
  if (destructor != NULL)
c002addc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002ade0:	74 11                	je     c002adf3 <hash_destroy+0x1d>
    hash_clear (h, destructor);
c002ade2:	83 ec 08             	sub    $0x8,%esp
c002ade5:	ff 75 0c             	push   0xc(%ebp)
c002ade8:	ff 75 08             	push   0x8(%ebp)
c002adeb:	e8 4f ff ff ff       	call   c002ad3f <hash_clear>
c002adf0:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002adf3:	8b 45 08             	mov    0x8(%ebp),%eax
c002adf6:	8b 40 08             	mov    0x8(%eax),%eax
c002adf9:	83 ec 0c             	sub    $0xc,%esp
c002adfc:	50                   	push   %eax
c002adfd:	e8 5d 89 ff ff       	call   c002375f <free>
c002ae02:	83 c4 10             	add    $0x10,%esp
}
c002ae05:	90                   	nop
c002ae06:	c9                   	leave  
c002ae07:	c3                   	ret    

c002ae08 <hash_insert>:
   no equal element is already in the table.
   If an equal element is already in the table, returns it
   without inserting NEW. */   
struct hash_elem *
hash_insert (struct hash *h, struct hash_elem *new)
{
c002ae08:	55                   	push   %ebp
c002ae09:	89 e5                	mov    %esp,%ebp
c002ae0b:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002ae0e:	83 ec 08             	sub    $0x8,%esp
c002ae11:	ff 75 0c             	push   0xc(%ebp)
c002ae14:	ff 75 08             	push   0x8(%ebp)
c002ae17:	e8 7f 04 00 00       	call   c002b29b <find_bucket>
c002ae1c:	83 c4 10             	add    $0x10,%esp
c002ae1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002ae22:	83 ec 04             	sub    $0x4,%esp
c002ae25:	ff 75 0c             	push   0xc(%ebp)
c002ae28:	ff 75 f4             	push   -0xc(%ebp)
c002ae2b:	ff 75 08             	push   0x8(%ebp)
c002ae2e:	e8 a2 04 00 00       	call   c002b2d5 <find_elem>
c002ae33:	83 c4 10             	add    $0x10,%esp
c002ae36:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old == NULL) 
c002ae39:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002ae3d:	75 14                	jne    c002ae53 <hash_insert+0x4b>
    insert_elem (h, bucket, new);
c002ae3f:	83 ec 04             	sub    $0x4,%esp
c002ae42:	ff 75 0c             	push   0xc(%ebp)
c002ae45:	ff 75 f4             	push   -0xc(%ebp)
c002ae48:	ff 75 08             	push   0x8(%ebp)
c002ae4b:	e8 ed 06 00 00       	call   c002b53d <insert_elem>
c002ae50:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002ae53:	83 ec 0c             	sub    $0xc,%esp
c002ae56:	ff 75 08             	push   0x8(%ebp)
c002ae59:	e8 42 05 00 00       	call   c002b3a0 <rehash>
c002ae5e:	83 c4 10             	add    $0x10,%esp

  return old; 
c002ae61:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002ae64:	c9                   	leave  
c002ae65:	c3                   	ret    

c002ae66 <hash_replace>:

/* Inserts NEW into hash table H, replacing any equal element
   already in the table, which is returned. */
struct hash_elem *
hash_replace (struct hash *h, struct hash_elem *new) 
{
c002ae66:	55                   	push   %ebp
c002ae67:	89 e5                	mov    %esp,%ebp
c002ae69:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002ae6c:	83 ec 08             	sub    $0x8,%esp
c002ae6f:	ff 75 0c             	push   0xc(%ebp)
c002ae72:	ff 75 08             	push   0x8(%ebp)
c002ae75:	e8 21 04 00 00       	call   c002b29b <find_bucket>
c002ae7a:	83 c4 10             	add    $0x10,%esp
c002ae7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002ae80:	83 ec 04             	sub    $0x4,%esp
c002ae83:	ff 75 0c             	push   0xc(%ebp)
c002ae86:	ff 75 f4             	push   -0xc(%ebp)
c002ae89:	ff 75 08             	push   0x8(%ebp)
c002ae8c:	e8 44 04 00 00       	call   c002b2d5 <find_elem>
c002ae91:	83 c4 10             	add    $0x10,%esp
c002ae94:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old != NULL)
c002ae97:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002ae9b:	74 11                	je     c002aeae <hash_replace+0x48>
    remove_elem (h, old);
c002ae9d:	83 ec 08             	sub    $0x8,%esp
c002aea0:	ff 75 f0             	push   -0x10(%ebp)
c002aea3:	ff 75 08             	push   0x8(%ebp)
c002aea6:	e8 ba 06 00 00       	call   c002b565 <remove_elem>
c002aeab:	83 c4 10             	add    $0x10,%esp
  insert_elem (h, bucket, new);
c002aeae:	83 ec 04             	sub    $0x4,%esp
c002aeb1:	ff 75 0c             	push   0xc(%ebp)
c002aeb4:	ff 75 f4             	push   -0xc(%ebp)
c002aeb7:	ff 75 08             	push   0x8(%ebp)
c002aeba:	e8 7e 06 00 00       	call   c002b53d <insert_elem>
c002aebf:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002aec2:	83 ec 0c             	sub    $0xc,%esp
c002aec5:	ff 75 08             	push   0x8(%ebp)
c002aec8:	e8 d3 04 00 00       	call   c002b3a0 <rehash>
c002aecd:	83 c4 10             	add    $0x10,%esp

  return old;
c002aed0:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002aed3:	c9                   	leave  
c002aed4:	c3                   	ret    

c002aed5 <hash_find>:

/* Finds and returns an element equal to E in hash table H, or a
   null pointer if no equal element exists in the table. */
struct hash_elem *
hash_find (struct hash *h, struct hash_elem *e) 
{
c002aed5:	55                   	push   %ebp
c002aed6:	89 e5                	mov    %esp,%ebp
c002aed8:	83 ec 08             	sub    $0x8,%esp
  return find_elem (h, find_bucket (h, e), e);
c002aedb:	83 ec 08             	sub    $0x8,%esp
c002aede:	ff 75 0c             	push   0xc(%ebp)
c002aee1:	ff 75 08             	push   0x8(%ebp)
c002aee4:	e8 b2 03 00 00       	call   c002b29b <find_bucket>
c002aee9:	83 c4 10             	add    $0x10,%esp
c002aeec:	83 ec 04             	sub    $0x4,%esp
c002aeef:	ff 75 0c             	push   0xc(%ebp)
c002aef2:	50                   	push   %eax
c002aef3:	ff 75 08             	push   0x8(%ebp)
c002aef6:	e8 da 03 00 00       	call   c002b2d5 <find_elem>
c002aefb:	83 c4 10             	add    $0x10,%esp
}
c002aefe:	c9                   	leave  
c002aeff:	c3                   	ret    

c002af00 <hash_delete>:
   If the elements of the hash table are dynamically allocated,
   or own resources that are, then it is the caller's
   responsibility to deallocate them. */
struct hash_elem *
hash_delete (struct hash *h, struct hash_elem *e)
{
c002af00:	55                   	push   %ebp
c002af01:	89 e5                	mov    %esp,%ebp
c002af03:	83 ec 18             	sub    $0x18,%esp
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002af06:	83 ec 08             	sub    $0x8,%esp
c002af09:	ff 75 0c             	push   0xc(%ebp)
c002af0c:	ff 75 08             	push   0x8(%ebp)
c002af0f:	e8 87 03 00 00       	call   c002b29b <find_bucket>
c002af14:	83 c4 10             	add    $0x10,%esp
c002af17:	83 ec 04             	sub    $0x4,%esp
c002af1a:	ff 75 0c             	push   0xc(%ebp)
c002af1d:	50                   	push   %eax
c002af1e:	ff 75 08             	push   0x8(%ebp)
c002af21:	e8 af 03 00 00       	call   c002b2d5 <find_elem>
c002af26:	83 c4 10             	add    $0x10,%esp
c002af29:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (found != NULL) 
c002af2c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002af30:	74 1f                	je     c002af51 <hash_delete+0x51>
    {
      remove_elem (h, found);
c002af32:	83 ec 08             	sub    $0x8,%esp
c002af35:	ff 75 f4             	push   -0xc(%ebp)
c002af38:	ff 75 08             	push   0x8(%ebp)
c002af3b:	e8 25 06 00 00       	call   c002b565 <remove_elem>
c002af40:	83 c4 10             	add    $0x10,%esp
      rehash (h); 
c002af43:	83 ec 0c             	sub    $0xc,%esp
c002af46:	ff 75 08             	push   0x8(%ebp)
c002af49:	e8 52 04 00 00       	call   c002b3a0 <rehash>
c002af4e:	83 c4 10             	add    $0x10,%esp
    }
  return found;
c002af51:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002af54:	c9                   	leave  
c002af55:	c3                   	ret    

c002af56 <hash_apply>:
   any of the functions hash_clear(), hash_destroy(),
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done from ACTION or elsewhere. */
void
hash_apply (struct hash *h, hash_action_func *action) 
{
c002af56:	55                   	push   %ebp
c002af57:	89 e5                	mov    %esp,%ebp
c002af59:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  
  ASSERT (action != NULL);
c002af5c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002af60:	75 21                	jne    c002af83 <hash_apply+0x2d>
c002af62:	83 ec 0c             	sub    $0xc,%esp
c002af65:	68 48 10 03 c0       	push   $0xc0031048
c002af6a:	68 57 10 03 c0       	push   $0xc0031057
c002af6f:	68 b0 10 03 c0       	push   $0xc00310b0
c002af74:	68 a7 00 00 00       	push   $0xa7
c002af79:	68 6e 10 03 c0       	push   $0xc003106e
c002af7e:	e8 9b e5 ff ff       	call   c002951e <debug_panic>

  for (i = 0; i < h->bucket_cnt; i++) 
c002af83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002af8a:	eb 6d                	jmp    c002aff9 <hash_apply+0xa3>
    {
      struct list *bucket = &h->buckets[i];
c002af8c:	8b 45 08             	mov    0x8(%ebp),%eax
c002af8f:	8b 40 08             	mov    0x8(%eax),%eax
c002af92:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002af95:	c1 e2 04             	shl    $0x4,%edx
c002af98:	01 d0                	add    %edx,%eax
c002af9a:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002af9d:	83 ec 0c             	sub    $0xc,%esp
c002afa0:	ff 75 ec             	push   -0x14(%ebp)
c002afa3:	e8 42 e8 ff ff       	call   c00297ea <list_begin>
c002afa8:	83 c4 10             	add    $0x10,%esp
c002afab:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002afae:	eb 33                	jmp    c002afe3 <hash_apply+0x8d>
        {
          next = list_next (elem);
c002afb0:	83 ec 0c             	sub    $0xc,%esp
c002afb3:	ff 75 f0             	push   -0x10(%ebp)
c002afb6:	e8 61 e8 ff ff       	call   c002981c <list_next>
c002afbb:	83 c4 10             	add    $0x10,%esp
c002afbe:	89 45 e8             	mov    %eax,-0x18(%ebp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002afc1:	8b 45 08             	mov    0x8(%ebp),%eax
c002afc4:	8b 40 14             	mov    0x14(%eax),%eax
c002afc7:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002afca:	83 c2 04             	add    $0x4,%edx
c002afcd:	83 ea 04             	sub    $0x4,%edx
c002afd0:	83 ec 08             	sub    $0x8,%esp
c002afd3:	50                   	push   %eax
c002afd4:	52                   	push   %edx
c002afd5:	8b 45 0c             	mov    0xc(%ebp),%eax
c002afd8:	ff d0                	call   *%eax
c002afda:	83 c4 10             	add    $0x10,%esp
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002afdd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002afe0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002afe3:	83 ec 0c             	sub    $0xc,%esp
c002afe6:	ff 75 ec             	push   -0x14(%ebp)
c002afe9:	e8 78 e8 ff ff       	call   c0029866 <list_end>
c002afee:	83 c4 10             	add    $0x10,%esp
c002aff1:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002aff4:	75 ba                	jne    c002afb0 <hash_apply+0x5a>
  for (i = 0; i < h->bucket_cnt; i++) 
c002aff6:	ff 45 f4             	incl   -0xc(%ebp)
c002aff9:	8b 45 08             	mov    0x8(%ebp),%eax
c002affc:	8b 40 04             	mov    0x4(%eax),%eax
c002afff:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002b002:	72 88                	jb     c002af8c <hash_apply+0x36>
        }
    }
}
c002b004:	90                   	nop
c002b005:	90                   	nop
c002b006:	c9                   	leave  
c002b007:	c3                   	ret    

c002b008 <hash_first>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
void
hash_first (struct hash_iterator *i, struct hash *h) 
{
c002b008:	55                   	push   %ebp
c002b009:	89 e5                	mov    %esp,%ebp
c002b00b:	83 ec 08             	sub    $0x8,%esp
  ASSERT (i != NULL);
c002b00e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b012:	75 21                	jne    c002b035 <hash_first+0x2d>
c002b014:	83 ec 0c             	sub    $0xc,%esp
c002b017:	68 86 10 03 c0       	push   $0xc0031086
c002b01c:	68 57 10 03 c0       	push   $0xc0031057
c002b021:	68 bc 10 03 c0       	push   $0xc00310bc
c002b026:	68 ca 00 00 00       	push   $0xca
c002b02b:	68 6e 10 03 c0       	push   $0xc003106e
c002b030:	e8 e9 e4 ff ff       	call   c002951e <debug_panic>
  ASSERT (h != NULL);
c002b035:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b039:	75 21                	jne    c002b05c <hash_first+0x54>
c002b03b:	83 ec 0c             	sub    $0xc,%esp
c002b03e:	68 90 10 03 c0       	push   $0xc0031090
c002b043:	68 57 10 03 c0       	push   $0xc0031057
c002b048:	68 bc 10 03 c0       	push   $0xc00310bc
c002b04d:	68 cb 00 00 00       	push   $0xcb
c002b052:	68 6e 10 03 c0       	push   $0xc003106e
c002b057:	e8 c2 e4 ff ff       	call   c002951e <debug_panic>

  i->hash = h;
c002b05c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b05f:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b062:	89 10                	mov    %edx,(%eax)
  i->bucket = i->hash->buckets;
c002b064:	8b 45 08             	mov    0x8(%ebp),%eax
c002b067:	8b 00                	mov    (%eax),%eax
c002b069:	8b 50 08             	mov    0x8(%eax),%edx
c002b06c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b06f:	89 50 04             	mov    %edx,0x4(%eax)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002b072:	8b 45 08             	mov    0x8(%ebp),%eax
c002b075:	8b 40 04             	mov    0x4(%eax),%eax
c002b078:	83 ec 0c             	sub    $0xc,%esp
c002b07b:	50                   	push   %eax
c002b07c:	e8 c4 e8 ff ff       	call   c0029945 <list_head>
c002b081:	83 c4 10             	add    $0x10,%esp
c002b084:	83 c0 04             	add    $0x4,%eax
c002b087:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b08a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b08d:	89 50 08             	mov    %edx,0x8(%eax)
}
c002b090:	90                   	nop
c002b091:	c9                   	leave  
c002b092:	c3                   	ret    

c002b093 <hash_next>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
struct hash_elem *
hash_next (struct hash_iterator *i)
{
c002b093:	55                   	push   %ebp
c002b094:	89 e5                	mov    %esp,%ebp
c002b096:	53                   	push   %ebx
c002b097:	83 ec 04             	sub    $0x4,%esp
  ASSERT (i != NULL);
c002b09a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b09e:	75 21                	jne    c002b0c1 <hash_next+0x2e>
c002b0a0:	83 ec 0c             	sub    $0xc,%esp
c002b0a3:	68 86 10 03 c0       	push   $0xc0031086
c002b0a8:	68 57 10 03 c0       	push   $0xc0031057
c002b0ad:	68 c8 10 03 c0       	push   $0xc00310c8
c002b0b2:	68 dd 00 00 00       	push   $0xdd
c002b0b7:	68 6e 10 03 c0       	push   $0xc003106e
c002b0bc:	e8 5d e4 ff ff       	call   c002951e <debug_panic>

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002b0c1:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0c4:	8b 40 08             	mov    0x8(%eax),%eax
c002b0c7:	83 ec 0c             	sub    $0xc,%esp
c002b0ca:	50                   	push   %eax
c002b0cb:	e8 4c e7 ff ff       	call   c002981c <list_next>
c002b0d0:	83 c4 10             	add    $0x10,%esp
c002b0d3:	83 c0 04             	add    $0x4,%eax
c002b0d6:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b0d9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0dc:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b0df:	eb 58                	jmp    c002b139 <hash_next+0xa6>
    {
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002b0e1:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0e4:	8b 40 04             	mov    0x4(%eax),%eax
c002b0e7:	8d 50 10             	lea    0x10(%eax),%edx
c002b0ea:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0ed:	89 50 04             	mov    %edx,0x4(%eax)
c002b0f0:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0f3:	8b 50 04             	mov    0x4(%eax),%edx
c002b0f6:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0f9:	8b 00                	mov    (%eax),%eax
c002b0fb:	8b 48 08             	mov    0x8(%eax),%ecx
c002b0fe:	8b 45 08             	mov    0x8(%ebp),%eax
c002b101:	8b 00                	mov    (%eax),%eax
c002b103:	8b 40 04             	mov    0x4(%eax),%eax
c002b106:	c1 e0 04             	shl    $0x4,%eax
c002b109:	01 c8                	add    %ecx,%eax
c002b10b:	39 c2                	cmp    %eax,%edx
c002b10d:	72 0c                	jb     c002b11b <hash_next+0x88>
        {
          i->elem = NULL;
c002b10f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b112:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          break;
c002b119:	eb 40                	jmp    c002b15b <hash_next+0xc8>
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002b11b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b11e:	8b 40 04             	mov    0x4(%eax),%eax
c002b121:	83 ec 0c             	sub    $0xc,%esp
c002b124:	50                   	push   %eax
c002b125:	e8 c0 e6 ff ff       	call   c00297ea <list_begin>
c002b12a:	83 c4 10             	add    $0x10,%esp
c002b12d:	83 c0 04             	add    $0x4,%eax
c002b130:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b133:	8b 45 08             	mov    0x8(%ebp),%eax
c002b136:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b139:	8b 45 08             	mov    0x8(%ebp),%eax
c002b13c:	8b 58 08             	mov    0x8(%eax),%ebx
c002b13f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b142:	8b 40 04             	mov    0x4(%eax),%eax
c002b145:	83 ec 0c             	sub    $0xc,%esp
c002b148:	50                   	push   %eax
c002b149:	e8 18 e7 ff ff       	call   c0029866 <list_end>
c002b14e:	83 c4 10             	add    $0x10,%esp
c002b151:	83 c0 04             	add    $0x4,%eax
c002b154:	83 e8 04             	sub    $0x4,%eax
c002b157:	39 c3                	cmp    %eax,%ebx
c002b159:	74 86                	je     c002b0e1 <hash_next+0x4e>
    }
  
  return i->elem;
c002b15b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b15e:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b161:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b164:	c9                   	leave  
c002b165:	c3                   	ret    

c002b166 <hash_cur>:
/* Returns the current element in the hash table iteration, or a
   null pointer at the end of the table.  Undefined behavior
   after calling hash_first() but before hash_next(). */
struct hash_elem *
hash_cur (struct hash_iterator *i) 
{
c002b166:	55                   	push   %ebp
c002b167:	89 e5                	mov    %esp,%ebp
  return i->elem;
c002b169:	8b 45 08             	mov    0x8(%ebp),%eax
c002b16c:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b16f:	5d                   	pop    %ebp
c002b170:	c3                   	ret    

c002b171 <hash_size>:

/* Returns the number of elements in H. */
size_t
hash_size (struct hash *h) 
{
c002b171:	55                   	push   %ebp
c002b172:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt;
c002b174:	8b 45 08             	mov    0x8(%ebp),%eax
c002b177:	8b 00                	mov    (%eax),%eax
}
c002b179:	5d                   	pop    %ebp
c002b17a:	c3                   	ret    

c002b17b <hash_empty>:

/* Returns true if H contains no elements, false otherwise. */
bool
hash_empty (struct hash *h) 
{
c002b17b:	55                   	push   %ebp
c002b17c:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt == 0;
c002b17e:	8b 45 08             	mov    0x8(%ebp),%eax
c002b181:	8b 00                	mov    (%eax),%eax
c002b183:	85 c0                	test   %eax,%eax
c002b185:	0f 94 c0             	sete   %al
}
c002b188:	5d                   	pop    %ebp
c002b189:	c3                   	ret    

c002b18a <hash_bytes>:
#define FNV_32_BASIS 2166136261u

/* Returns a hash of the SIZE bytes in BUF. */
unsigned
hash_bytes (const void *buf_, size_t size)
{
c002b18a:	55                   	push   %ebp
c002b18b:	89 e5                	mov    %esp,%ebp
c002b18d:	83 ec 18             	sub    $0x18,%esp
  /* Fowler-Noll-Vo 32-bit hash, for bytes. */
  const unsigned char *buf = buf_;
c002b190:	8b 45 08             	mov    0x8(%ebp),%eax
c002b193:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (buf != NULL);
c002b196:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b19a:	75 21                	jne    c002b1bd <hash_bytes+0x33>
c002b19c:	83 ec 0c             	sub    $0xc,%esp
c002b19f:	68 9a 10 03 c0       	push   $0xc003109a
c002b1a4:	68 57 10 03 c0       	push   $0xc0031057
c002b1a9:	68 d4 10 03 c0       	push   $0xc00310d4
c002b1ae:	68 10 01 00 00       	push   $0x110
c002b1b3:	68 6e 10 03 c0       	push   $0xc003106e
c002b1b8:	e8 61 e3 ff ff       	call   c002951e <debug_panic>

  hash = FNV_32_BASIS;
c002b1bd:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (size-- > 0)
c002b1c4:	eb 30                	jmp    c002b1f6 <hash_bytes+0x6c>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002b1c6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b1c9:	89 d0                	mov    %edx,%eax
c002b1cb:	c1 e0 10             	shl    $0x10,%eax
c002b1ce:	01 d0                	add    %edx,%eax
c002b1d0:	01 c0                	add    %eax,%eax
c002b1d2:	01 d0                	add    %edx,%eax
c002b1d4:	c1 e0 03             	shl    $0x3,%eax
c002b1d7:	01 d0                	add    %edx,%eax
c002b1d9:	c1 e0 03             	shl    $0x3,%eax
c002b1dc:	01 d0                	add    %edx,%eax
c002b1de:	01 c0                	add    %eax,%eax
c002b1e0:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
c002b1e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b1e6:	8d 50 01             	lea    0x1(%eax),%edx
c002b1e9:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b1ec:	8a 00                	mov    (%eax),%al
c002b1ee:	0f b6 c0             	movzbl %al,%eax
c002b1f1:	31 c8                	xor    %ecx,%eax
c002b1f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while (size-- > 0)
c002b1f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b1f9:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b1fc:	89 55 0c             	mov    %edx,0xc(%ebp)
c002b1ff:	85 c0                	test   %eax,%eax
c002b201:	75 c3                	jne    c002b1c6 <hash_bytes+0x3c>

  return hash;
c002b203:	8b 45 f0             	mov    -0x10(%ebp),%eax
} 
c002b206:	c9                   	leave  
c002b207:	c3                   	ret    

c002b208 <hash_string>:

/* Returns a hash of string S. */
unsigned
hash_string (const char *s_) 
{
c002b208:	55                   	push   %ebp
c002b209:	89 e5                	mov    %esp,%ebp
c002b20b:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *s = (const unsigned char *) s_;
c002b20e:	8b 45 08             	mov    0x8(%ebp),%eax
c002b211:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (s != NULL);
c002b214:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b218:	75 21                	jne    c002b23b <hash_string+0x33>
c002b21a:	83 ec 0c             	sub    $0xc,%esp
c002b21d:	68 a6 10 03 c0       	push   $0xc00310a6
c002b222:	68 57 10 03 c0       	push   $0xc0031057
c002b227:	68 e0 10 03 c0       	push   $0xc00310e0
c002b22c:	68 20 01 00 00       	push   $0x120
c002b231:	68 6e 10 03 c0       	push   $0xc003106e
c002b236:	e8 e3 e2 ff ff       	call   c002951e <debug_panic>

  hash = FNV_32_BASIS;
c002b23b:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (*s != '\0')
c002b242:	eb 30                	jmp    c002b274 <hash_string+0x6c>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002b244:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b247:	89 d0                	mov    %edx,%eax
c002b249:	c1 e0 10             	shl    $0x10,%eax
c002b24c:	01 d0                	add    %edx,%eax
c002b24e:	01 c0                	add    %eax,%eax
c002b250:	01 d0                	add    %edx,%eax
c002b252:	c1 e0 03             	shl    $0x3,%eax
c002b255:	01 d0                	add    %edx,%eax
c002b257:	c1 e0 03             	shl    $0x3,%eax
c002b25a:	01 d0                	add    %edx,%eax
c002b25c:	01 c0                	add    %eax,%eax
c002b25e:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
c002b261:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b264:	8d 50 01             	lea    0x1(%eax),%edx
c002b267:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b26a:	8a 00                	mov    (%eax),%al
c002b26c:	0f b6 c0             	movzbl %al,%eax
c002b26f:	31 c8                	xor    %ecx,%eax
c002b271:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while (*s != '\0')
c002b274:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b277:	8a 00                	mov    (%eax),%al
c002b279:	84 c0                	test   %al,%al
c002b27b:	75 c7                	jne    c002b244 <hash_string+0x3c>

  return hash;
c002b27d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b280:	c9                   	leave  
c002b281:	c3                   	ret    

c002b282 <hash_int>:

/* Returns a hash of integer I. */
unsigned
hash_int (int i) 
{
c002b282:	55                   	push   %ebp
c002b283:	89 e5                	mov    %esp,%ebp
c002b285:	83 ec 08             	sub    $0x8,%esp
  return hash_bytes (&i, sizeof i);
c002b288:	83 ec 08             	sub    $0x8,%esp
c002b28b:	6a 04                	push   $0x4
c002b28d:	8d 45 08             	lea    0x8(%ebp),%eax
c002b290:	50                   	push   %eax
c002b291:	e8 f4 fe ff ff       	call   c002b18a <hash_bytes>
c002b296:	83 c4 10             	add    $0x10,%esp
}
c002b299:	c9                   	leave  
c002b29a:	c3                   	ret    

c002b29b <find_bucket>:

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002b29b:	55                   	push   %ebp
c002b29c:	89 e5                	mov    %esp,%ebp
c002b29e:	83 ec 18             	sub    $0x18,%esp
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002b2a1:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2a4:	8b 40 0c             	mov    0xc(%eax),%eax
c002b2a7:	8b 55 08             	mov    0x8(%ebp),%edx
c002b2aa:	8b 52 14             	mov    0x14(%edx),%edx
c002b2ad:	83 ec 08             	sub    $0x8,%esp
c002b2b0:	52                   	push   %edx
c002b2b1:	ff 75 0c             	push   0xc(%ebp)
c002b2b4:	ff d0                	call   *%eax
c002b2b6:	83 c4 10             	add    $0x10,%esp
c002b2b9:	8b 55 08             	mov    0x8(%ebp),%edx
c002b2bc:	8b 52 04             	mov    0x4(%edx),%edx
c002b2bf:	4a                   	dec    %edx
c002b2c0:	21 d0                	and    %edx,%eax
c002b2c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return &h->buckets[bucket_idx];
c002b2c5:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2c8:	8b 40 08             	mov    0x8(%eax),%eax
c002b2cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b2ce:	c1 e2 04             	shl    $0x4,%edx
c002b2d1:	01 d0                	add    %edx,%eax
}
c002b2d3:	c9                   	leave  
c002b2d4:	c3                   	ret    

c002b2d5 <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002b2d5:	55                   	push   %ebp
c002b2d6:	89 e5                	mov    %esp,%ebp
c002b2d8:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002b2db:	83 ec 0c             	sub    $0xc,%esp
c002b2de:	ff 75 0c             	push   0xc(%ebp)
c002b2e1:	e8 04 e5 ff ff       	call   c00297ea <list_begin>
c002b2e6:	83 c4 10             	add    $0x10,%esp
c002b2e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b2ec:	eb 66                	jmp    c002b354 <find_elem+0x7f>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
c002b2ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b2f1:	83 c0 04             	add    $0x4,%eax
c002b2f4:	83 e8 04             	sub    $0x4,%eax
c002b2f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002b2fa:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2fd:	8b 40 10             	mov    0x10(%eax),%eax
c002b300:	8b 55 08             	mov    0x8(%ebp),%edx
c002b303:	8b 52 14             	mov    0x14(%edx),%edx
c002b306:	83 ec 04             	sub    $0x4,%esp
c002b309:	52                   	push   %edx
c002b30a:	ff 75 10             	push   0x10(%ebp)
c002b30d:	ff 75 f0             	push   -0x10(%ebp)
c002b310:	ff d0                	call   *%eax
c002b312:	83 c4 10             	add    $0x10,%esp
c002b315:	83 f0 01             	xor    $0x1,%eax
c002b318:	84 c0                	test   %al,%al
c002b31a:	74 27                	je     c002b343 <find_elem+0x6e>
c002b31c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b31f:	8b 40 10             	mov    0x10(%eax),%eax
c002b322:	8b 55 08             	mov    0x8(%ebp),%edx
c002b325:	8b 52 14             	mov    0x14(%edx),%edx
c002b328:	83 ec 04             	sub    $0x4,%esp
c002b32b:	52                   	push   %edx
c002b32c:	ff 75 f0             	push   -0x10(%ebp)
c002b32f:	ff 75 10             	push   0x10(%ebp)
c002b332:	ff d0                	call   *%eax
c002b334:	83 c4 10             	add    $0x10,%esp
c002b337:	83 f0 01             	xor    $0x1,%eax
c002b33a:	84 c0                	test   %al,%al
c002b33c:	74 05                	je     c002b343 <find_elem+0x6e>
        return hi; 
c002b33e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b341:	eb 29                	jmp    c002b36c <find_elem+0x97>
  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002b343:	83 ec 0c             	sub    $0xc,%esp
c002b346:	ff 75 f4             	push   -0xc(%ebp)
c002b349:	e8 ce e4 ff ff       	call   c002981c <list_next>
c002b34e:	83 c4 10             	add    $0x10,%esp
c002b351:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b354:	83 ec 0c             	sub    $0xc,%esp
c002b357:	ff 75 0c             	push   0xc(%ebp)
c002b35a:	e8 07 e5 ff ff       	call   c0029866 <list_end>
c002b35f:	83 c4 10             	add    $0x10,%esp
c002b362:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002b365:	75 87                	jne    c002b2ee <find_elem+0x19>
    }
  return NULL;
c002b367:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b36c:	c9                   	leave  
c002b36d:	c3                   	ret    

c002b36e <turn_off_least_1bit>:

/* Returns X with its lowest-order bit set to 1 turned off. */
static inline size_t
turn_off_least_1bit (size_t x) 
{
c002b36e:	55                   	push   %ebp
c002b36f:	89 e5                	mov    %esp,%ebp
  return x & (x - 1);
c002b371:	8b 45 08             	mov    0x8(%ebp),%eax
c002b374:	48                   	dec    %eax
c002b375:	23 45 08             	and    0x8(%ebp),%eax
}
c002b378:	5d                   	pop    %ebp
c002b379:	c3                   	ret    

c002b37a <is_power_of_2>:

/* Returns true if X is a power of 2, otherwise false. */
static inline size_t
is_power_of_2 (size_t x) 
{
c002b37a:	55                   	push   %ebp
c002b37b:	89 e5                	mov    %esp,%ebp
  return x != 0 && turn_off_least_1bit (x) == 0;
c002b37d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b381:	74 16                	je     c002b399 <is_power_of_2+0x1f>
c002b383:	ff 75 08             	push   0x8(%ebp)
c002b386:	e8 e3 ff ff ff       	call   c002b36e <turn_off_least_1bit>
c002b38b:	83 c4 04             	add    $0x4,%esp
c002b38e:	85 c0                	test   %eax,%eax
c002b390:	75 07                	jne    c002b399 <is_power_of_2+0x1f>
c002b392:	b8 01 00 00 00       	mov    $0x1,%eax
c002b397:	eb 05                	jmp    c002b39e <is_power_of_2+0x24>
c002b399:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b39e:	c9                   	leave  
c002b39f:	c3                   	ret    

c002b3a0 <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002b3a0:	55                   	push   %ebp
c002b3a1:	89 e5                	mov    %esp,%ebp
c002b3a3:	83 ec 38             	sub    $0x38,%esp
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002b3a6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b3aa:	75 21                	jne    c002b3cd <rehash+0x2d>
c002b3ac:	83 ec 0c             	sub    $0xc,%esp
c002b3af:	68 90 10 03 c0       	push   $0xc0031090
c002b3b4:	68 57 10 03 c0       	push   $0xc0031057
c002b3b9:	68 ec 10 03 c0       	push   $0xc00310ec
c002b3be:	68 66 01 00 00       	push   $0x166
c002b3c3:	68 6e 10 03 c0       	push   $0xc003106e
c002b3c8:	e8 51 e1 ff ff       	call   c002951e <debug_panic>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
c002b3cd:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3d0:	8b 40 08             	mov    0x8(%eax),%eax
c002b3d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  old_bucket_cnt = h->bucket_cnt;
c002b3d6:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3d9:	8b 40 04             	mov    0x4(%eax),%eax
c002b3dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002b3df:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3e2:	8b 00                	mov    (%eax),%eax
c002b3e4:	d1 e8                	shr    %eax
c002b3e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (new_bucket_cnt < 4)
c002b3e9:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c002b3ed:	77 1a                	ja     c002b409 <rehash+0x69>
    new_bucket_cnt = 4;
c002b3ef:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002b3f6:	eb 11                	jmp    c002b409 <rehash+0x69>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);
c002b3f8:	83 ec 0c             	sub    $0xc,%esp
c002b3fb:	ff 75 f4             	push   -0xc(%ebp)
c002b3fe:	e8 6b ff ff ff       	call   c002b36e <turn_off_least_1bit>
c002b403:	83 c4 10             	add    $0x10,%esp
c002b406:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002b409:	83 ec 0c             	sub    $0xc,%esp
c002b40c:	ff 75 f4             	push   -0xc(%ebp)
c002b40f:	e8 66 ff ff ff       	call   c002b37a <is_power_of_2>
c002b414:	83 c4 10             	add    $0x10,%esp
c002b417:	85 c0                	test   %eax,%eax
c002b419:	74 dd                	je     c002b3f8 <rehash+0x58>

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002b41b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b41e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002b421:	0f 84 10 01 00 00    	je     c002b537 <rehash+0x197>
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002b427:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b42a:	c1 e0 04             	shl    $0x4,%eax
c002b42d:	83 ec 0c             	sub    $0xc,%esp
c002b430:	50                   	push   %eax
c002b431:	e8 2d 80 ff ff       	call   c0023463 <malloc>
c002b436:	83 c4 10             	add    $0x10,%esp
c002b439:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (new_buckets == NULL) 
c002b43c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002b440:	0f 84 f4 00 00 00    	je     c002b53a <rehash+0x19a>
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
c002b446:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002b44d:	eb 1c                	jmp    c002b46b <rehash+0xcb>
    list_init (&new_buckets[i]);
c002b44f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b452:	c1 e0 04             	shl    $0x4,%eax
c002b455:	89 c2                	mov    %eax,%edx
c002b457:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002b45a:	01 d0                	add    %edx,%eax
c002b45c:	83 ec 0c             	sub    $0xc,%esp
c002b45f:	50                   	push   %eax
c002b460:	e8 30 e3 ff ff       	call   c0029795 <list_init>
c002b465:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < new_bucket_cnt; i++) 
c002b468:	ff 45 f0             	incl   -0x10(%ebp)
c002b46b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b46e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b471:	72 dc                	jb     c002b44f <rehash+0xaf>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002b473:	8b 45 08             	mov    0x8(%ebp),%eax
c002b476:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002b479:	89 50 08             	mov    %edx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002b47c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b47f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b482:	89 50 04             	mov    %edx,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002b485:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002b48c:	e9 8a 00 00 00       	jmp    c002b51b <rehash+0x17b>
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
c002b491:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b494:	c1 e0 04             	shl    $0x4,%eax
c002b497:	89 c2                	mov    %eax,%edx
c002b499:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b49c:	01 d0                	add    %edx,%eax
c002b49e:	89 45 dc             	mov    %eax,-0x24(%ebp)
      for (elem = list_begin (old_bucket);
c002b4a1:	83 ec 0c             	sub    $0xc,%esp
c002b4a4:	ff 75 dc             	push   -0x24(%ebp)
c002b4a7:	e8 3e e3 ff ff       	call   c00297ea <list_begin>
c002b4ac:	83 c4 10             	add    $0x10,%esp
c002b4af:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002b4b2:	eb 51                	jmp    c002b505 <rehash+0x165>
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
            = find_bucket (h, list_elem_to_hash_elem (elem));
c002b4b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002b4b7:	83 c0 04             	add    $0x4,%eax
c002b4ba:	83 e8 04             	sub    $0x4,%eax
c002b4bd:	83 ec 08             	sub    $0x8,%esp
c002b4c0:	50                   	push   %eax
c002b4c1:	ff 75 08             	push   0x8(%ebp)
c002b4c4:	e8 d2 fd ff ff       	call   c002b29b <find_bucket>
c002b4c9:	83 c4 10             	add    $0x10,%esp
c002b4cc:	89 45 d8             	mov    %eax,-0x28(%ebp)
          next = list_next (elem);
c002b4cf:	83 ec 0c             	sub    $0xc,%esp
c002b4d2:	ff 75 ec             	push   -0x14(%ebp)
c002b4d5:	e8 42 e3 ff ff       	call   c002981c <list_next>
c002b4da:	83 c4 10             	add    $0x10,%esp
c002b4dd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          list_remove (elem);
c002b4e0:	83 ec 0c             	sub    $0xc,%esp
c002b4e3:	ff 75 ec             	push   -0x14(%ebp)
c002b4e6:	e8 b0 e6 ff ff       	call   c0029b9b <list_remove>
c002b4eb:	83 c4 10             	add    $0x10,%esp
          list_push_front (new_bucket, elem);
c002b4ee:	83 ec 08             	sub    $0x8,%esp
c002b4f1:	ff 75 ec             	push   -0x14(%ebp)
c002b4f4:	ff 75 d8             	push   -0x28(%ebp)
c002b4f7:	e8 53 e6 ff ff       	call   c0029b4f <list_push_front>
c002b4fc:	83 c4 10             	add    $0x10,%esp
           elem != list_end (old_bucket); elem = next) 
c002b4ff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002b502:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002b505:	83 ec 0c             	sub    $0xc,%esp
c002b508:	ff 75 dc             	push   -0x24(%ebp)
c002b50b:	e8 56 e3 ff ff       	call   c0029866 <list_end>
c002b510:	83 c4 10             	add    $0x10,%esp
      for (elem = list_begin (old_bucket);
c002b513:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c002b516:	75 9c                	jne    c002b4b4 <rehash+0x114>
  for (i = 0; i < old_bucket_cnt; i++) 
c002b518:	ff 45 f0             	incl   -0x10(%ebp)
c002b51b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b51e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002b521:	0f 82 6a ff ff ff    	jb     c002b491 <rehash+0xf1>
        }
    }

  free (old_buckets);
c002b527:	83 ec 0c             	sub    $0xc,%esp
c002b52a:	ff 75 e8             	push   -0x18(%ebp)
c002b52d:	e8 2d 82 ff ff       	call   c002375f <free>
c002b532:	83 c4 10             	add    $0x10,%esp
c002b535:	eb 04                	jmp    c002b53b <rehash+0x19b>
    return;
c002b537:	90                   	nop
c002b538:	eb 01                	jmp    c002b53b <rehash+0x19b>
      return;
c002b53a:	90                   	nop
}
c002b53b:	c9                   	leave  
c002b53c:	c3                   	ret    

c002b53d <insert_elem>:

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002b53d:	55                   	push   %ebp
c002b53e:	89 e5                	mov    %esp,%ebp
c002b540:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt++;
c002b543:	8b 45 08             	mov    0x8(%ebp),%eax
c002b546:	8b 00                	mov    (%eax),%eax
c002b548:	8d 50 01             	lea    0x1(%eax),%edx
c002b54b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b54e:	89 10                	mov    %edx,(%eax)
  list_push_front (bucket, &e->list_elem);
c002b550:	8b 45 10             	mov    0x10(%ebp),%eax
c002b553:	83 ec 08             	sub    $0x8,%esp
c002b556:	50                   	push   %eax
c002b557:	ff 75 0c             	push   0xc(%ebp)
c002b55a:	e8 f0 e5 ff ff       	call   c0029b4f <list_push_front>
c002b55f:	83 c4 10             	add    $0x10,%esp
}
c002b562:	90                   	nop
c002b563:	c9                   	leave  
c002b564:	c3                   	ret    

c002b565 <remove_elem>:

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
c002b565:	55                   	push   %ebp
c002b566:	89 e5                	mov    %esp,%ebp
c002b568:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt--;
c002b56b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b56e:	8b 00                	mov    (%eax),%eax
c002b570:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b573:	8b 45 08             	mov    0x8(%ebp),%eax
c002b576:	89 10                	mov    %edx,(%eax)
  list_remove (&e->list_elem);
c002b578:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b57b:	83 ec 0c             	sub    $0xc,%esp
c002b57e:	50                   	push   %eax
c002b57f:	e8 17 e6 ff ff       	call   c0029b9b <list_remove>
c002b584:	83 c4 10             	add    $0x10,%esp
}
c002b587:	90                   	nop
c002b588:	c9                   	leave  
c002b589:	c3                   	ret    

c002b58a <console_init>:
static int64_t write_cnt;

/* Enable console locking. */
void
console_init (void) 
{
c002b58a:	55                   	push   %ebp
c002b58b:	89 e5                	mov    %esp,%ebp
c002b58d:	83 ec 08             	sub    $0x8,%esp
  lock_init (&console_lock);
c002b590:	83 ec 0c             	sub    $0xc,%esp
c002b593:	68 c8 53 03 c0       	push   $0xc00353c8
c002b598:	e8 b8 74 ff ff       	call   c0022a55 <lock_init>
c002b59d:	83 c4 10             	add    $0x10,%esp
  use_console_lock = true;
c002b5a0:	c6 05 e0 53 03 c0 01 	movb   $0x1,0xc00353e0
}
c002b5a7:	90                   	nop
c002b5a8:	c9                   	leave  
c002b5a9:	c3                   	ret    

c002b5aa <console_panic>:
/* Notifies the console that a kernel panic is underway,
   which warns it to avoid trying to take the console lock from
   now on. */
void
console_panic (void) 
{
c002b5aa:	55                   	push   %ebp
c002b5ab:	89 e5                	mov    %esp,%ebp
  use_console_lock = false;
c002b5ad:	c6 05 e0 53 03 c0 00 	movb   $0x0,0xc00353e0
}
c002b5b4:	90                   	nop
c002b5b5:	5d                   	pop    %ebp
c002b5b6:	c3                   	ret    

c002b5b7 <console_print_stats>:

/* Prints console statistics. */
void
console_print_stats (void) 
{
c002b5b7:	55                   	push   %ebp
c002b5b8:	89 e5                	mov    %esp,%ebp
c002b5ba:	83 ec 08             	sub    $0x8,%esp
  printf ("Console: %lld characters output\n", write_cnt);
c002b5bd:	a1 e8 53 03 c0       	mov    0xc00353e8,%eax
c002b5c2:	8b 15 ec 53 03 c0    	mov    0xc00353ec,%edx
c002b5c8:	83 ec 04             	sub    $0x4,%esp
c002b5cb:	52                   	push   %edx
c002b5cc:	50                   	push   %eax
c002b5cd:	68 f4 10 03 c0       	push   $0xc00310f4
c002b5d2:	e8 a5 bb ff ff       	call   c002717c <printf>
c002b5d7:	83 c4 10             	add    $0x10,%esp
}
c002b5da:	90                   	nop
c002b5db:	c9                   	leave  
c002b5dc:	c3                   	ret    

c002b5dd <acquire_console>:

/* Acquires the console lock. */
static void
acquire_console (void) 
{
c002b5dd:	55                   	push   %ebp
c002b5de:	89 e5                	mov    %esp,%ebp
c002b5e0:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002b5e3:	e8 82 60 ff ff       	call   c002166a <intr_context>
c002b5e8:	83 f0 01             	xor    $0x1,%eax
c002b5eb:	84 c0                	test   %al,%al
c002b5ed:	74 3a                	je     c002b629 <acquire_console+0x4c>
c002b5ef:	a0 e0 53 03 c0       	mov    0xc00353e0,%al
c002b5f4:	84 c0                	test   %al,%al
c002b5f6:	74 31                	je     c002b629 <acquire_console+0x4c>
    {
      if (lock_held_by_current_thread (&console_lock)) 
c002b5f8:	83 ec 0c             	sub    $0xc,%esp
c002b5fb:	68 c8 53 03 c0       	push   $0xc00353c8
c002b600:	e8 57 76 ff ff       	call   c0022c5c <lock_held_by_current_thread>
c002b605:	83 c4 10             	add    $0x10,%esp
c002b608:	84 c0                	test   %al,%al
c002b60a:	74 0d                	je     c002b619 <acquire_console+0x3c>
        console_lock_depth++; 
c002b60c:	a1 e4 53 03 c0       	mov    0xc00353e4,%eax
c002b611:	40                   	inc    %eax
c002b612:	a3 e4 53 03 c0       	mov    %eax,0xc00353e4
      else
        lock_acquire (&console_lock); 
    }
}
c002b617:	eb 10                	jmp    c002b629 <acquire_console+0x4c>
        lock_acquire (&console_lock); 
c002b619:	83 ec 0c             	sub    $0xc,%esp
c002b61c:	68 c8 53 03 c0       	push   $0xc00353c8
c002b621:	e8 7c 74 ff ff       	call   c0022aa2 <lock_acquire>
c002b626:	83 c4 10             	add    $0x10,%esp
}
c002b629:	90                   	nop
c002b62a:	c9                   	leave  
c002b62b:	c3                   	ret    

c002b62c <release_console>:

/* Releases the console lock. */
static void
release_console (void) 
{
c002b62c:	55                   	push   %ebp
c002b62d:	89 e5                	mov    %esp,%ebp
c002b62f:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002b632:	e8 33 60 ff ff       	call   c002166a <intr_context>
c002b637:	83 f0 01             	xor    $0x1,%eax
c002b63a:	84 c0                	test   %al,%al
c002b63c:	74 2f                	je     c002b66d <release_console+0x41>
c002b63e:	a0 e0 53 03 c0       	mov    0xc00353e0,%al
c002b643:	84 c0                	test   %al,%al
c002b645:	74 26                	je     c002b66d <release_console+0x41>
    {
      if (console_lock_depth > 0)
c002b647:	a1 e4 53 03 c0       	mov    0xc00353e4,%eax
c002b64c:	85 c0                	test   %eax,%eax
c002b64e:	7e 0d                	jle    c002b65d <release_console+0x31>
        console_lock_depth--;
c002b650:	a1 e4 53 03 c0       	mov    0xc00353e4,%eax
c002b655:	48                   	dec    %eax
c002b656:	a3 e4 53 03 c0       	mov    %eax,0xc00353e4
      else
        lock_release (&console_lock); 
    }
}
c002b65b:	eb 10                	jmp    c002b66d <release_console+0x41>
        lock_release (&console_lock); 
c002b65d:	83 ec 0c             	sub    $0xc,%esp
c002b660:	68 c8 53 03 c0       	push   $0xc00353c8
c002b665:	e8 74 75 ff ff       	call   c0022bde <lock_release>
c002b66a:	83 c4 10             	add    $0x10,%esp
}
c002b66d:	90                   	nop
c002b66e:	c9                   	leave  
c002b66f:	c3                   	ret    

c002b670 <console_locked_by_current_thread>:

/* Returns true if the current thread has the console lock,
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
c002b670:	55                   	push   %ebp
c002b671:	89 e5                	mov    %esp,%ebp
c002b673:	83 ec 08             	sub    $0x8,%esp
  return (intr_context ()
c002b676:	e8 ef 5f ff ff       	call   c002166a <intr_context>
          || !use_console_lock
          || lock_held_by_current_thread (&console_lock));
c002b67b:	84 c0                	test   %al,%al
c002b67d:	75 20                	jne    c002b69f <console_locked_by_current_thread+0x2f>
          || !use_console_lock
c002b67f:	a0 e0 53 03 c0       	mov    0xc00353e0,%al
c002b684:	83 f0 01             	xor    $0x1,%eax
c002b687:	84 c0                	test   %al,%al
c002b689:	75 14                	jne    c002b69f <console_locked_by_current_thread+0x2f>
          || lock_held_by_current_thread (&console_lock));
c002b68b:	83 ec 0c             	sub    $0xc,%esp
c002b68e:	68 c8 53 03 c0       	push   $0xc00353c8
c002b693:	e8 c4 75 ff ff       	call   c0022c5c <lock_held_by_current_thread>
c002b698:	83 c4 10             	add    $0x10,%esp
c002b69b:	84 c0                	test   %al,%al
c002b69d:	74 07                	je     c002b6a6 <console_locked_by_current_thread+0x36>
c002b69f:	b8 01 00 00 00       	mov    $0x1,%eax
c002b6a4:	eb 05                	jmp    c002b6ab <console_locked_by_current_thread+0x3b>
c002b6a6:	b8 00 00 00 00       	mov    $0x0,%eax
c002b6ab:	83 e0 01             	and    $0x1,%eax
}
c002b6ae:	c9                   	leave  
c002b6af:	c3                   	ret    

c002b6b0 <vprintf>:
/* The standard vprintf() function,
   which is like printf() but uses a va_list.
   Writes its output to both vga display and serial port. */
int
vprintf (const char *format, va_list args) 
{
c002b6b0:	55                   	push   %ebp
c002b6b1:	89 e5                	mov    %esp,%ebp
c002b6b3:	83 ec 18             	sub    $0x18,%esp
  int char_cnt = 0;
c002b6b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  acquire_console ();
c002b6bd:	e8 1b ff ff ff       	call   c002b5dd <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002b6c2:	8d 45 f4             	lea    -0xc(%ebp),%eax
c002b6c5:	50                   	push   %eax
c002b6c6:	68 8f b7 02 c0       	push   $0xc002b78f
c002b6cb:	ff 75 0c             	push   0xc(%ebp)
c002b6ce:	ff 75 08             	push   0x8(%ebp)
c002b6d1:	e8 cc ba ff ff       	call   c00271a2 <__vprintf>
c002b6d6:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002b6d9:	e8 4e ff ff ff       	call   c002b62c <release_console>

  return char_cnt;
c002b6de:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b6e1:	c9                   	leave  
c002b6e2:	c3                   	ret    

c002b6e3 <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
c002b6e3:	55                   	push   %ebp
c002b6e4:	89 e5                	mov    %esp,%ebp
c002b6e6:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002b6e9:	e8 ef fe ff ff       	call   c002b5dd <acquire_console>
  while (*s != '\0')
c002b6ee:	eb 1a                	jmp    c002b70a <puts+0x27>
    putchar_have_lock (*s++);
c002b6f0:	8b 45 08             	mov    0x8(%ebp),%eax
c002b6f3:	8d 50 01             	lea    0x1(%eax),%edx
c002b6f6:	89 55 08             	mov    %edx,0x8(%ebp)
c002b6f9:	8a 00                	mov    (%eax),%al
c002b6fb:	0f b6 c0             	movzbl %al,%eax
c002b6fe:	83 ec 0c             	sub    $0xc,%esp
c002b701:	50                   	push   %eax
c002b702:	e8 bc 00 00 00       	call   c002b7c3 <putchar_have_lock>
c002b707:	83 c4 10             	add    $0x10,%esp
  while (*s != '\0')
c002b70a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b70d:	8a 00                	mov    (%eax),%al
c002b70f:	84 c0                	test   %al,%al
c002b711:	75 dd                	jne    c002b6f0 <puts+0xd>
  putchar_have_lock ('\n');
c002b713:	83 ec 0c             	sub    $0xc,%esp
c002b716:	6a 0a                	push   $0xa
c002b718:	e8 a6 00 00 00       	call   c002b7c3 <putchar_have_lock>
c002b71d:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002b720:	e8 07 ff ff ff       	call   c002b62c <release_console>

  return 0;
c002b725:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b72a:	c9                   	leave  
c002b72b:	c3                   	ret    

c002b72c <putbuf>:

/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
c002b72c:	55                   	push   %ebp
c002b72d:	89 e5                	mov    %esp,%ebp
c002b72f:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002b732:	e8 a6 fe ff ff       	call   c002b5dd <acquire_console>
  while (n-- > 0)
c002b737:	eb 1a                	jmp    c002b753 <putbuf+0x27>
    putchar_have_lock (*buffer++);
c002b739:	8b 45 08             	mov    0x8(%ebp),%eax
c002b73c:	8d 50 01             	lea    0x1(%eax),%edx
c002b73f:	89 55 08             	mov    %edx,0x8(%ebp)
c002b742:	8a 00                	mov    (%eax),%al
c002b744:	0f b6 c0             	movzbl %al,%eax
c002b747:	83 ec 0c             	sub    $0xc,%esp
c002b74a:	50                   	push   %eax
c002b74b:	e8 73 00 00 00       	call   c002b7c3 <putchar_have_lock>
c002b750:	83 c4 10             	add    $0x10,%esp
  while (n-- > 0)
c002b753:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b756:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b759:	89 55 0c             	mov    %edx,0xc(%ebp)
c002b75c:	85 c0                	test   %eax,%eax
c002b75e:	75 d9                	jne    c002b739 <putbuf+0xd>
  release_console ();
c002b760:	e8 c7 fe ff ff       	call   c002b62c <release_console>
}
c002b765:	90                   	nop
c002b766:	c9                   	leave  
c002b767:	c3                   	ret    

c002b768 <putchar>:

/* Writes C to the vga display and serial port. */
int
putchar (int c) 
{
c002b768:	55                   	push   %ebp
c002b769:	89 e5                	mov    %esp,%ebp
c002b76b:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002b76e:	e8 6a fe ff ff       	call   c002b5dd <acquire_console>
  putchar_have_lock (c);
c002b773:	8b 45 08             	mov    0x8(%ebp),%eax
c002b776:	0f b6 c0             	movzbl %al,%eax
c002b779:	83 ec 0c             	sub    $0xc,%esp
c002b77c:	50                   	push   %eax
c002b77d:	e8 41 00 00 00       	call   c002b7c3 <putchar_have_lock>
c002b782:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002b785:	e8 a2 fe ff ff       	call   c002b62c <release_console>
  
  return c;
c002b78a:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002b78d:	c9                   	leave  
c002b78e:	c3                   	ret    

c002b78f <vprintf_helper>:

/* Helper function for vprintf(). */
static void
vprintf_helper (char c, void *char_cnt_) 
{
c002b78f:	55                   	push   %ebp
c002b790:	89 e5                	mov    %esp,%ebp
c002b792:	83 ec 28             	sub    $0x28,%esp
c002b795:	8b 45 08             	mov    0x8(%ebp),%eax
c002b798:	88 45 e4             	mov    %al,-0x1c(%ebp)
  int *char_cnt = char_cnt_;
c002b79b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b79e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  (*char_cnt)++;
c002b7a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b7a4:	8b 00                	mov    (%eax),%eax
c002b7a6:	8d 50 01             	lea    0x1(%eax),%edx
c002b7a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b7ac:	89 10                	mov    %edx,(%eax)
  putchar_have_lock (c);
c002b7ae:	8a 45 e4             	mov    -0x1c(%ebp),%al
c002b7b1:	0f b6 c0             	movzbl %al,%eax
c002b7b4:	83 ec 0c             	sub    $0xc,%esp
c002b7b7:	50                   	push   %eax
c002b7b8:	e8 06 00 00 00       	call   c002b7c3 <putchar_have_lock>
c002b7bd:	83 c4 10             	add    $0x10,%esp
}
c002b7c0:	90                   	nop
c002b7c1:	c9                   	leave  
c002b7c2:	c3                   	ret    

c002b7c3 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002b7c3:	55                   	push   %ebp
c002b7c4:	89 e5                	mov    %esp,%ebp
c002b7c6:	83 ec 18             	sub    $0x18,%esp
c002b7c9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7cc:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (console_locked_by_current_thread ());
c002b7cf:	e8 9c fe ff ff       	call   c002b670 <console_locked_by_current_thread>
c002b7d4:	84 c0                	test   %al,%al
c002b7d6:	75 21                	jne    c002b7f9 <putchar_have_lock+0x36>
c002b7d8:	83 ec 0c             	sub    $0xc,%esp
c002b7db:	68 18 11 03 c0       	push   $0xc0031118
c002b7e0:	68 3c 11 03 c0       	push   $0xc003113c
c002b7e5:	68 70 11 03 c0       	push   $0xc0031170
c002b7ea:	68 bb 00 00 00       	push   $0xbb
c002b7ef:	68 53 11 03 c0       	push   $0xc0031153
c002b7f4:	e8 25 dd ff ff       	call   c002951e <debug_panic>
  write_cnt++;
c002b7f9:	a1 e8 53 03 c0       	mov    0xc00353e8,%eax
c002b7fe:	8b 15 ec 53 03 c0    	mov    0xc00353ec,%edx
c002b804:	83 c0 01             	add    $0x1,%eax
c002b807:	83 d2 00             	adc    $0x0,%edx
c002b80a:	a3 e8 53 03 c0       	mov    %eax,0xc00353e8
c002b80f:	89 15 ec 53 03 c0    	mov    %edx,0xc00353ec
  serial_putc (c);
c002b815:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002b819:	83 ec 0c             	sub    $0xc,%esp
c002b81c:	50                   	push   %eax
c002b81d:	e8 7f 91 ff ff       	call   c00249a1 <serial_putc>
c002b822:	83 c4 10             	add    $0x10,%esp
  vga_putc (c);
c002b825:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002b829:	83 ec 0c             	sub    $0xc,%esp
c002b82c:	50                   	push   %eax
c002b82d:	e8 04 8d ff ff       	call   c0024536 <vga_putc>
c002b832:	83 c4 10             	add    $0x10,%esp
}
c002b835:	90                   	nop
c002b836:	c9                   	leave  
c002b837:	c3                   	ret    

c002b838 <run_test>:
static const char *test_name;

/* Runs the test named NAME. */
void
run_test (const char *name) 
{
c002b838:	55                   	push   %ebp
c002b839:	89 e5                	mov    %esp,%ebp
c002b83b:	83 ec 18             	sub    $0x18,%esp
  const struct test *t;

  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002b83e:	c7 45 f4 60 13 03 c0 	movl   $0xc0031360,-0xc(%ebp)
c002b845:	eb 4e                	jmp    c002b895 <run_test+0x5d>
    if (!strcmp (name, t->name))
c002b847:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b84a:	8b 00                	mov    (%eax),%eax
c002b84c:	83 ec 08             	sub    $0x8,%esp
c002b84f:	50                   	push   %eax
c002b850:	ff 75 08             	push   0x8(%ebp)
c002b853:	e8 15 cd ff ff       	call   c002856d <strcmp>
c002b858:	83 c4 10             	add    $0x10,%esp
c002b85b:	85 c0                	test   %eax,%eax
c002b85d:	75 32                	jne    c002b891 <run_test+0x59>
      {
        test_name = name;
c002b85f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b862:	a3 f0 53 03 c0       	mov    %eax,0xc00353f0
        msg ("begin");
c002b867:	83 ec 0c             	sub    $0xc,%esp
c002b86a:	68 38 14 03 c0       	push   $0xc0031438
c002b86f:	e8 49 00 00 00       	call   c002b8bd <msg>
c002b874:	83 c4 10             	add    $0x10,%esp
        t->function ();
c002b877:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b87a:	8b 40 04             	mov    0x4(%eax),%eax
c002b87d:	ff d0                	call   *%eax
        msg ("end");
c002b87f:	83 ec 0c             	sub    $0xc,%esp
c002b882:	68 3e 14 03 c0       	push   $0xc003143e
c002b887:	e8 31 00 00 00       	call   c002b8bd <msg>
c002b88c:	83 c4 10             	add    $0x10,%esp
        return;
c002b88f:	eb 2a                	jmp    c002b8bb <run_test+0x83>
  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002b891:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
c002b895:	b8 38 14 03 c0       	mov    $0xc0031438,%eax
c002b89a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002b89d:	72 a8                	jb     c002b847 <run_test+0xf>
      }
  PANIC ("no test named \"%s\"", name);
c002b89f:	83 ec 0c             	sub    $0xc,%esp
c002b8a2:	ff 75 08             	push   0x8(%ebp)
c002b8a5:	68 42 14 03 c0       	push   $0xc0031442
c002b8aa:	68 9c 14 03 c0       	push   $0xc003149c
c002b8af:	6a 3c                	push   $0x3c
c002b8b1:	68 55 14 03 c0       	push   $0xc0031455
c002b8b6:	e8 63 dc ff ff       	call   c002951e <debug_panic>
}
c002b8bb:	c9                   	leave  
c002b8bc:	c3                   	ret    

c002b8bd <msg>:
/* Prints FORMAT as if with printf(),
   prefixing the output by the name of the test
   and following it with a new-line character. */
void
msg (const char *format, ...) 
{
c002b8bd:	55                   	push   %ebp
c002b8be:	89 e5                	mov    %esp,%ebp
c002b8c0:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  
  printf ("(%s) ", test_name);
c002b8c3:	a1 f0 53 03 c0       	mov    0xc00353f0,%eax
c002b8c8:	83 ec 08             	sub    $0x8,%esp
c002b8cb:	50                   	push   %eax
c002b8cc:	68 71 14 03 c0       	push   $0xc0031471
c002b8d1:	e8 a6 b8 ff ff       	call   c002717c <printf>
c002b8d6:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002b8d9:	8d 45 0c             	lea    0xc(%ebp),%eax
c002b8dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002b8df:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b8e2:	83 ec 08             	sub    $0x8,%esp
c002b8e5:	50                   	push   %eax
c002b8e6:	ff 75 08             	push   0x8(%ebp)
c002b8e9:	e8 c2 fd ff ff       	call   c002b6b0 <vprintf>
c002b8ee:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002b8f1:	83 ec 0c             	sub    $0xc,%esp
c002b8f4:	6a 0a                	push   $0xa
c002b8f6:	e8 6d fe ff ff       	call   c002b768 <putchar>
c002b8fb:	83 c4 10             	add    $0x10,%esp
}
c002b8fe:	90                   	nop
c002b8ff:	c9                   	leave  
c002b900:	c3                   	ret    

c002b901 <fail>:
   prefixing the output by the name of the test and FAIL:
   and following it with a new-line character,
   and then panics the kernel. */
void
fail (const char *format, ...) 
{
c002b901:	55                   	push   %ebp
c002b902:	89 e5                	mov    %esp,%ebp
c002b904:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  
  printf ("(%s) FAIL: ", test_name);
c002b907:	a1 f0 53 03 c0       	mov    0xc00353f0,%eax
c002b90c:	83 ec 08             	sub    $0x8,%esp
c002b90f:	50                   	push   %eax
c002b910:	68 77 14 03 c0       	push   $0xc0031477
c002b915:	e8 62 b8 ff ff       	call   c002717c <printf>
c002b91a:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002b91d:	8d 45 0c             	lea    0xc(%ebp),%eax
c002b920:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002b923:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b926:	83 ec 08             	sub    $0x8,%esp
c002b929:	50                   	push   %eax
c002b92a:	ff 75 08             	push   0x8(%ebp)
c002b92d:	e8 7e fd ff ff       	call   c002b6b0 <vprintf>
c002b932:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002b935:	83 ec 0c             	sub    $0xc,%esp
c002b938:	6a 0a                	push   $0xa
c002b93a:	e8 29 fe ff ff       	call   c002b768 <putchar>
c002b93f:	83 c4 10             	add    $0x10,%esp

  PANIC ("test failed");
c002b942:	68 83 14 03 c0       	push   $0xc0031483
c002b947:	68 a8 14 03 c0       	push   $0xc00314a8
c002b94c:	6a 5d                	push   $0x5d
c002b94e:	68 55 14 03 c0       	push   $0xc0031455
c002b953:	e8 c6 db ff ff       	call   c002951e <debug_panic>

c002b958 <pass>:
}

/* Prints a message indicating the current test passed. */
void
pass (void) 
{
c002b958:	55                   	push   %ebp
c002b959:	89 e5                	mov    %esp,%ebp
c002b95b:	83 ec 08             	sub    $0x8,%esp
  printf ("(%s) PASS\n", test_name);
c002b95e:	a1 f0 53 03 c0       	mov    0xc00353f0,%eax
c002b963:	83 ec 08             	sub    $0x8,%esp
c002b966:	50                   	push   %eax
c002b967:	68 8f 14 03 c0       	push   $0xc003148f
c002b96c:	e8 0b b8 ff ff       	call   c002717c <printf>
c002b971:	83 c4 10             	add    $0x10,%esp
}
c002b974:	90                   	nop
c002b975:	c9                   	leave  
c002b976:	c3                   	ret    

c002b977 <test_alarm_single>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_single (void) 
{
c002b977:	55                   	push   %ebp
c002b978:	89 e5                	mov    %esp,%ebp
c002b97a:	83 ec 08             	sub    $0x8,%esp
  test_sleep (5, 1);
c002b97d:	83 ec 08             	sub    $0x8,%esp
c002b980:	6a 01                	push   $0x1
c002b982:	6a 05                	push   $0x5
c002b984:	e8 1e 00 00 00       	call   c002b9a7 <test_sleep>
c002b989:	83 c4 10             	add    $0x10,%esp
}
c002b98c:	90                   	nop
c002b98d:	c9                   	leave  
c002b98e:	c3                   	ret    

c002b98f <test_alarm_multiple>:

void
test_alarm_multiple (void) 
{
c002b98f:	55                   	push   %ebp
c002b990:	89 e5                	mov    %esp,%ebp
c002b992:	83 ec 08             	sub    $0x8,%esp
  test_sleep (5, 7);
c002b995:	83 ec 08             	sub    $0x8,%esp
c002b998:	6a 07                	push   $0x7
c002b99a:	6a 05                	push   $0x5
c002b99c:	e8 06 00 00 00       	call   c002b9a7 <test_sleep>
c002b9a1:	83 c4 10             	add    $0x10,%esp
}
c002b9a4:	90                   	nop
c002b9a5:	c9                   	leave  
c002b9a6:	c3                   	ret    

c002b9a7 <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002b9a7:	55                   	push   %ebp
c002b9a8:	89 e5                	mov    %esp,%ebp
c002b9aa:	83 ec 68             	sub    $0x68,%esp
  int *output, *op;
  int product;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002b9ad:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002b9b2:	83 f0 01             	xor    $0x1,%eax
c002b9b5:	84 c0                	test   %al,%al
c002b9b7:	75 1e                	jne    c002b9d7 <test_sleep+0x30>
c002b9b9:	83 ec 0c             	sub    $0xc,%esp
c002b9bc:	68 b0 14 03 c0       	push   $0xc00314b0
c002b9c1:	68 be 14 03 c0       	push   $0xc00314be
c002b9c6:	68 c4 16 03 c0       	push   $0xc00316c4
c002b9cb:	6a 3c                	push   $0x3c
c002b9cd:	68 d8 14 03 c0       	push   $0xc00314d8
c002b9d2:	e8 47 db ff ff       	call   c002951e <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002b9d7:	83 ec 04             	sub    $0x4,%esp
c002b9da:	ff 75 0c             	push   0xc(%ebp)
c002b9dd:	ff 75 08             	push   0x8(%ebp)
c002b9e0:	68 fc 14 03 c0       	push   $0xc00314fc
c002b9e5:	e8 d3 fe ff ff       	call   c002b8bd <msg>
c002b9ea:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 0 sleeps 10 ticks each time,");
c002b9ed:	83 ec 0c             	sub    $0xc,%esp
c002b9f0:	68 28 15 03 c0       	push   $0xc0031528
c002b9f5:	e8 c3 fe ff ff       	call   c002b8bd <msg>
c002b9fa:	83 c4 10             	add    $0x10,%esp
  msg ("thread 1 sleeps 20 ticks each time, and so on.");
c002b9fd:	83 ec 0c             	sub    $0xc,%esp
c002ba00:	68 4c 15 03 c0       	push   $0xc003154c
c002ba05:	e8 b3 fe ff ff       	call   c002b8bd <msg>
c002ba0a:	83 c4 10             	add    $0x10,%esp
  msg ("If successful, product of iteration count and");
c002ba0d:	83 ec 0c             	sub    $0xc,%esp
c002ba10:	68 7c 15 03 c0       	push   $0xc003157c
c002ba15:	e8 a3 fe ff ff       	call   c002b8bd <msg>
c002ba1a:	83 c4 10             	add    $0x10,%esp
  msg ("sleep duration will appear in nondescending order.");
c002ba1d:	83 ec 0c             	sub    $0xc,%esp
c002ba20:	68 ac 15 03 c0       	push   $0xc00315ac
c002ba25:	e8 93 fe ff ff       	call   c002b8bd <msg>
c002ba2a:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  threads = malloc (sizeof *threads * thread_cnt);
c002ba2d:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba30:	c1 e0 04             	shl    $0x4,%eax
c002ba33:	83 ec 0c             	sub    $0xc,%esp
c002ba36:	50                   	push   %eax
c002ba37:	e8 27 7a ff ff       	call   c0023463 <malloc>
c002ba3c:	83 c4 10             	add    $0x10,%esp
c002ba3f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002ba42:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ba45:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba48:	0f af c2             	imul   %edx,%eax
c002ba4b:	c1 e0 03             	shl    $0x3,%eax
c002ba4e:	83 ec 0c             	sub    $0xc,%esp
c002ba51:	50                   	push   %eax
c002ba52:	e8 0c 7a ff ff       	call   c0023463 <malloc>
c002ba57:	83 c4 10             	add    $0x10,%esp
c002ba5a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (threads == NULL || output == NULL)
c002ba5d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002ba61:	74 06                	je     c002ba69 <test_sleep+0xc2>
c002ba63:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002ba67:	75 16                	jne    c002ba7f <test_sleep+0xd8>
    PANIC ("couldn't allocate memory for test");
c002ba69:	68 e0 15 03 c0       	push   $0xc00315e0
c002ba6e:	68 c4 16 03 c0       	push   $0xc00316c4
c002ba73:	6a 48                	push   $0x48
c002ba75:	68 d8 14 03 c0       	push   $0xc00314d8
c002ba7a:	e8 9f da ff ff       	call   c002951e <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002ba7f:	e8 26 82 ff ff       	call   c0023caa <timer_ticks>
c002ba84:	83 c0 64             	add    $0x64,%eax
c002ba87:	83 d2 00             	adc    $0x0,%edx
c002ba8a:	89 45 b0             	mov    %eax,-0x50(%ebp)
c002ba8d:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  test.iterations = iterations;
c002ba90:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ba93:	89 45 b8             	mov    %eax,-0x48(%ebp)
  lock_init (&test.output_lock);
c002ba96:	83 ec 0c             	sub    $0xc,%esp
c002ba99:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002ba9c:	83 c0 0c             	add    $0xc,%eax
c002ba9f:	50                   	push   %eax
c002baa0:	e8 b0 6f ff ff       	call   c0022a55 <lock_init>
c002baa5:	83 c4 10             	add    $0x10,%esp
  test.output_pos = output;
c002baa8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002baab:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002baae:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002bab2:	75 1e                	jne    c002bad2 <test_sleep+0x12b>
c002bab4:	83 ec 0c             	sub    $0xc,%esp
c002bab7:	68 02 16 03 c0       	push   $0xc0031602
c002babc:	68 be 14 03 c0       	push   $0xc00314be
c002bac1:	68 c4 16 03 c0       	push   $0xc00316c4
c002bac6:	6a 51                	push   $0x51
c002bac8:	68 d8 14 03 c0       	push   $0xc00314d8
c002bacd:	e8 4c da ff ff       	call   c002951e <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002bad2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002bad9:	eb 71                	jmp    c002bb4c <test_sleep+0x1a5>
    {
      struct sleep_thread *t = threads + i;
c002badb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bade:	c1 e0 04             	shl    $0x4,%eax
c002bae1:	89 c2                	mov    %eax,%edx
c002bae3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bae6:	01 d0                	add    %edx,%eax
c002bae8:	89 45 d8             	mov    %eax,-0x28(%ebp)
      char name[16];
      
      t->test = &test;
c002baeb:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002baee:	8d 55 b0             	lea    -0x50(%ebp),%edx
c002baf1:	89 10                	mov    %edx,(%eax)
      t->id = i;
c002baf3:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002baf6:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002baf9:	89 50 04             	mov    %edx,0x4(%eax)
      t->duration = (i + 1) * 10;
c002bafc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002baff:	8d 50 01             	lea    0x1(%eax),%edx
c002bb02:	89 d0                	mov    %edx,%eax
c002bb04:	c1 e0 02             	shl    $0x2,%eax
c002bb07:	01 d0                	add    %edx,%eax
c002bb09:	01 c0                	add    %eax,%eax
c002bb0b:	89 c2                	mov    %eax,%edx
c002bb0d:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002bb10:	89 50 08             	mov    %edx,0x8(%eax)
      t->iterations = 0;
c002bb13:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002bb16:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

      snprintf (name, sizeof name, "thread %d", i);
c002bb1d:	ff 75 ec             	push   -0x14(%ebp)
c002bb20:	68 11 16 03 c0       	push   $0xc0031611
c002bb25:	6a 10                	push   $0x10
c002bb27:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002bb2a:	50                   	push   %eax
c002bb2b:	e8 23 b6 ff ff       	call   c0027153 <snprintf>
c002bb30:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, t);
c002bb33:	ff 75 d8             	push   -0x28(%ebp)
c002bb36:	68 e1 bc 02 c0       	push   $0xc002bce1
c002bb3b:	6a 1f                	push   $0x1f
c002bb3d:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002bb40:	50                   	push   %eax
c002bb41:	e8 1b 4f ff ff       	call   c0020a61 <thread_create>
c002bb46:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002bb49:	ff 45 ec             	incl   -0x14(%ebp)
c002bb4c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bb4f:	3b 45 08             	cmp    0x8(%ebp),%eax
c002bb52:	7c 87                	jl     c002badb <test_sleep+0x134>
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c002bb54:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb57:	0f af 45 0c          	imul   0xc(%ebp),%eax
c002bb5b:	89 c2                	mov    %eax,%edx
c002bb5d:	89 d0                	mov    %edx,%eax
c002bb5f:	c1 e0 02             	shl    $0x2,%eax
c002bb62:	01 d0                	add    %edx,%eax
c002bb64:	01 c0                	add    %eax,%eax
c002bb66:	05 c8 00 00 00       	add    $0xc8,%eax
c002bb6b:	99                   	cltd   
c002bb6c:	83 ec 08             	sub    $0x8,%esp
c002bb6f:	52                   	push   %edx
c002bb70:	50                   	push   %eax
c002bb71:	e8 88 81 ff ff       	call   c0023cfe <timer_sleep>
c002bb76:	83 c4 10             	add    $0x10,%esp

  /* Acquire the output lock in case some rogue thread is still
     running. */
  lock_acquire (&test.output_lock);
c002bb79:	83 ec 0c             	sub    $0xc,%esp
c002bb7c:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002bb7f:	83 c0 0c             	add    $0xc,%eax
c002bb82:	50                   	push   %eax
c002bb83:	e8 1a 6f ff ff       	call   c0022aa2 <lock_acquire>
c002bb88:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  product = 0;
c002bb8b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (op = output; op < test.output_pos; op++) 
c002bb92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002bb95:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002bb98:	e9 ba 00 00 00       	jmp    c002bc57 <test_sleep+0x2b0>
    {
      struct sleep_thread *t;
      int new_prod;

      ASSERT (*op >= 0 && *op < thread_cnt);
c002bb9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bba0:	8b 00                	mov    (%eax),%eax
c002bba2:	85 c0                	test   %eax,%eax
c002bba4:	78 0a                	js     c002bbb0 <test_sleep+0x209>
c002bba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bba9:	8b 00                	mov    (%eax),%eax
c002bbab:	39 45 08             	cmp    %eax,0x8(%ebp)
c002bbae:	7f 1e                	jg     c002bbce <test_sleep+0x227>
c002bbb0:	83 ec 0c             	sub    $0xc,%esp
c002bbb3:	68 1b 16 03 c0       	push   $0xc003161b
c002bbb8:	68 be 14 03 c0       	push   $0xc00314be
c002bbbd:	68 c4 16 03 c0       	push   $0xc00316c4
c002bbc2:	6a 6e                	push   $0x6e
c002bbc4:	68 d8 14 03 c0       	push   $0xc00314d8
c002bbc9:	e8 50 d9 ff ff       	call   c002951e <debug_panic>
      t = threads + *op;
c002bbce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bbd1:	8b 00                	mov    (%eax),%eax
c002bbd3:	c1 e0 04             	shl    $0x4,%eax
c002bbd6:	89 c2                	mov    %eax,%edx
c002bbd8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bbdb:	01 d0                	add    %edx,%eax
c002bbdd:	89 45 e0             	mov    %eax,-0x20(%ebp)

      new_prod = ++t->iterations * t->duration;
c002bbe0:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bbe3:	8b 40 0c             	mov    0xc(%eax),%eax
c002bbe6:	8d 50 01             	lea    0x1(%eax),%edx
c002bbe9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bbec:	89 50 0c             	mov    %edx,0xc(%eax)
c002bbef:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bbf2:	8b 50 0c             	mov    0xc(%eax),%edx
c002bbf5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bbf8:	8b 40 08             	mov    0x8(%eax),%eax
c002bbfb:	0f af c2             	imul   %edx,%eax
c002bbfe:	89 45 dc             	mov    %eax,-0x24(%ebp)
        
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
c002bc01:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bc04:	8b 48 0c             	mov    0xc(%eax),%ecx
c002bc07:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bc0a:	8b 50 08             	mov    0x8(%eax),%edx
c002bc0d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bc10:	8b 40 04             	mov    0x4(%eax),%eax
c002bc13:	83 ec 0c             	sub    $0xc,%esp
c002bc16:	ff 75 dc             	push   -0x24(%ebp)
c002bc19:	51                   	push   %ecx
c002bc1a:	52                   	push   %edx
c002bc1b:	50                   	push   %eax
c002bc1c:	68 38 16 03 c0       	push   $0xc0031638
c002bc21:	e8 97 fc ff ff       	call   c002b8bd <msg>
c002bc26:	83 c4 20             	add    $0x20,%esp
           t->id, t->duration, t->iterations, new_prod);
      
      if (new_prod >= product)
c002bc29:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bc2c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002bc2f:	7c 08                	jl     c002bc39 <test_sleep+0x292>
        product = new_prod;
c002bc31:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bc34:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002bc37:	eb 1a                	jmp    c002bc53 <test_sleep+0x2ac>
      else
        fail ("thread %d woke up out of order (%d > %d)!",
c002bc39:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bc3c:	8b 40 04             	mov    0x4(%eax),%eax
c002bc3f:	ff 75 dc             	push   -0x24(%ebp)
c002bc42:	ff 75 f0             	push   -0x10(%ebp)
c002bc45:	50                   	push   %eax
c002bc46:	68 6c 16 03 c0       	push   $0xc003166c
c002bc4b:	e8 b1 fc ff ff       	call   c002b901 <fail>
c002bc50:	83 c4 10             	add    $0x10,%esp
  for (op = output; op < test.output_pos; op++) 
c002bc53:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002bc57:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002bc5a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002bc5d:	0f 82 3a ff ff ff    	jb     c002bb9d <test_sleep+0x1f6>
              t->id, product, new_prod);
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
c002bc63:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002bc6a:	eb 3c                	jmp    c002bca8 <test_sleep+0x301>
    if (threads[i].iterations != iterations)
c002bc6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bc6f:	c1 e0 04             	shl    $0x4,%eax
c002bc72:	89 c2                	mov    %eax,%edx
c002bc74:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bc77:	01 d0                	add    %edx,%eax
c002bc79:	8b 40 0c             	mov    0xc(%eax),%eax
c002bc7c:	39 45 0c             	cmp    %eax,0xc(%ebp)
c002bc7f:	74 24                	je     c002bca5 <test_sleep+0x2fe>
      fail ("thread %d woke up %d times instead of %d",
            i, threads[i].iterations, iterations);
c002bc81:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bc84:	c1 e0 04             	shl    $0x4,%eax
c002bc87:	89 c2                	mov    %eax,%edx
c002bc89:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bc8c:	01 d0                	add    %edx,%eax
      fail ("thread %d woke up %d times instead of %d",
c002bc8e:	8b 40 0c             	mov    0xc(%eax),%eax
c002bc91:	ff 75 0c             	push   0xc(%ebp)
c002bc94:	50                   	push   %eax
c002bc95:	ff 75 ec             	push   -0x14(%ebp)
c002bc98:	68 98 16 03 c0       	push   $0xc0031698
c002bc9d:	e8 5f fc ff ff       	call   c002b901 <fail>
c002bca2:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002bca5:	ff 45 ec             	incl   -0x14(%ebp)
c002bca8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bcab:	3b 45 08             	cmp    0x8(%ebp),%eax
c002bcae:	7c bc                	jl     c002bc6c <test_sleep+0x2c5>
  
  lock_release (&test.output_lock);
c002bcb0:	83 ec 0c             	sub    $0xc,%esp
c002bcb3:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002bcb6:	83 c0 0c             	add    $0xc,%eax
c002bcb9:	50                   	push   %eax
c002bcba:	e8 1f 6f ff ff       	call   c0022bde <lock_release>
c002bcbf:	83 c4 10             	add    $0x10,%esp
  free (output);
c002bcc2:	83 ec 0c             	sub    $0xc,%esp
c002bcc5:	ff 75 e4             	push   -0x1c(%ebp)
c002bcc8:	e8 92 7a ff ff       	call   c002375f <free>
c002bccd:	83 c4 10             	add    $0x10,%esp
  free (threads);
c002bcd0:	83 ec 0c             	sub    $0xc,%esp
c002bcd3:	ff 75 e8             	push   -0x18(%ebp)
c002bcd6:	e8 84 7a ff ff       	call   c002375f <free>
c002bcdb:	83 c4 10             	add    $0x10,%esp
}
c002bcde:	90                   	nop
c002bcdf:	c9                   	leave  
c002bce0:	c3                   	ret    

c002bce1 <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *t_) 
{
c002bce1:	55                   	push   %ebp
c002bce2:	89 e5                	mov    %esp,%ebp
c002bce4:	53                   	push   %ebx
c002bce5:	83 ec 24             	sub    $0x24,%esp
  struct sleep_thread *t = t_;
c002bce8:	8b 45 08             	mov    0x8(%ebp),%eax
c002bceb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct sleep_test *test = t->test;
c002bcee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bcf1:	8b 00                	mov    (%eax),%eax
c002bcf3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int i;

  for (i = 1; i <= test->iterations; i++) 
c002bcf6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002bcfd:	eb 7b                	jmp    c002bd7a <sleeper+0x99>
    {
      int64_t sleep_until = test->start + i * t->duration;
c002bcff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd02:	8b 08                	mov    (%eax),%ecx
c002bd04:	8b 58 04             	mov    0x4(%eax),%ebx
c002bd07:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bd0a:	8b 40 08             	mov    0x8(%eax),%eax
c002bd0d:	0f af 45 f4          	imul   -0xc(%ebp),%eax
c002bd11:	99                   	cltd   
c002bd12:	01 c8                	add    %ecx,%eax
c002bd14:	11 da                	adc    %ebx,%edx
c002bd16:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002bd19:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002bd1c:	e8 89 7f ff ff       	call   c0023caa <timer_ticks>
c002bd21:	89 c1                	mov    %eax,%ecx
c002bd23:	89 d3                	mov    %edx,%ebx
c002bd25:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bd28:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002bd2b:	29 c8                	sub    %ecx,%eax
c002bd2d:	19 da                	sbb    %ebx,%edx
c002bd2f:	83 ec 08             	sub    $0x8,%esp
c002bd32:	52                   	push   %edx
c002bd33:	50                   	push   %eax
c002bd34:	e8 c5 7f ff ff       	call   c0023cfe <timer_sleep>
c002bd39:	83 c4 10             	add    $0x10,%esp
      lock_acquire (&test->output_lock);
c002bd3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd3f:	83 c0 0c             	add    $0xc,%eax
c002bd42:	83 ec 0c             	sub    $0xc,%esp
c002bd45:	50                   	push   %eax
c002bd46:	e8 57 6d ff ff       	call   c0022aa2 <lock_acquire>
c002bd4b:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = t->id;
c002bd4e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd51:	8b 40 24             	mov    0x24(%eax),%eax
c002bd54:	8d 48 04             	lea    0x4(%eax),%ecx
c002bd57:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002bd5a:	89 4a 24             	mov    %ecx,0x24(%edx)
c002bd5d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002bd60:	8b 52 04             	mov    0x4(%edx),%edx
c002bd63:	89 10                	mov    %edx,(%eax)
      lock_release (&test->output_lock);
c002bd65:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd68:	83 c0 0c             	add    $0xc,%eax
c002bd6b:	83 ec 0c             	sub    $0xc,%esp
c002bd6e:	50                   	push   %eax
c002bd6f:	e8 6a 6e ff ff       	call   c0022bde <lock_release>
c002bd74:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i <= test->iterations; i++) 
c002bd77:	ff 45 f4             	incl   -0xc(%ebp)
c002bd7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd7d:	8b 40 08             	mov    0x8(%eax),%eax
c002bd80:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002bd83:	0f 8e 76 ff ff ff    	jle    c002bcff <sleeper+0x1e>
    }
}
c002bd89:	90                   	nop
c002bd8a:	90                   	nop
c002bd8b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bd8e:	c9                   	leave  
c002bd8f:	c3                   	ret    

c002bd90 <test_alarm_simultaneous>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_simultaneous (void) 
{
c002bd90:	55                   	push   %ebp
c002bd91:	89 e5                	mov    %esp,%ebp
c002bd93:	83 ec 08             	sub    $0x8,%esp
  test_sleep (3, 5);
c002bd96:	83 ec 08             	sub    $0x8,%esp
c002bd99:	6a 05                	push   $0x5
c002bd9b:	6a 03                	push   $0x3
c002bd9d:	e8 06 00 00 00       	call   c002bda8 <test_sleep>
c002bda2:	83 c4 10             	add    $0x10,%esp
}
c002bda5:	90                   	nop
c002bda6:	c9                   	leave  
c002bda7:	c3                   	ret    

c002bda8 <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002bda8:	55                   	push   %ebp
c002bda9:	89 e5                	mov    %esp,%ebp
c002bdab:	53                   	push   %ebx
c002bdac:	83 ec 34             	sub    $0x34,%esp
  struct sleep_test test;
  int *output;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002bdaf:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002bdb4:	83 f0 01             	xor    $0x1,%eax
c002bdb7:	84 c0                	test   %al,%al
c002bdb9:	75 1e                	jne    c002bdd9 <test_sleep+0x31>
c002bdbb:	83 ec 0c             	sub    $0xc,%esp
c002bdbe:	68 d0 16 03 c0       	push   $0xc00316d0
c002bdc3:	68 de 16 03 c0       	push   $0xc00316de
c002bdc8:	68 58 18 03 c0       	push   $0xc0031858
c002bdcd:	6a 28                	push   $0x28
c002bdcf:	68 f8 16 03 c0       	push   $0xc00316f8
c002bdd4:	e8 45 d7 ff ff       	call   c002951e <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002bdd9:	83 ec 04             	sub    $0x4,%esp
c002bddc:	ff 75 0c             	push   0xc(%ebp)
c002bddf:	ff 75 08             	push   0x8(%ebp)
c002bde2:	68 24 17 03 c0       	push   $0xc0031724
c002bde7:	e8 d1 fa ff ff       	call   c002b8bd <msg>
c002bdec:	83 c4 10             	add    $0x10,%esp
  msg ("Each thread sleeps 10 ticks each time.");
c002bdef:	83 ec 0c             	sub    $0xc,%esp
c002bdf2:	68 50 17 03 c0       	push   $0xc0031750
c002bdf7:	e8 c1 fa ff ff       	call   c002b8bd <msg>
c002bdfc:	83 c4 10             	add    $0x10,%esp
  msg ("Within an iteration, all threads should wake up on the same tick.");
c002bdff:	83 ec 0c             	sub    $0xc,%esp
c002be02:	68 78 17 03 c0       	push   $0xc0031778
c002be07:	e8 b1 fa ff ff       	call   c002b8bd <msg>
c002be0c:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002be0f:	8b 55 0c             	mov    0xc(%ebp),%edx
c002be12:	8b 45 08             	mov    0x8(%ebp),%eax
c002be15:	0f af c2             	imul   %edx,%eax
c002be18:	c1 e0 03             	shl    $0x3,%eax
c002be1b:	83 ec 0c             	sub    $0xc,%esp
c002be1e:	50                   	push   %eax
c002be1f:	e8 3f 76 ff ff       	call   c0023463 <malloc>
c002be24:	83 c4 10             	add    $0x10,%esp
c002be27:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (output == NULL)
c002be2a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002be2e:	75 16                	jne    c002be46 <test_sleep+0x9e>
    PANIC ("couldn't allocate memory for test");
c002be30:	68 bc 17 03 c0       	push   $0xc00317bc
c002be35:	68 58 18 03 c0       	push   $0xc0031858
c002be3a:	6a 31                	push   $0x31
c002be3c:	68 f8 16 03 c0       	push   $0xc00316f8
c002be41:	e8 d8 d6 ff ff       	call   c002951e <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002be46:	e8 5f 7e ff ff       	call   c0023caa <timer_ticks>
c002be4b:	83 c0 64             	add    $0x64,%eax
c002be4e:	83 d2 00             	adc    $0x0,%edx
c002be51:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002be54:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  test.iterations = iterations;
c002be57:	8b 45 0c             	mov    0xc(%ebp),%eax
c002be5a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  test.output_pos = output;
c002be5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002be60:	89 45 ec             	mov    %eax,-0x14(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002be63:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002be67:	75 1e                	jne    c002be87 <test_sleep+0xdf>
c002be69:	83 ec 0c             	sub    $0xc,%esp
c002be6c:	68 de 17 03 c0       	push   $0xc00317de
c002be71:	68 de 16 03 c0       	push   $0xc00316de
c002be76:	68 58 18 03 c0       	push   $0xc0031858
c002be7b:	6a 39                	push   $0x39
c002be7d:	68 f8 16 03 c0       	push   $0xc00316f8
c002be82:	e8 97 d6 ff ff       	call   c002951e <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002be87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002be8e:	eb 30                	jmp    c002bec0 <test_sleep+0x118>
    {
      char name[16];
      snprintf (name, sizeof name, "thread %d", i);
c002be90:	ff 75 f4             	push   -0xc(%ebp)
c002be93:	68 ed 17 03 c0       	push   $0xc00317ed
c002be98:	6a 10                	push   $0x10
c002be9a:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002be9d:	50                   	push   %eax
c002be9e:	e8 b0 b2 ff ff       	call   c0027153 <snprintf>
c002bea3:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, &test);
c002bea6:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002bea9:	50                   	push   %eax
c002beaa:	68 76 bf 02 c0       	push   $0xc002bf76
c002beaf:	6a 1f                	push   $0x1f
c002beb1:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002beb4:	50                   	push   %eax
c002beb5:	e8 a7 4b ff ff       	call   c0020a61 <thread_create>
c002beba:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002bebd:	ff 45 f4             	incl   -0xc(%ebp)
c002bec0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bec3:	3b 45 08             	cmp    0x8(%ebp),%eax
c002bec6:	7c c8                	jl     c002be90 <test_sleep+0xe8>
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + iterations * 10 + 100);
c002bec8:	8b 55 0c             	mov    0xc(%ebp),%edx
c002becb:	89 d0                	mov    %edx,%eax
c002becd:	c1 e0 02             	shl    $0x2,%eax
c002bed0:	01 d0                	add    %edx,%eax
c002bed2:	01 c0                	add    %eax,%eax
c002bed4:	05 c8 00 00 00       	add    $0xc8,%eax
c002bed9:	99                   	cltd   
c002beda:	83 ec 08             	sub    $0x8,%esp
c002bedd:	52                   	push   %edx
c002bede:	50                   	push   %eax
c002bedf:	e8 1a 7e ff ff       	call   c0023cfe <timer_sleep>
c002bee4:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
c002bee7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002beea:	8b 00                	mov    (%eax),%eax
c002beec:	83 ec 08             	sub    $0x8,%esp
c002beef:	50                   	push   %eax
c002bef0:	68 f8 17 03 c0       	push   $0xc00317f8
c002bef5:	e8 c3 f9 ff ff       	call   c002b8bd <msg>
c002befa:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < test.output_pos - output; i++) 
c002befd:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002bf04:	eb 4e                	jmp    c002bf54 <test_sleep+0x1ac>
    msg ("iteration %d, thread %d: woke up %d ticks later",
         i / thread_cnt, i % thread_cnt, output[i] - output[i - 1]);
c002bf06:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf09:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002bf10:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bf13:	01 d0                	add    %edx,%eax
c002bf15:	8b 10                	mov    (%eax),%edx
c002bf17:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf1a:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
c002bf1f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c002bf26:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bf29:	01 c8                	add    %ecx,%eax
c002bf2b:	8b 00                	mov    (%eax),%eax
    msg ("iteration %d, thread %d: woke up %d ticks later",
c002bf2d:	89 d3                	mov    %edx,%ebx
c002bf2f:	29 c3                	sub    %eax,%ebx
c002bf31:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf34:	99                   	cltd   
c002bf35:	f7 7d 08             	idivl  0x8(%ebp)
c002bf38:	89 d1                	mov    %edx,%ecx
c002bf3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf3d:	99                   	cltd   
c002bf3e:	f7 7d 08             	idivl  0x8(%ebp)
c002bf41:	53                   	push   %ebx
c002bf42:	51                   	push   %ecx
c002bf43:	50                   	push   %eax
c002bf44:	68 28 18 03 c0       	push   $0xc0031828
c002bf49:	e8 6f f9 ff ff       	call   c002b8bd <msg>
c002bf4e:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < test.output_pos - output; i++) 
c002bf51:	ff 45 f4             	incl   -0xc(%ebp)
c002bf54:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bf57:	2b 45 f0             	sub    -0x10(%ebp),%eax
c002bf5a:	c1 f8 02             	sar    $0x2,%eax
c002bf5d:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002bf60:	7c a4                	jl     c002bf06 <test_sleep+0x15e>
  
  free (output);
c002bf62:	83 ec 0c             	sub    $0xc,%esp
c002bf65:	ff 75 f0             	push   -0x10(%ebp)
c002bf68:	e8 f2 77 ff ff       	call   c002375f <free>
c002bf6d:	83 c4 10             	add    $0x10,%esp
}
c002bf70:	90                   	nop
c002bf71:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bf74:	c9                   	leave  
c002bf75:	c3                   	ret    

c002bf76 <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *test_) 
{
c002bf76:	55                   	push   %ebp
c002bf77:	89 e5                	mov    %esp,%ebp
c002bf79:	53                   	push   %ebx
c002bf7a:	83 ec 14             	sub    $0x14,%esp
  struct sleep_test *test = test_;
c002bf7d:	8b 45 08             	mov    0x8(%ebp),%eax
c002bf80:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);
c002bf83:	83 ec 08             	sub    $0x8,%esp
c002bf86:	6a 00                	push   $0x0
c002bf88:	6a 01                	push   $0x1
c002bf8a:	e8 6f 7d ff ff       	call   c0023cfe <timer_sleep>
c002bf8f:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i <= test->iterations; i++) 
c002bf92:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002bf99:	eb 6d                	jmp    c002c008 <sleeper+0x92>
    {
      int64_t sleep_until = test->start + i * 10;
c002bf9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bf9e:	8b 08                	mov    (%eax),%ecx
c002bfa0:	8b 58 04             	mov    0x4(%eax),%ebx
c002bfa3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002bfa6:	89 d0                	mov    %edx,%eax
c002bfa8:	c1 e0 02             	shl    $0x2,%eax
c002bfab:	01 d0                	add    %edx,%eax
c002bfad:	01 c0                	add    %eax,%eax
c002bfaf:	99                   	cltd   
c002bfb0:	01 c8                	add    %ecx,%eax
c002bfb2:	11 da                	adc    %ebx,%edx
c002bfb4:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002bfb7:	89 55 ec             	mov    %edx,-0x14(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002bfba:	e8 eb 7c ff ff       	call   c0023caa <timer_ticks>
c002bfbf:	89 c1                	mov    %eax,%ecx
c002bfc1:	89 d3                	mov    %edx,%ebx
c002bfc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bfc6:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002bfc9:	29 c8                	sub    %ecx,%eax
c002bfcb:	19 da                	sbb    %ebx,%edx
c002bfcd:	83 ec 08             	sub    $0x8,%esp
c002bfd0:	52                   	push   %edx
c002bfd1:	50                   	push   %eax
c002bfd2:	e8 27 7d ff ff       	call   c0023cfe <timer_sleep>
c002bfd7:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = timer_ticks () - test->start;
c002bfda:	e8 cb 7c ff ff       	call   c0023caa <timer_ticks>
c002bfdf:	89 c1                	mov    %eax,%ecx
c002bfe1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bfe4:	8b 50 04             	mov    0x4(%eax),%edx
c002bfe7:	8b 00                	mov    (%eax),%eax
c002bfe9:	89 cb                	mov    %ecx,%ebx
c002bfeb:	29 c3                	sub    %eax,%ebx
c002bfed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bff0:	8b 40 0c             	mov    0xc(%eax),%eax
c002bff3:	8d 48 04             	lea    0x4(%eax),%ecx
c002bff6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002bff9:	89 4a 0c             	mov    %ecx,0xc(%edx)
c002bffc:	89 da                	mov    %ebx,%edx
c002bffe:	89 10                	mov    %edx,(%eax)
      thread_yield ();
c002c000:	e8 69 4d ff ff       	call   c0020d6e <thread_yield>
  for (i = 1; i <= test->iterations; i++) 
c002c005:	ff 45 f4             	incl   -0xc(%ebp)
c002c008:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c00b:	8b 40 08             	mov    0x8(%eax),%eax
c002c00e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002c011:	7e 88                	jle    c002bf9b <sleeper+0x25>
    }
}
c002c013:	90                   	nop
c002c014:	90                   	nop
c002c015:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c018:	c9                   	leave  
c002c019:	c3                   	ret    

c002c01a <test_alarm_priority>:
static int64_t wake_time;
static struct semaphore wait_sema;

void
test_alarm_priority (void) 
{
c002c01a:	55                   	push   %ebp
c002c01b:	89 e5                	mov    %esp,%ebp
c002c01d:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c020:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002c025:	83 f0 01             	xor    $0x1,%eax
c002c028:	84 c0                	test   %al,%al
c002c02a:	75 1e                	jne    c002c04a <test_alarm_priority+0x30>
c002c02c:	83 ec 0c             	sub    $0xc,%esp
c002c02f:	68 64 18 03 c0       	push   $0xc0031864
c002c034:	68 72 18 03 c0       	push   $0xc0031872
c002c039:	68 d0 18 03 c0       	push   $0xc00318d0
c002c03e:	6a 16                	push   $0x16
c002c040:	68 8c 18 03 c0       	push   $0xc003188c
c002c045:	e8 d4 d4 ff ff       	call   c002951e <debug_panic>

  wake_time = timer_ticks () + 5 * TIMER_FREQ;
c002c04a:	e8 5b 7c ff ff       	call   c0023caa <timer_ticks>
c002c04f:	05 f4 01 00 00       	add    $0x1f4,%eax
c002c054:	83 d2 00             	adc    $0x0,%edx
c002c057:	a3 f8 53 03 c0       	mov    %eax,0xc00353f8
c002c05c:	89 15 fc 53 03 c0    	mov    %edx,0xc00353fc
  sema_init (&wait_sema, 0);
c002c062:	83 ec 08             	sub    $0x8,%esp
c002c065:	6a 00                	push   $0x0
c002c067:	68 00 54 03 c0       	push   $0xc0035400
c002c06c:	e8 2b 67 ff ff       	call   c002279c <sema_init>
c002c071:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < 10; i++) 
c002c074:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002c07b:	eb 47                	jmp    c002c0c4 <test_alarm_priority+0xaa>
    {
      int priority = PRI_DEFAULT - (i + 5) % 10 - 1;
c002c07d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c080:	83 c0 05             	add    $0x5,%eax
c002c083:	b9 0a 00 00 00       	mov    $0xa,%ecx
c002c088:	99                   	cltd   
c002c089:	f7 f9                	idiv   %ecx
c002c08b:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002c090:	29 d0                	sub    %edx,%eax
c002c092:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002c095:	ff 75 f0             	push   -0x10(%ebp)
c002c098:	68 b1 18 03 c0       	push   $0xc00318b1
c002c09d:	6a 10                	push   $0x10
c002c09f:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c0a2:	50                   	push   %eax
c002c0a3:	e8 ab b0 ff ff       	call   c0027153 <snprintf>
c002c0a8:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, alarm_priority_thread, NULL);
c002c0ab:	6a 00                	push   $0x0
c002c0ad:	68 fd c0 02 c0       	push   $0xc002c0fd
c002c0b2:	ff 75 f0             	push   -0x10(%ebp)
c002c0b5:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c0b8:	50                   	push   %eax
c002c0b9:	e8 a3 49 ff ff       	call   c0020a61 <thread_create>
c002c0be:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002c0c1:	ff 45 f4             	incl   -0xc(%ebp)
c002c0c4:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002c0c8:	7e b3                	jle    c002c07d <test_alarm_priority+0x63>
    }

  thread_set_priority (PRI_MIN);
c002c0ca:	83 ec 0c             	sub    $0xc,%esp
c002c0cd:	6a 00                	push   $0x0
c002c0cf:	e8 aa 4d ff ff       	call   c0020e7e <thread_set_priority>
c002c0d4:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 10; i++)
c002c0d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002c0de:	eb 13                	jmp    c002c0f3 <test_alarm_priority+0xd9>
    sema_down (&wait_sema);
c002c0e0:	83 ec 0c             	sub    $0xc,%esp
c002c0e3:	68 00 54 03 c0       	push   $0xc0035400
c002c0e8:	e8 f6 66 ff ff       	call   c00227e3 <sema_down>
c002c0ed:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++)
c002c0f0:	ff 45 f4             	incl   -0xc(%ebp)
c002c0f3:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002c0f7:	7e e7                	jle    c002c0e0 <test_alarm_priority+0xc6>
}
c002c0f9:	90                   	nop
c002c0fa:	90                   	nop
c002c0fb:	c9                   	leave  
c002c0fc:	c3                   	ret    

c002c0fd <alarm_priority_thread>:

static void
alarm_priority_thread (void *aux UNUSED) 
{
c002c0fd:	55                   	push   %ebp
c002c0fe:	89 e5                	mov    %esp,%ebp
c002c100:	57                   	push   %edi
c002c101:	56                   	push   %esi
c002c102:	53                   	push   %ebx
c002c103:	83 ec 1c             	sub    $0x1c,%esp
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
c002c106:	e8 9f 7b ff ff       	call   c0023caa <timer_ticks>
c002c10b:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002c10e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  while (timer_elapsed (start_time) == 0)
c002c111:	eb 01                	jmp    c002c114 <alarm_priority_thread+0x17>
    continue;
c002c113:	90                   	nop
  while (timer_elapsed (start_time) == 0)
c002c114:	83 ec 08             	sub    $0x8,%esp
c002c117:	ff 75 e4             	push   -0x1c(%ebp)
c002c11a:	ff 75 e0             	push   -0x20(%ebp)
c002c11d:	e8 bd 7b ff ff       	call   c0023cdf <timer_elapsed>
c002c122:	83 c4 10             	add    $0x10,%esp
c002c125:	89 c3                	mov    %eax,%ebx
c002c127:	80 f7 00             	xor    $0x0,%bh
c002c12a:	89 de                	mov    %ebx,%esi
c002c12c:	89 d0                	mov    %edx,%eax
c002c12e:	80 f4 00             	xor    $0x0,%ah
c002c131:	89 c7                	mov    %eax,%edi
c002c133:	89 f8                	mov    %edi,%eax
c002c135:	09 f0                	or     %esi,%eax
c002c137:	85 c0                	test   %eax,%eax
c002c139:	74 d8                	je     c002c113 <alarm_priority_thread+0x16>

  /* Now we know we're at the very beginning of a timer tick, so
     we can call timer_sleep() without worrying about races
     between checking the time and a timer interrupt. */
  timer_sleep (wake_time - timer_ticks ());
c002c13b:	8b 35 f8 53 03 c0    	mov    0xc00353f8,%esi
c002c141:	8b 3d fc 53 03 c0    	mov    0xc00353fc,%edi
c002c147:	e8 5e 7b ff ff       	call   c0023caa <timer_ticks>
c002c14c:	89 c1                	mov    %eax,%ecx
c002c14e:	89 d3                	mov    %edx,%ebx
c002c150:	89 f0                	mov    %esi,%eax
c002c152:	89 fa                	mov    %edi,%edx
c002c154:	29 c8                	sub    %ecx,%eax
c002c156:	19 da                	sbb    %ebx,%edx
c002c158:	83 ec 08             	sub    $0x8,%esp
c002c15b:	52                   	push   %edx
c002c15c:	50                   	push   %eax
c002c15d:	e8 9c 7b ff ff       	call   c0023cfe <timer_sleep>
c002c162:	83 c4 10             	add    $0x10,%esp

  /* Print a message on wake-up. */
  msg ("Thread %s woke up.", thread_name ());
c002c165:	e8 fe 4a ff ff       	call   c0020c68 <thread_name>
c002c16a:	83 ec 08             	sub    $0x8,%esp
c002c16d:	50                   	push   %eax
c002c16e:	68 bd 18 03 c0       	push   $0xc00318bd
c002c173:	e8 45 f7 ff ff       	call   c002b8bd <msg>
c002c178:	83 c4 10             	add    $0x10,%esp

  sema_up (&wait_sema);
c002c17b:	83 ec 0c             	sub    $0xc,%esp
c002c17e:	68 00 54 03 c0       	push   $0xc0035400
c002c183:	e8 65 67 ff ff       	call   c00228ed <sema_up>
c002c188:	83 c4 10             	add    $0x10,%esp
}
c002c18b:	90                   	nop
c002c18c:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002c18f:	5b                   	pop    %ebx
c002c190:	5e                   	pop    %esi
c002c191:	5f                   	pop    %edi
c002c192:	5d                   	pop    %ebp
c002c193:	c3                   	ret    

c002c194 <test_alarm_zero>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_zero (void) 
{
c002c194:	55                   	push   %ebp
c002c195:	89 e5                	mov    %esp,%ebp
c002c197:	83 ec 08             	sub    $0x8,%esp
  timer_sleep (0);
c002c19a:	83 ec 08             	sub    $0x8,%esp
c002c19d:	6a 00                	push   $0x0
c002c19f:	6a 00                	push   $0x0
c002c1a1:	e8 58 7b ff ff       	call   c0023cfe <timer_sleep>
c002c1a6:	83 c4 10             	add    $0x10,%esp
  pass ();
c002c1a9:	e8 aa f7 ff ff       	call   c002b958 <pass>
}
c002c1ae:	90                   	nop
c002c1af:	c9                   	leave  
c002c1b0:	c3                   	ret    

c002c1b1 <test_alarm_negative>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_negative (void) 
{
c002c1b1:	55                   	push   %ebp
c002c1b2:	89 e5                	mov    %esp,%ebp
c002c1b4:	83 ec 08             	sub    $0x8,%esp
  timer_sleep (-100);
c002c1b7:	83 ec 08             	sub    $0x8,%esp
c002c1ba:	6a ff                	push   $0xffffffff
c002c1bc:	6a 9c                	push   $0xffffff9c
c002c1be:	e8 3b 7b ff ff       	call   c0023cfe <timer_sleep>
c002c1c3:	83 c4 10             	add    $0x10,%esp
  pass ();
c002c1c6:	e8 8d f7 ff ff       	call   c002b958 <pass>
}
c002c1cb:	90                   	nop
c002c1cc:	c9                   	leave  
c002c1cd:	c3                   	ret    

c002c1ce <test_priority_change>:

static thread_func changing_thread;

void
test_priority_change (void) 
{
c002c1ce:	55                   	push   %ebp
c002c1cf:	89 e5                	mov    %esp,%ebp
c002c1d1:	83 ec 08             	sub    $0x8,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c1d4:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002c1d9:	83 f0 01             	xor    $0x1,%eax
c002c1dc:	84 c0                	test   %al,%al
c002c1de:	75 1e                	jne    c002c1fe <test_priority_change+0x30>
c002c1e0:	83 ec 0c             	sub    $0xc,%esp
c002c1e3:	68 e4 18 03 c0       	push   $0xc00318e4
c002c1e8:	68 f2 18 03 c0       	push   $0xc00318f2
c002c1ed:	68 e8 19 03 c0       	push   $0xc00319e8
c002c1f2:	6a 10                	push   $0x10
c002c1f4:	68 0c 19 03 c0       	push   $0xc003190c
c002c1f9:	e8 20 d3 ff ff       	call   c002951e <debug_panic>

  msg ("Creating a high-priority thread 2.");
c002c1fe:	83 ec 0c             	sub    $0xc,%esp
c002c201:	68 34 19 03 c0       	push   $0xc0031934
c002c206:	e8 b2 f6 ff ff       	call   c002b8bd <msg>
c002c20b:	83 c4 10             	add    $0x10,%esp
  thread_create ("thread 2", PRI_DEFAULT + 1, changing_thread, NULL);
c002c20e:	6a 00                	push   $0x0
c002c210:	68 54 c2 02 c0       	push   $0xc002c254
c002c215:	6a 20                	push   $0x20
c002c217:	68 57 19 03 c0       	push   $0xc0031957
c002c21c:	e8 40 48 ff ff       	call   c0020a61 <thread_create>
c002c221:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just lowered its priority.");
c002c224:	83 ec 0c             	sub    $0xc,%esp
c002c227:	68 60 19 03 c0       	push   $0xc0031960
c002c22c:	e8 8c f6 ff ff       	call   c002b8bd <msg>
c002c231:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 2);
c002c234:	83 ec 0c             	sub    $0xc,%esp
c002c237:	6a 1d                	push   $0x1d
c002c239:	e8 40 4c ff ff       	call   c0020e7e <thread_set_priority>
c002c23e:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just exited.");
c002c241:	83 ec 0c             	sub    $0xc,%esp
c002c244:	68 90 19 03 c0       	push   $0xc0031990
c002c249:	e8 6f f6 ff ff       	call   c002b8bd <msg>
c002c24e:	83 c4 10             	add    $0x10,%esp
}
c002c251:	90                   	nop
c002c252:	c9                   	leave  
c002c253:	c3                   	ret    

c002c254 <changing_thread>:

static void
changing_thread (void *aux UNUSED) 
{
c002c254:	55                   	push   %ebp
c002c255:	89 e5                	mov    %esp,%ebp
c002c257:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread 2 now lowering priority.");
c002c25a:	83 ec 0c             	sub    $0xc,%esp
c002c25d:	68 b4 19 03 c0       	push   $0xc00319b4
c002c262:	e8 56 f6 ff ff       	call   c002b8bd <msg>
c002c267:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 1);
c002c26a:	83 ec 0c             	sub    $0xc,%esp
c002c26d:	6a 1e                	push   $0x1e
c002c26f:	e8 0a 4c ff ff       	call   c0020e7e <thread_set_priority>
c002c274:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 exiting.");
c002c277:	83 ec 0c             	sub    $0xc,%esp
c002c27a:	68 d4 19 03 c0       	push   $0xc00319d4
c002c27f:	e8 39 f6 ff ff       	call   c002b8bd <msg>
c002c284:	83 c4 10             	add    $0x10,%esp
}
c002c287:	90                   	nop
c002c288:	c9                   	leave  
c002c289:	c3                   	ret    

c002c28a <test_priority_donate_one>:
static thread_func acquire1_thread_func;
static thread_func acquire2_thread_func;

void
test_priority_donate_one (void) 
{
c002c28a:	55                   	push   %ebp
c002c28b:	89 e5                	mov    %esp,%ebp
c002c28d:	83 ec 28             	sub    $0x28,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c290:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002c295:	83 f0 01             	xor    $0x1,%eax
c002c298:	84 c0                	test   %al,%al
c002c29a:	75 1e                	jne    c002c2ba <test_priority_donate_one+0x30>
c002c29c:	83 ec 0c             	sub    $0xc,%esp
c002c29f:	68 00 1a 03 c0       	push   $0xc0031a00
c002c2a4:	68 0e 1a 03 c0       	push   $0xc0031a0e
c002c2a9:	68 90 1b 03 c0       	push   $0xc0031b90
c002c2ae:	6a 1b                	push   $0x1b
c002c2b0:	68 28 1a 03 c0       	push   $0xc0031a28
c002c2b5:	e8 64 d2 ff ff       	call   c002951e <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c2ba:	e8 d3 4b ff ff       	call   c0020e92 <thread_get_priority>
c002c2bf:	83 f8 1f             	cmp    $0x1f,%eax
c002c2c2:	74 1e                	je     c002c2e2 <test_priority_donate_one+0x58>
c002c2c4:	83 ec 0c             	sub    $0xc,%esp
c002c2c7:	68 54 1a 03 c0       	push   $0xc0031a54
c002c2cc:	68 0e 1a 03 c0       	push   $0xc0031a0e
c002c2d1:	68 90 1b 03 c0       	push   $0xc0031b90
c002c2d6:	6a 1e                	push   $0x1e
c002c2d8:	68 28 1a 03 c0       	push   $0xc0031a28
c002c2dd:	e8 3c d2 ff ff       	call   c002951e <debug_panic>

  lock_init (&lock);
c002c2e2:	83 ec 0c             	sub    $0xc,%esp
c002c2e5:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c2e8:	50                   	push   %eax
c002c2e9:	e8 67 67 ff ff       	call   c0022a55 <lock_init>
c002c2ee:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002c2f1:	83 ec 0c             	sub    $0xc,%esp
c002c2f4:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c2f7:	50                   	push   %eax
c002c2f8:	e8 a5 67 ff ff       	call   c0022aa2 <lock_acquire>
c002c2fd:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire1", PRI_DEFAULT + 1, acquire1_thread_func, &lock);
c002c300:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c303:	50                   	push   %eax
c002c304:	68 92 c3 02 c0       	push   $0xc002c392
c002c309:	6a 20                	push   $0x20
c002c30b:	68 7a 1a 03 c0       	push   $0xc0031a7a
c002c310:	e8 4c 47 ff ff       	call   c0020a61 <thread_create>
c002c315:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002c318:	e8 75 4b ff ff       	call   c0020e92 <thread_get_priority>
c002c31d:	83 ec 04             	sub    $0x4,%esp
c002c320:	50                   	push   %eax
c002c321:	6a 20                	push   $0x20
c002c323:	68 84 1a 03 c0       	push   $0xc0031a84
c002c328:	e8 90 f5 ff ff       	call   c002b8bd <msg>
c002c32d:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());
  thread_create ("acquire2", PRI_DEFAULT + 2, acquire2_thread_func, &lock);
c002c330:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c333:	50                   	push   %eax
c002c334:	68 dd c3 02 c0       	push   $0xc002c3dd
c002c339:	6a 21                	push   $0x21
c002c33b:	68 bf 1a 03 c0       	push   $0xc0031abf
c002c340:	e8 1c 47 ff ff       	call   c0020a61 <thread_create>
c002c345:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002c348:	e8 45 4b ff ff       	call   c0020e92 <thread_get_priority>
c002c34d:	83 ec 04             	sub    $0x4,%esp
c002c350:	50                   	push   %eax
c002c351:	6a 21                	push   $0x21
c002c353:	68 84 1a 03 c0       	push   $0xc0031a84
c002c358:	e8 60 f5 ff ff       	call   c002b8bd <msg>
c002c35d:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  lock_release (&lock);
c002c360:	83 ec 0c             	sub    $0xc,%esp
c002c363:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c366:	50                   	push   %eax
c002c367:	e8 72 68 ff ff       	call   c0022bde <lock_release>
c002c36c:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2, acquire1 must already have finished, in that order.");
c002c36f:	83 ec 0c             	sub    $0xc,%esp
c002c372:	68 c8 1a 03 c0       	push   $0xc0031ac8
c002c377:	e8 41 f5 ff ff       	call   c002b8bd <msg>
c002c37c:	83 c4 10             	add    $0x10,%esp
  msg ("This should be the last line before finishing this test.");
c002c37f:	83 ec 0c             	sub    $0xc,%esp
c002c382:	68 08 1b 03 c0       	push   $0xc0031b08
c002c387:	e8 31 f5 ff ff       	call   c002b8bd <msg>
c002c38c:	83 c4 10             	add    $0x10,%esp
}
c002c38f:	90                   	nop
c002c390:	c9                   	leave  
c002c391:	c3                   	ret    

c002c392 <acquire1_thread_func>:

static void
acquire1_thread_func (void *lock_) 
{
c002c392:	55                   	push   %ebp
c002c393:	89 e5                	mov    %esp,%ebp
c002c395:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c398:	8b 45 08             	mov    0x8(%ebp),%eax
c002c39b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c39e:	83 ec 0c             	sub    $0xc,%esp
c002c3a1:	ff 75 f4             	push   -0xc(%ebp)
c002c3a4:	e8 f9 66 ff ff       	call   c0022aa2 <lock_acquire>
c002c3a9:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: got the lock");
c002c3ac:	83 ec 0c             	sub    $0xc,%esp
c002c3af:	68 41 1b 03 c0       	push   $0xc0031b41
c002c3b4:	e8 04 f5 ff ff       	call   c002b8bd <msg>
c002c3b9:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c3bc:	83 ec 0c             	sub    $0xc,%esp
c002c3bf:	ff 75 f4             	push   -0xc(%ebp)
c002c3c2:	e8 17 68 ff ff       	call   c0022bde <lock_release>
c002c3c7:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: done");
c002c3ca:	83 ec 0c             	sub    $0xc,%esp
c002c3cd:	68 58 1b 03 c0       	push   $0xc0031b58
c002c3d2:	e8 e6 f4 ff ff       	call   c002b8bd <msg>
c002c3d7:	83 c4 10             	add    $0x10,%esp
}
c002c3da:	90                   	nop
c002c3db:	c9                   	leave  
c002c3dc:	c3                   	ret    

c002c3dd <acquire2_thread_func>:

static void
acquire2_thread_func (void *lock_) 
{
c002c3dd:	55                   	push   %ebp
c002c3de:	89 e5                	mov    %esp,%ebp
c002c3e0:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c3e3:	8b 45 08             	mov    0x8(%ebp),%eax
c002c3e6:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c3e9:	83 ec 0c             	sub    $0xc,%esp
c002c3ec:	ff 75 f4             	push   -0xc(%ebp)
c002c3ef:	e8 ae 66 ff ff       	call   c0022aa2 <lock_acquire>
c002c3f4:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: got the lock");
c002c3f7:	83 ec 0c             	sub    $0xc,%esp
c002c3fa:	68 67 1b 03 c0       	push   $0xc0031b67
c002c3ff:	e8 b9 f4 ff ff       	call   c002b8bd <msg>
c002c404:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c407:	83 ec 0c             	sub    $0xc,%esp
c002c40a:	ff 75 f4             	push   -0xc(%ebp)
c002c40d:	e8 cc 67 ff ff       	call   c0022bde <lock_release>
c002c412:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: done");
c002c415:	83 ec 0c             	sub    $0xc,%esp
c002c418:	68 7e 1b 03 c0       	push   $0xc0031b7e
c002c41d:	e8 9b f4 ff ff       	call   c002b8bd <msg>
c002c422:	83 c4 10             	add    $0x10,%esp
}
c002c425:	90                   	nop
c002c426:	c9                   	leave  
c002c427:	c3                   	ret    

c002c428 <test_priority_donate_multiple>:
static thread_func a_thread_func;
static thread_func b_thread_func;

void
test_priority_donate_multiple (void) 
{
c002c428:	55                   	push   %ebp
c002c429:	89 e5                	mov    %esp,%ebp
c002c42b:	83 ec 38             	sub    $0x38,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c42e:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002c433:	83 f0 01             	xor    $0x1,%eax
c002c436:	84 c0                	test   %al,%al
c002c438:	75 1e                	jne    c002c458 <test_priority_donate_multiple+0x30>
c002c43a:	83 ec 0c             	sub    $0xc,%esp
c002c43d:	68 ac 1b 03 c0       	push   $0xc0031bac
c002c442:	68 ba 1b 03 c0       	push   $0xc0031bba
c002c447:	68 10 1d 03 c0       	push   $0xc0031d10
c002c44c:	6a 1b                	push   $0x1b
c002c44e:	68 d4 1b 03 c0       	push   $0xc0031bd4
c002c453:	e8 c6 d0 ff ff       	call   c002951e <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c458:	e8 35 4a ff ff       	call   c0020e92 <thread_get_priority>
c002c45d:	83 f8 1f             	cmp    $0x1f,%eax
c002c460:	74 1e                	je     c002c480 <test_priority_donate_multiple+0x58>
c002c462:	83 ec 0c             	sub    $0xc,%esp
c002c465:	68 04 1c 03 c0       	push   $0xc0031c04
c002c46a:	68 ba 1b 03 c0       	push   $0xc0031bba
c002c46f:	68 10 1d 03 c0       	push   $0xc0031d10
c002c474:	6a 1e                	push   $0x1e
c002c476:	68 d4 1b 03 c0       	push   $0xc0031bd4
c002c47b:	e8 9e d0 ff ff       	call   c002951e <debug_panic>

  lock_init (&a);
c002c480:	83 ec 0c             	sub    $0xc,%esp
c002c483:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c486:	50                   	push   %eax
c002c487:	e8 c9 65 ff ff       	call   c0022a55 <lock_init>
c002c48c:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002c48f:	83 ec 0c             	sub    $0xc,%esp
c002c492:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c495:	50                   	push   %eax
c002c496:	e8 ba 65 ff ff       	call   c0022a55 <lock_init>
c002c49b:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002c49e:	83 ec 0c             	sub    $0xc,%esp
c002c4a1:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c4a4:	50                   	push   %eax
c002c4a5:	e8 f8 65 ff ff       	call   c0022aa2 <lock_acquire>
c002c4aa:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002c4ad:	83 ec 0c             	sub    $0xc,%esp
c002c4b0:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c4b3:	50                   	push   %eax
c002c4b4:	e8 e9 65 ff ff       	call   c0022aa2 <lock_acquire>
c002c4b9:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 1, a_thread_func, &a);
c002c4bc:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c4bf:	50                   	push   %eax
c002c4c0:	68 8d c5 02 c0       	push   $0xc002c58d
c002c4c5:	6a 20                	push   $0x20
c002c4c7:	68 2a 1c 03 c0       	push   $0xc0031c2a
c002c4cc:	e8 90 45 ff ff       	call   c0020a61 <thread_create>
c002c4d1:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c4d4:	e8 b9 49 ff ff       	call   c0020e92 <thread_get_priority>
c002c4d9:	83 ec 04             	sub    $0x4,%esp
c002c4dc:	50                   	push   %eax
c002c4dd:	6a 20                	push   $0x20
c002c4df:	68 2c 1c 03 c0       	push   $0xc0031c2c
c002c4e4:	e8 d4 f3 ff ff       	call   c002b8bd <msg>
c002c4e9:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("b", PRI_DEFAULT + 2, b_thread_func, &b);
c002c4ec:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c4ef:	50                   	push   %eax
c002c4f0:	68 d8 c5 02 c0       	push   $0xc002c5d8
c002c4f5:	6a 21                	push   $0x21
c002c4f7:	68 67 1c 03 c0       	push   $0xc0031c67
c002c4fc:	e8 60 45 ff ff       	call   c0020a61 <thread_create>
c002c501:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c504:	e8 89 49 ff ff       	call   c0020e92 <thread_get_priority>
c002c509:	83 ec 04             	sub    $0x4,%esp
c002c50c:	50                   	push   %eax
c002c50d:	6a 21                	push   $0x21
c002c50f:	68 2c 1c 03 c0       	push   $0xc0031c2c
c002c514:	e8 a4 f3 ff ff       	call   c002b8bd <msg>
c002c519:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&b);
c002c51c:	83 ec 0c             	sub    $0xc,%esp
c002c51f:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c522:	50                   	push   %eax
c002c523:	e8 b6 66 ff ff       	call   c0022bde <lock_release>
c002c528:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b should have just finished.");
c002c52b:	83 ec 0c             	sub    $0xc,%esp
c002c52e:	68 6c 1c 03 c0       	push   $0xc0031c6c
c002c533:	e8 85 f3 ff ff       	call   c002b8bd <msg>
c002c538:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c53b:	e8 52 49 ff ff       	call   c0020e92 <thread_get_priority>
c002c540:	83 ec 04             	sub    $0x4,%esp
c002c543:	50                   	push   %eax
c002c544:	6a 20                	push   $0x20
c002c546:	68 2c 1c 03 c0       	push   $0xc0031c2c
c002c54b:	e8 6d f3 ff ff       	call   c002b8bd <msg>
c002c550:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  lock_release (&a);
c002c553:	83 ec 0c             	sub    $0xc,%esp
c002c556:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c559:	50                   	push   %eax
c002c55a:	e8 7f 66 ff ff       	call   c0022bde <lock_release>
c002c55f:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a should have just finished.");
c002c562:	83 ec 0c             	sub    $0xc,%esp
c002c565:	68 90 1c 03 c0       	push   $0xc0031c90
c002c56a:	e8 4e f3 ff ff       	call   c002b8bd <msg>
c002c56f:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c572:	e8 1b 49 ff ff       	call   c0020e92 <thread_get_priority>
c002c577:	83 ec 04             	sub    $0x4,%esp
c002c57a:	50                   	push   %eax
c002c57b:	6a 1f                	push   $0x1f
c002c57d:	68 2c 1c 03 c0       	push   $0xc0031c2c
c002c582:	e8 36 f3 ff ff       	call   c002b8bd <msg>
c002c587:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002c58a:	90                   	nop
c002c58b:	c9                   	leave  
c002c58c:	c3                   	ret    

c002c58d <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002c58d:	55                   	push   %ebp
c002c58e:	89 e5                	mov    %esp,%ebp
c002c590:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c593:	8b 45 08             	mov    0x8(%ebp),%eax
c002c596:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c599:	83 ec 0c             	sub    $0xc,%esp
c002c59c:	ff 75 f4             	push   -0xc(%ebp)
c002c59f:	e8 fe 64 ff ff       	call   c0022aa2 <lock_acquire>
c002c5a4:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002c5a7:	83 ec 0c             	sub    $0xc,%esp
c002c5aa:	68 b4 1c 03 c0       	push   $0xc0031cb4
c002c5af:	e8 09 f3 ff ff       	call   c002b8bd <msg>
c002c5b4:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c5b7:	83 ec 0c             	sub    $0xc,%esp
c002c5ba:	ff 75 f4             	push   -0xc(%ebp)
c002c5bd:	e8 1c 66 ff ff       	call   c0022bde <lock_release>
c002c5c2:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002c5c5:	83 ec 0c             	sub    $0xc,%esp
c002c5c8:	68 ce 1c 03 c0       	push   $0xc0031cce
c002c5cd:	e8 eb f2 ff ff       	call   c002b8bd <msg>
c002c5d2:	83 c4 10             	add    $0x10,%esp
}
c002c5d5:	90                   	nop
c002c5d6:	c9                   	leave  
c002c5d7:	c3                   	ret    

c002c5d8 <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002c5d8:	55                   	push   %ebp
c002c5d9:	89 e5                	mov    %esp,%ebp
c002c5db:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c5de:	8b 45 08             	mov    0x8(%ebp),%eax
c002c5e1:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c5e4:	83 ec 0c             	sub    $0xc,%esp
c002c5e7:	ff 75 f4             	push   -0xc(%ebp)
c002c5ea:	e8 b3 64 ff ff       	call   c0022aa2 <lock_acquire>
c002c5ef:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002c5f2:	83 ec 0c             	sub    $0xc,%esp
c002c5f5:	68 e1 1c 03 c0       	push   $0xc0031ce1
c002c5fa:	e8 be f2 ff ff       	call   c002b8bd <msg>
c002c5ff:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c602:	83 ec 0c             	sub    $0xc,%esp
c002c605:	ff 75 f4             	push   -0xc(%ebp)
c002c608:	e8 d1 65 ff ff       	call   c0022bde <lock_release>
c002c60d:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002c610:	83 ec 0c             	sub    $0xc,%esp
c002c613:	68 fb 1c 03 c0       	push   $0xc0031cfb
c002c618:	e8 a0 f2 ff ff       	call   c002b8bd <msg>
c002c61d:	83 c4 10             	add    $0x10,%esp
}
c002c620:	90                   	nop
c002c621:	c9                   	leave  
c002c622:	c3                   	ret    

c002c623 <test_priority_donate_multiple2>:
static thread_func b_thread_func;
static thread_func c_thread_func;

void
test_priority_donate_multiple2 (void) 
{
c002c623:	55                   	push   %ebp
c002c624:	89 e5                	mov    %esp,%ebp
c002c626:	83 ec 38             	sub    $0x38,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c629:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002c62e:	83 f0 01             	xor    $0x1,%eax
c002c631:	84 c0                	test   %al,%al
c002c633:	75 1e                	jne    c002c653 <test_priority_donate_multiple2+0x30>
c002c635:	83 ec 0c             	sub    $0xc,%esp
c002c638:	68 30 1d 03 c0       	push   $0xc0031d30
c002c63d:	68 3e 1d 03 c0       	push   $0xc0031d3e
c002c642:	68 98 1e 03 c0       	push   $0xc0031e98
c002c647:	6a 21                	push   $0x21
c002c649:	68 58 1d 03 c0       	push   $0xc0031d58
c002c64e:	e8 cb ce ff ff       	call   c002951e <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c653:	e8 3a 48 ff ff       	call   c0020e92 <thread_get_priority>
c002c658:	83 f8 1f             	cmp    $0x1f,%eax
c002c65b:	74 1e                	je     c002c67b <test_priority_donate_multiple2+0x58>
c002c65d:	83 ec 0c             	sub    $0xc,%esp
c002c660:	68 88 1d 03 c0       	push   $0xc0031d88
c002c665:	68 3e 1d 03 c0       	push   $0xc0031d3e
c002c66a:	68 98 1e 03 c0       	push   $0xc0031e98
c002c66f:	6a 24                	push   $0x24
c002c671:	68 58 1d 03 c0       	push   $0xc0031d58
c002c676:	e8 a3 ce ff ff       	call   c002951e <debug_panic>

  lock_init (&a);
c002c67b:	83 ec 0c             	sub    $0xc,%esp
c002c67e:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c681:	50                   	push   %eax
c002c682:	e8 ce 63 ff ff       	call   c0022a55 <lock_init>
c002c687:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002c68a:	83 ec 0c             	sub    $0xc,%esp
c002c68d:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c690:	50                   	push   %eax
c002c691:	e8 bf 63 ff ff       	call   c0022a55 <lock_init>
c002c696:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002c699:	83 ec 0c             	sub    $0xc,%esp
c002c69c:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c69f:	50                   	push   %eax
c002c6a0:	e8 fd 63 ff ff       	call   c0022aa2 <lock_acquire>
c002c6a5:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002c6a8:	83 ec 0c             	sub    $0xc,%esp
c002c6ab:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c6ae:	50                   	push   %eax
c002c6af:	e8 ee 63 ff ff       	call   c0022aa2 <lock_acquire>
c002c6b4:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 3, a_thread_func, &a);
c002c6b7:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c6ba:	50                   	push   %eax
c002c6bb:	68 8e c7 02 c0       	push   $0xc002c78e
c002c6c0:	6a 22                	push   $0x22
c002c6c2:	68 ae 1d 03 c0       	push   $0xc0031dae
c002c6c7:	e8 95 43 ff ff       	call   c0020a61 <thread_create>
c002c6cc:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c6cf:	e8 be 47 ff ff       	call   c0020e92 <thread_get_priority>
c002c6d4:	83 ec 04             	sub    $0x4,%esp
c002c6d7:	50                   	push   %eax
c002c6d8:	6a 22                	push   $0x22
c002c6da:	68 b0 1d 03 c0       	push   $0xc0031db0
c002c6df:	e8 d9 f1 ff ff       	call   c002b8bd <msg>
c002c6e4:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 3, thread_get_priority ());

  thread_create ("c", PRI_DEFAULT + 1, c_thread_func, NULL);
c002c6e7:	6a 00                	push   $0x0
c002c6e9:	68 24 c8 02 c0       	push   $0xc002c824
c002c6ee:	6a 20                	push   $0x20
c002c6f0:	68 eb 1d 03 c0       	push   $0xc0031deb
c002c6f5:	e8 67 43 ff ff       	call   c0020a61 <thread_create>
c002c6fa:	83 c4 10             	add    $0x10,%esp

  thread_create ("b", PRI_DEFAULT + 5, b_thread_func, &b);
c002c6fd:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c700:	50                   	push   %eax
c002c701:	68 d9 c7 02 c0       	push   $0xc002c7d9
c002c706:	6a 24                	push   $0x24
c002c708:	68 ed 1d 03 c0       	push   $0xc0031ded
c002c70d:	e8 4f 43 ff ff       	call   c0020a61 <thread_create>
c002c712:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c715:	e8 78 47 ff ff       	call   c0020e92 <thread_get_priority>
c002c71a:	83 ec 04             	sub    $0x4,%esp
c002c71d:	50                   	push   %eax
c002c71e:	6a 24                	push   $0x24
c002c720:	68 b0 1d 03 c0       	push   $0xc0031db0
c002c725:	e8 93 f1 ff ff       	call   c002b8bd <msg>
c002c72a:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&a);
c002c72d:	83 ec 0c             	sub    $0xc,%esp
c002c730:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c733:	50                   	push   %eax
c002c734:	e8 a5 64 ff ff       	call   c0022bde <lock_release>
c002c739:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c73c:	e8 51 47 ff ff       	call   c0020e92 <thread_get_priority>
c002c741:	83 ec 04             	sub    $0x4,%esp
c002c744:	50                   	push   %eax
c002c745:	6a 24                	push   $0x24
c002c747:	68 b0 1d 03 c0       	push   $0xc0031db0
c002c74c:	e8 6c f1 ff ff       	call   c002b8bd <msg>
c002c751:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&b);
c002c754:	83 ec 0c             	sub    $0xc,%esp
c002c757:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c75a:	50                   	push   %eax
c002c75b:	e8 7e 64 ff ff       	call   c0022bde <lock_release>
c002c760:	83 c4 10             	add    $0x10,%esp
  msg ("Threads b, a, c should have just finished, in that order.");
c002c763:	83 ec 0c             	sub    $0xc,%esp
c002c766:	68 f0 1d 03 c0       	push   $0xc0031df0
c002c76b:	e8 4d f1 ff ff       	call   c002b8bd <msg>
c002c770:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c773:	e8 1a 47 ff ff       	call   c0020e92 <thread_get_priority>
c002c778:	83 ec 04             	sub    $0x4,%esp
c002c77b:	50                   	push   %eax
c002c77c:	6a 1f                	push   $0x1f
c002c77e:	68 b0 1d 03 c0       	push   $0xc0031db0
c002c783:	e8 35 f1 ff ff       	call   c002b8bd <msg>
c002c788:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002c78b:	90                   	nop
c002c78c:	c9                   	leave  
c002c78d:	c3                   	ret    

c002c78e <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002c78e:	55                   	push   %ebp
c002c78f:	89 e5                	mov    %esp,%ebp
c002c791:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c794:	8b 45 08             	mov    0x8(%ebp),%eax
c002c797:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c79a:	83 ec 0c             	sub    $0xc,%esp
c002c79d:	ff 75 f4             	push   -0xc(%ebp)
c002c7a0:	e8 fd 62 ff ff       	call   c0022aa2 <lock_acquire>
c002c7a5:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002c7a8:	83 ec 0c             	sub    $0xc,%esp
c002c7ab:	68 2a 1e 03 c0       	push   $0xc0031e2a
c002c7b0:	e8 08 f1 ff ff       	call   c002b8bd <msg>
c002c7b5:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c7b8:	83 ec 0c             	sub    $0xc,%esp
c002c7bb:	ff 75 f4             	push   -0xc(%ebp)
c002c7be:	e8 1b 64 ff ff       	call   c0022bde <lock_release>
c002c7c3:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002c7c6:	83 ec 0c             	sub    $0xc,%esp
c002c7c9:	68 44 1e 03 c0       	push   $0xc0031e44
c002c7ce:	e8 ea f0 ff ff       	call   c002b8bd <msg>
c002c7d3:	83 c4 10             	add    $0x10,%esp
}
c002c7d6:	90                   	nop
c002c7d7:	c9                   	leave  
c002c7d8:	c3                   	ret    

c002c7d9 <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002c7d9:	55                   	push   %ebp
c002c7da:	89 e5                	mov    %esp,%ebp
c002c7dc:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c7df:	8b 45 08             	mov    0x8(%ebp),%eax
c002c7e2:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c7e5:	83 ec 0c             	sub    $0xc,%esp
c002c7e8:	ff 75 f4             	push   -0xc(%ebp)
c002c7eb:	e8 b2 62 ff ff       	call   c0022aa2 <lock_acquire>
c002c7f0:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002c7f3:	83 ec 0c             	sub    $0xc,%esp
c002c7f6:	68 57 1e 03 c0       	push   $0xc0031e57
c002c7fb:	e8 bd f0 ff ff       	call   c002b8bd <msg>
c002c800:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c803:	83 ec 0c             	sub    $0xc,%esp
c002c806:	ff 75 f4             	push   -0xc(%ebp)
c002c809:	e8 d0 63 ff ff       	call   c0022bde <lock_release>
c002c80e:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002c811:	83 ec 0c             	sub    $0xc,%esp
c002c814:	68 71 1e 03 c0       	push   $0xc0031e71
c002c819:	e8 9f f0 ff ff       	call   c002b8bd <msg>
c002c81e:	83 c4 10             	add    $0x10,%esp
}
c002c821:	90                   	nop
c002c822:	c9                   	leave  
c002c823:	c3                   	ret    

c002c824 <c_thread_func>:

static void
c_thread_func (void *a_ UNUSED) 
{
c002c824:	55                   	push   %ebp
c002c825:	89 e5                	mov    %esp,%ebp
c002c827:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread c finished.");
c002c82a:	83 ec 0c             	sub    $0xc,%esp
c002c82d:	68 84 1e 03 c0       	push   $0xc0031e84
c002c832:	e8 86 f0 ff ff       	call   c002b8bd <msg>
c002c837:	83 c4 10             	add    $0x10,%esp
}
c002c83a:	90                   	nop
c002c83b:	c9                   	leave  
c002c83c:	c3                   	ret    

c002c83d <test_priority_donate_nest>:
static thread_func medium_thread_func;
static thread_func high_thread_func;

void
test_priority_donate_nest (void) 
{
c002c83d:	55                   	push   %ebp
c002c83e:	89 e5                	mov    %esp,%ebp
c002c840:	83 ec 48             	sub    $0x48,%esp
  struct lock a, b;
  struct locks locks;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c843:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002c848:	83 f0 01             	xor    $0x1,%eax
c002c84b:	84 c0                	test   %al,%al
c002c84d:	75 1e                	jne    c002c86d <test_priority_donate_nest+0x30>
c002c84f:	83 ec 0c             	sub    $0xc,%esp
c002c852:	68 b8 1e 03 c0       	push   $0xc0031eb8
c002c857:	68 c6 1e 03 c0       	push   $0xc0031ec6
c002c85c:	68 74 20 03 c0       	push   $0xc0032074
c002c861:	6a 22                	push   $0x22
c002c863:	68 e0 1e 03 c0       	push   $0xc0031ee0
c002c868:	e8 b1 cc ff ff       	call   c002951e <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c86d:	e8 20 46 ff ff       	call   c0020e92 <thread_get_priority>
c002c872:	83 f8 1f             	cmp    $0x1f,%eax
c002c875:	74 1e                	je     c002c895 <test_priority_donate_nest+0x58>
c002c877:	83 ec 0c             	sub    $0xc,%esp
c002c87a:	68 0c 1f 03 c0       	push   $0xc0031f0c
c002c87f:	68 c6 1e 03 c0       	push   $0xc0031ec6
c002c884:	68 74 20 03 c0       	push   $0xc0032074
c002c889:	6a 25                	push   $0x25
c002c88b:	68 e0 1e 03 c0       	push   $0xc0031ee0
c002c890:	e8 89 cc ff ff       	call   c002951e <debug_panic>

  lock_init (&a);
c002c895:	83 ec 0c             	sub    $0xc,%esp
c002c898:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c89b:	50                   	push   %eax
c002c89c:	e8 b4 61 ff ff       	call   c0022a55 <lock_init>
c002c8a1:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002c8a4:	83 ec 0c             	sub    $0xc,%esp
c002c8a7:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c8aa:	50                   	push   %eax
c002c8ab:	e8 a5 61 ff ff       	call   c0022a55 <lock_init>
c002c8b0:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002c8b3:	83 ec 0c             	sub    $0xc,%esp
c002c8b6:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c8b9:	50                   	push   %eax
c002c8ba:	e8 e3 61 ff ff       	call   c0022aa2 <lock_acquire>
c002c8bf:	83 c4 10             	add    $0x10,%esp

  locks.a = &a;
c002c8c2:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c8c5:	89 45 c0             	mov    %eax,-0x40(%ebp)
  locks.b = &b;
c002c8c8:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c8cb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  thread_create ("medium", PRI_DEFAULT + 1, medium_thread_func, &locks);
c002c8ce:	8d 45 c0             	lea    -0x40(%ebp),%eax
c002c8d1:	50                   	push   %eax
c002c8d2:	68 77 c9 02 c0       	push   $0xc002c977
c002c8d7:	6a 20                	push   $0x20
c002c8d9:	68 32 1f 03 c0       	push   $0xc0031f32
c002c8de:	e8 7e 41 ff ff       	call   c0020a61 <thread_create>
c002c8e3:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002c8e6:	e8 83 44 ff ff       	call   c0020d6e <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002c8eb:	e8 a2 45 ff ff       	call   c0020e92 <thread_get_priority>
c002c8f0:	83 ec 04             	sub    $0x4,%esp
c002c8f3:	50                   	push   %eax
c002c8f4:	6a 20                	push   $0x20
c002c8f6:	68 3c 1f 03 c0       	push   $0xc0031f3c
c002c8fb:	e8 bd ef ff ff       	call   c002b8bd <msg>
c002c900:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("high", PRI_DEFAULT + 2, high_thread_func, &b);
c002c903:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c906:	50                   	push   %eax
c002c907:	68 1e ca 02 c0       	push   $0xc002ca1e
c002c90c:	6a 21                	push   $0x21
c002c90e:	68 76 1f 03 c0       	push   $0xc0031f76
c002c913:	e8 49 41 ff ff       	call   c0020a61 <thread_create>
c002c918:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002c91b:	e8 4e 44 ff ff       	call   c0020d6e <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002c920:	e8 6d 45 ff ff       	call   c0020e92 <thread_get_priority>
c002c925:	83 ec 04             	sub    $0x4,%esp
c002c928:	50                   	push   %eax
c002c929:	6a 21                	push   $0x21
c002c92b:	68 3c 1f 03 c0       	push   $0xc0031f3c
c002c930:	e8 88 ef ff ff       	call   c002b8bd <msg>
c002c935:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&a);
c002c938:	83 ec 0c             	sub    $0xc,%esp
c002c93b:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c93e:	50                   	push   %eax
c002c93f:	e8 9a 62 ff ff       	call   c0022bde <lock_release>
c002c944:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002c947:	e8 22 44 ff ff       	call   c0020d6e <thread_yield>
  msg ("Medium thread should just have finished.");
c002c94c:	83 ec 0c             	sub    $0xc,%esp
c002c94f:	68 7c 1f 03 c0       	push   $0xc0031f7c
c002c954:	e8 64 ef ff ff       	call   c002b8bd <msg>
c002c959:	83 c4 10             	add    $0x10,%esp
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002c95c:	e8 31 45 ff ff       	call   c0020e92 <thread_get_priority>
c002c961:	83 ec 04             	sub    $0x4,%esp
c002c964:	50                   	push   %eax
c002c965:	6a 1f                	push   $0x1f
c002c967:	68 3c 1f 03 c0       	push   $0xc0031f3c
c002c96c:	e8 4c ef ff ff       	call   c002b8bd <msg>
c002c971:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002c974:	90                   	nop
c002c975:	c9                   	leave  
c002c976:	c3                   	ret    

c002c977 <medium_thread_func>:

static void
medium_thread_func (void *locks_) 
{
c002c977:	55                   	push   %ebp
c002c978:	89 e5                	mov    %esp,%ebp
c002c97a:	83 ec 18             	sub    $0x18,%esp
  struct locks *locks = locks_;
c002c97d:	8b 45 08             	mov    0x8(%ebp),%eax
c002c980:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (locks->b);
c002c983:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c986:	8b 40 04             	mov    0x4(%eax),%eax
c002c989:	83 ec 0c             	sub    $0xc,%esp
c002c98c:	50                   	push   %eax
c002c98d:	e8 10 61 ff ff       	call   c0022aa2 <lock_acquire>
c002c992:	83 c4 10             	add    $0x10,%esp
  lock_acquire (locks->a);
c002c995:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c998:	8b 00                	mov    (%eax),%eax
c002c99a:	83 ec 0c             	sub    $0xc,%esp
c002c99d:	50                   	push   %eax
c002c99e:	e8 ff 60 ff ff       	call   c0022aa2 <lock_acquire>
c002c9a3:	83 c4 10             	add    $0x10,%esp

  msg ("Medium thread should have priority %d.  Actual priority: %d.",
c002c9a6:	e8 e7 44 ff ff       	call   c0020e92 <thread_get_priority>
c002c9ab:	83 ec 04             	sub    $0x4,%esp
c002c9ae:	50                   	push   %eax
c002c9af:	6a 21                	push   $0x21
c002c9b1:	68 a8 1f 03 c0       	push   $0xc0031fa8
c002c9b6:	e8 02 ef ff ff       	call   c002b8bd <msg>
c002c9bb:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  msg ("Medium thread got the lock.");
c002c9be:	83 ec 0c             	sub    $0xc,%esp
c002c9c1:	68 e5 1f 03 c0       	push   $0xc0031fe5
c002c9c6:	e8 f2 ee ff ff       	call   c002b8bd <msg>
c002c9cb:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->a);
c002c9ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c9d1:	8b 00                	mov    (%eax),%eax
c002c9d3:	83 ec 0c             	sub    $0xc,%esp
c002c9d6:	50                   	push   %eax
c002c9d7:	e8 02 62 ff ff       	call   c0022bde <lock_release>
c002c9dc:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002c9df:	e8 8a 43 ff ff       	call   c0020d6e <thread_yield>

  lock_release (locks->b);
c002c9e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c9e7:	8b 40 04             	mov    0x4(%eax),%eax
c002c9ea:	83 ec 0c             	sub    $0xc,%esp
c002c9ed:	50                   	push   %eax
c002c9ee:	e8 eb 61 ff ff       	call   c0022bde <lock_release>
c002c9f3:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002c9f6:	e8 73 43 ff ff       	call   c0020d6e <thread_yield>

  msg ("High thread should have just finished.");
c002c9fb:	83 ec 0c             	sub    $0xc,%esp
c002c9fe:	68 04 20 03 c0       	push   $0xc0032004
c002ca03:	e8 b5 ee ff ff       	call   c002b8bd <msg>
c002ca08:	83 c4 10             	add    $0x10,%esp
  msg ("Middle thread finished.");
c002ca0b:	83 ec 0c             	sub    $0xc,%esp
c002ca0e:	68 2b 20 03 c0       	push   $0xc003202b
c002ca13:	e8 a5 ee ff ff       	call   c002b8bd <msg>
c002ca18:	83 c4 10             	add    $0x10,%esp
}
c002ca1b:	90                   	nop
c002ca1c:	c9                   	leave  
c002ca1d:	c3                   	ret    

c002ca1e <high_thread_func>:

static void
high_thread_func (void *lock_) 
{
c002ca1e:	55                   	push   %ebp
c002ca1f:	89 e5                	mov    %esp,%ebp
c002ca21:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002ca24:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca27:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002ca2a:	83 ec 0c             	sub    $0xc,%esp
c002ca2d:	ff 75 f4             	push   -0xc(%ebp)
c002ca30:	e8 6d 60 ff ff       	call   c0022aa2 <lock_acquire>
c002ca35:	83 c4 10             	add    $0x10,%esp
  msg ("High thread got the lock.");
c002ca38:	83 ec 0c             	sub    $0xc,%esp
c002ca3b:	68 43 20 03 c0       	push   $0xc0032043
c002ca40:	e8 78 ee ff ff       	call   c002b8bd <msg>
c002ca45:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002ca48:	83 ec 0c             	sub    $0xc,%esp
c002ca4b:	ff 75 f4             	push   -0xc(%ebp)
c002ca4e:	e8 8b 61 ff ff       	call   c0022bde <lock_release>
c002ca53:	83 c4 10             	add    $0x10,%esp
  msg ("High thread finished.");
c002ca56:	83 ec 0c             	sub    $0xc,%esp
c002ca59:	68 5d 20 03 c0       	push   $0xc003205d
c002ca5e:	e8 5a ee ff ff       	call   c002b8bd <msg>
c002ca63:	83 c4 10             	add    $0x10,%esp
}
c002ca66:	90                   	nop
c002ca67:	c9                   	leave  
c002ca68:	c3                   	ret    

c002ca69 <test_priority_donate_sema>:
static thread_func m_thread_func;
static thread_func h_thread_func;

void
test_priority_donate_sema (void) 
{
c002ca69:	55                   	push   %ebp
c002ca6a:	89 e5                	mov    %esp,%ebp
c002ca6c:	83 ec 38             	sub    $0x38,%esp
  struct lock_and_sema ls;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002ca6f:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002ca74:	83 f0 01             	xor    $0x1,%eax
c002ca77:	84 c0                	test   %al,%al
c002ca79:	75 1e                	jne    c002ca99 <test_priority_donate_sema+0x30>
c002ca7b:	83 ec 0c             	sub    $0xc,%esp
c002ca7e:	68 90 20 03 c0       	push   $0xc0032090
c002ca83:	68 9e 20 03 c0       	push   $0xc003209e
c002ca88:	68 b4 21 03 c0       	push   $0xc00321b4
c002ca8d:	6a 23                	push   $0x23
c002ca8f:	68 b8 20 03 c0       	push   $0xc00320b8
c002ca94:	e8 85 ca ff ff       	call   c002951e <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002ca99:	e8 f4 43 ff ff       	call   c0020e92 <thread_get_priority>
c002ca9e:	83 f8 1f             	cmp    $0x1f,%eax
c002caa1:	74 1e                	je     c002cac1 <test_priority_donate_sema+0x58>
c002caa3:	83 ec 0c             	sub    $0xc,%esp
c002caa6:	68 e4 20 03 c0       	push   $0xc00320e4
c002caab:	68 9e 20 03 c0       	push   $0xc003209e
c002cab0:	68 b4 21 03 c0       	push   $0xc00321b4
c002cab5:	6a 26                	push   $0x26
c002cab7:	68 b8 20 03 c0       	push   $0xc00320b8
c002cabc:	e8 5d ca ff ff       	call   c002951e <debug_panic>

  lock_init (&ls.lock);
c002cac1:	83 ec 0c             	sub    $0xc,%esp
c002cac4:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cac7:	50                   	push   %eax
c002cac8:	e8 88 5f ff ff       	call   c0022a55 <lock_init>
c002cacd:	83 c4 10             	add    $0x10,%esp
  sema_init (&ls.sema, 0);
c002cad0:	83 ec 08             	sub    $0x8,%esp
c002cad3:	6a 00                	push   $0x0
c002cad5:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cad8:	83 c0 18             	add    $0x18,%eax
c002cadb:	50                   	push   %eax
c002cadc:	e8 bb 5c ff ff       	call   c002279c <sema_init>
c002cae1:	83 c4 10             	add    $0x10,%esp
  thread_create ("low", PRI_DEFAULT + 1, l_thread_func, &ls);
c002cae4:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cae7:	50                   	push   %eax
c002cae8:	68 51 cb 02 c0       	push   $0xc002cb51
c002caed:	6a 20                	push   $0x20
c002caef:	68 0a 21 03 c0       	push   $0xc003210a
c002caf4:	e8 68 3f ff ff       	call   c0020a61 <thread_create>
c002caf9:	83 c4 10             	add    $0x10,%esp
  thread_create ("med", PRI_DEFAULT + 3, m_thread_func, &ls);
c002cafc:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002caff:	50                   	push   %eax
c002cb00:	68 c0 cb 02 c0       	push   $0xc002cbc0
c002cb05:	6a 22                	push   $0x22
c002cb07:	68 0e 21 03 c0       	push   $0xc003210e
c002cb0c:	e8 50 3f ff ff       	call   c0020a61 <thread_create>
c002cb11:	83 c4 10             	add    $0x10,%esp
  thread_create ("high", PRI_DEFAULT + 5, h_thread_func, &ls);
c002cb14:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cb17:	50                   	push   %eax
c002cb18:	68 f1 cb 02 c0       	push   $0xc002cbf1
c002cb1d:	6a 24                	push   $0x24
c002cb1f:	68 12 21 03 c0       	push   $0xc0032112
c002cb24:	e8 38 3f ff ff       	call   c0020a61 <thread_create>
c002cb29:	83 c4 10             	add    $0x10,%esp
  sema_up (&ls.sema);
c002cb2c:	83 ec 0c             	sub    $0xc,%esp
c002cb2f:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cb32:	83 c0 18             	add    $0x18,%eax
c002cb35:	50                   	push   %eax
c002cb36:	e8 b2 5d ff ff       	call   c00228ed <sema_up>
c002cb3b:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread finished.");
c002cb3e:	83 ec 0c             	sub    $0xc,%esp
c002cb41:	68 17 21 03 c0       	push   $0xc0032117
c002cb46:	e8 72 ed ff ff       	call   c002b8bd <msg>
c002cb4b:	83 c4 10             	add    $0x10,%esp
}
c002cb4e:	90                   	nop
c002cb4f:	c9                   	leave  
c002cb50:	c3                   	ret    

c002cb51 <l_thread_func>:

static void
l_thread_func (void *ls_) 
{
c002cb51:	55                   	push   %ebp
c002cb52:	89 e5                	mov    %esp,%ebp
c002cb54:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002cb57:	8b 45 08             	mov    0x8(%ebp),%eax
c002cb5a:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002cb5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cb60:	83 ec 0c             	sub    $0xc,%esp
c002cb63:	50                   	push   %eax
c002cb64:	e8 39 5f ff ff       	call   c0022aa2 <lock_acquire>
c002cb69:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L acquired lock.");
c002cb6c:	83 ec 0c             	sub    $0xc,%esp
c002cb6f:	68 2d 21 03 c0       	push   $0xc003212d
c002cb74:	e8 44 ed ff ff       	call   c002b8bd <msg>
c002cb79:	83 c4 10             	add    $0x10,%esp
  sema_down (&ls->sema);
c002cb7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cb7f:	83 c0 18             	add    $0x18,%eax
c002cb82:	83 ec 0c             	sub    $0xc,%esp
c002cb85:	50                   	push   %eax
c002cb86:	e8 58 5c ff ff       	call   c00227e3 <sema_down>
c002cb8b:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L downed semaphore.");
c002cb8e:	83 ec 0c             	sub    $0xc,%esp
c002cb91:	68 45 21 03 c0       	push   $0xc0032145
c002cb96:	e8 22 ed ff ff       	call   c002b8bd <msg>
c002cb9b:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002cb9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cba1:	83 ec 0c             	sub    $0xc,%esp
c002cba4:	50                   	push   %eax
c002cba5:	e8 34 60 ff ff       	call   c0022bde <lock_release>
c002cbaa:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L finished.");
c002cbad:	83 ec 0c             	sub    $0xc,%esp
c002cbb0:	68 60 21 03 c0       	push   $0xc0032160
c002cbb5:	e8 03 ed ff ff       	call   c002b8bd <msg>
c002cbba:	83 c4 10             	add    $0x10,%esp
}
c002cbbd:	90                   	nop
c002cbbe:	c9                   	leave  
c002cbbf:	c3                   	ret    

c002cbc0 <m_thread_func>:

static void
m_thread_func (void *ls_) 
{
c002cbc0:	55                   	push   %ebp
c002cbc1:	89 e5                	mov    %esp,%ebp
c002cbc3:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002cbc6:	8b 45 08             	mov    0x8(%ebp),%eax
c002cbc9:	89 45 f4             	mov    %eax,-0xc(%ebp)

  sema_down (&ls->sema);
c002cbcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cbcf:	83 c0 18             	add    $0x18,%eax
c002cbd2:	83 ec 0c             	sub    $0xc,%esp
c002cbd5:	50                   	push   %eax
c002cbd6:	e8 08 5c ff ff       	call   c00227e3 <sema_down>
c002cbdb:	83 c4 10             	add    $0x10,%esp
  msg ("Thread M finished.");
c002cbde:	83 ec 0c             	sub    $0xc,%esp
c002cbe1:	68 73 21 03 c0       	push   $0xc0032173
c002cbe6:	e8 d2 ec ff ff       	call   c002b8bd <msg>
c002cbeb:	83 c4 10             	add    $0x10,%esp
}
c002cbee:	90                   	nop
c002cbef:	c9                   	leave  
c002cbf0:	c3                   	ret    

c002cbf1 <h_thread_func>:

static void
h_thread_func (void *ls_) 
{
c002cbf1:	55                   	push   %ebp
c002cbf2:	89 e5                	mov    %esp,%ebp
c002cbf4:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002cbf7:	8b 45 08             	mov    0x8(%ebp),%eax
c002cbfa:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002cbfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc00:	83 ec 0c             	sub    $0xc,%esp
c002cc03:	50                   	push   %eax
c002cc04:	e8 99 5e ff ff       	call   c0022aa2 <lock_acquire>
c002cc09:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H acquired lock.");
c002cc0c:	83 ec 0c             	sub    $0xc,%esp
c002cc0f:	68 86 21 03 c0       	push   $0xc0032186
c002cc14:	e8 a4 ec ff ff       	call   c002b8bd <msg>
c002cc19:	83 c4 10             	add    $0x10,%esp

  sema_up (&ls->sema);
c002cc1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc1f:	83 c0 18             	add    $0x18,%eax
c002cc22:	83 ec 0c             	sub    $0xc,%esp
c002cc25:	50                   	push   %eax
c002cc26:	e8 c2 5c ff ff       	call   c00228ed <sema_up>
c002cc2b:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002cc2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc31:	83 ec 0c             	sub    $0xc,%esp
c002cc34:	50                   	push   %eax
c002cc35:	e8 a4 5f ff ff       	call   c0022bde <lock_release>
c002cc3a:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H finished.");
c002cc3d:	83 ec 0c             	sub    $0xc,%esp
c002cc40:	68 9e 21 03 c0       	push   $0xc003219e
c002cc45:	e8 73 ec ff ff       	call   c002b8bd <msg>
c002cc4a:	83 c4 10             	add    $0x10,%esp
}
c002cc4d:	90                   	nop
c002cc4e:	c9                   	leave  
c002cc4f:	c3                   	ret    

c002cc50 <test_priority_donate_lower>:

static thread_func acquire_thread_func;

void
test_priority_donate_lower (void) 
{
c002cc50:	55                   	push   %ebp
c002cc51:	89 e5                	mov    %esp,%ebp
c002cc53:	83 ec 28             	sub    $0x28,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cc56:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002cc5b:	83 f0 01             	xor    $0x1,%eax
c002cc5e:	84 c0                	test   %al,%al
c002cc60:	75 1e                	jne    c002cc80 <test_priority_donate_lower+0x30>
c002cc62:	83 ec 0c             	sub    $0xc,%esp
c002cc65:	68 d0 21 03 c0       	push   $0xc00321d0
c002cc6a:	68 de 21 03 c0       	push   $0xc00321de
c002cc6f:	68 f4 22 03 c0       	push   $0xc00322f4
c002cc74:	6a 15                	push   $0x15
c002cc76:	68 f8 21 03 c0       	push   $0xc00321f8
c002cc7b:	e8 9e c8 ff ff       	call   c002951e <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cc80:	e8 0d 42 ff ff       	call   c0020e92 <thread_get_priority>
c002cc85:	83 f8 1f             	cmp    $0x1f,%eax
c002cc88:	74 1e                	je     c002cca8 <test_priority_donate_lower+0x58>
c002cc8a:	83 ec 0c             	sub    $0xc,%esp
c002cc8d:	68 24 22 03 c0       	push   $0xc0032224
c002cc92:	68 de 21 03 c0       	push   $0xc00321de
c002cc97:	68 f4 22 03 c0       	push   $0xc00322f4
c002cc9c:	6a 18                	push   $0x18
c002cc9e:	68 f8 21 03 c0       	push   $0xc00321f8
c002cca3:	e8 76 c8 ff ff       	call   c002951e <debug_panic>

  lock_init (&lock);
c002cca8:	83 ec 0c             	sub    $0xc,%esp
c002ccab:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ccae:	50                   	push   %eax
c002ccaf:	e8 a1 5d ff ff       	call   c0022a55 <lock_init>
c002ccb4:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002ccb7:	83 ec 0c             	sub    $0xc,%esp
c002ccba:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ccbd:	50                   	push   %eax
c002ccbe:	e8 df 5d ff ff       	call   c0022aa2 <lock_acquire>
c002ccc3:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire", PRI_DEFAULT + 10, acquire_thread_func, &lock);
c002ccc6:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ccc9:	50                   	push   %eax
c002ccca:	68 65 cd 02 c0       	push   $0xc002cd65
c002cccf:	6a 29                	push   $0x29
c002ccd1:	68 4a 22 03 c0       	push   $0xc003224a
c002ccd6:	e8 86 3d ff ff       	call   c0020a61 <thread_create>
c002ccdb:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002ccde:	e8 af 41 ff ff       	call   c0020e92 <thread_get_priority>
c002cce3:	83 ec 04             	sub    $0x4,%esp
c002cce6:	50                   	push   %eax
c002cce7:	6a 29                	push   $0x29
c002cce9:	68 54 22 03 c0       	push   $0xc0032254
c002ccee:	e8 ca eb ff ff       	call   c002b8bd <msg>
c002ccf3:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());

  msg ("Lowering base priority...");
c002ccf6:	83 ec 0c             	sub    $0xc,%esp
c002ccf9:	68 8f 22 03 c0       	push   $0xc003228f
c002ccfe:	e8 ba eb ff ff       	call   c002b8bd <msg>
c002cd03:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 10);
c002cd06:	83 ec 0c             	sub    $0xc,%esp
c002cd09:	6a 15                	push   $0x15
c002cd0b:	e8 6e 41 ff ff       	call   c0020e7e <thread_set_priority>
c002cd10:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cd13:	e8 7a 41 ff ff       	call   c0020e92 <thread_get_priority>
c002cd18:	83 ec 04             	sub    $0x4,%esp
c002cd1b:	50                   	push   %eax
c002cd1c:	6a 29                	push   $0x29
c002cd1e:	68 54 22 03 c0       	push   $0xc0032254
c002cd23:	e8 95 eb ff ff       	call   c002b8bd <msg>
c002cd28:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());
  lock_release (&lock);
c002cd2b:	83 ec 0c             	sub    $0xc,%esp
c002cd2e:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cd31:	50                   	push   %eax
c002cd32:	e8 a7 5e ff ff       	call   c0022bde <lock_release>
c002cd37:	83 c4 10             	add    $0x10,%esp
  msg ("acquire must already have finished.");
c002cd3a:	83 ec 0c             	sub    $0xc,%esp
c002cd3d:	68 ac 22 03 c0       	push   $0xc00322ac
c002cd42:	e8 76 eb ff ff       	call   c002b8bd <msg>
c002cd47:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cd4a:	e8 43 41 ff ff       	call   c0020e92 <thread_get_priority>
c002cd4f:	83 ec 04             	sub    $0x4,%esp
c002cd52:	50                   	push   %eax
c002cd53:	6a 15                	push   $0x15
c002cd55:	68 54 22 03 c0       	push   $0xc0032254
c002cd5a:	e8 5e eb ff ff       	call   c002b8bd <msg>
c002cd5f:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT - 10, thread_get_priority ());
}
c002cd62:	90                   	nop
c002cd63:	c9                   	leave  
c002cd64:	c3                   	ret    

c002cd65 <acquire_thread_func>:

static void
acquire_thread_func (void *lock_) 
{
c002cd65:	55                   	push   %ebp
c002cd66:	89 e5                	mov    %esp,%ebp
c002cd68:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002cd6b:	8b 45 08             	mov    0x8(%ebp),%eax
c002cd6e:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002cd71:	83 ec 0c             	sub    $0xc,%esp
c002cd74:	ff 75 f4             	push   -0xc(%ebp)
c002cd77:	e8 26 5d ff ff       	call   c0022aa2 <lock_acquire>
c002cd7c:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: got the lock");
c002cd7f:	83 ec 0c             	sub    $0xc,%esp
c002cd82:	68 d0 22 03 c0       	push   $0xc00322d0
c002cd87:	e8 31 eb ff ff       	call   c002b8bd <msg>
c002cd8c:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002cd8f:	83 ec 0c             	sub    $0xc,%esp
c002cd92:	ff 75 f4             	push   -0xc(%ebp)
c002cd95:	e8 44 5e ff ff       	call   c0022bde <lock_release>
c002cd9a:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: done");
c002cd9d:	83 ec 0c             	sub    $0xc,%esp
c002cda0:	68 e6 22 03 c0       	push   $0xc00322e6
c002cda5:	e8 13 eb ff ff       	call   c002b8bd <msg>
c002cdaa:	83 c4 10             	add    $0x10,%esp
}
c002cdad:	90                   	nop
c002cdae:	c9                   	leave  
c002cdaf:	c3                   	ret    

c002cdb0 <test_priority_fifo>:

static thread_func simple_thread_func;

void
test_priority_fifo (void) 
{
c002cdb0:	55                   	push   %ebp
c002cdb1:	89 e5                	mov    %esp,%ebp
c002cdb3:	81 ec 48 01 00 00    	sub    $0x148,%esp
  struct lock lock;
  int *output, *op;
  int i, cnt;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cdb9:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002cdbe:	83 f0 01             	xor    $0x1,%eax
c002cdc1:	84 c0                	test   %al,%al
c002cdc3:	75 1e                	jne    c002cde3 <test_priority_fifo+0x33>
c002cdc5:	83 ec 0c             	sub    $0xc,%esp
c002cdc8:	68 10 23 03 c0       	push   $0xc0032310
c002cdcd:	68 1e 23 03 c0       	push   $0xc003231e
c002cdd2:	68 58 24 03 c0       	push   $0xc0032458
c002cdd7:	6a 28                	push   $0x28
c002cdd9:	68 38 23 03 c0       	push   $0xc0032338
c002cdde:	e8 3b c7 ff ff       	call   c002951e <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cde3:	e8 aa 40 ff ff       	call   c0020e92 <thread_get_priority>
c002cde8:	83 f8 1f             	cmp    $0x1f,%eax
c002cdeb:	74 1e                	je     c002ce0b <test_priority_fifo+0x5b>
c002cded:	83 ec 0c             	sub    $0xc,%esp
c002cdf0:	68 5c 23 03 c0       	push   $0xc003235c
c002cdf5:	68 1e 23 03 c0       	push   $0xc003231e
c002cdfa:	68 58 24 03 c0       	push   $0xc0032458
c002cdff:	6a 2b                	push   $0x2b
c002ce01:	68 38 23 03 c0       	push   $0xc0032338
c002ce06:	e8 13 c7 ff ff       	call   c002951e <debug_panic>

  msg ("%d threads will iterate %d times in the same order each time.",
c002ce0b:	83 ec 04             	sub    $0x4,%esp
c002ce0e:	6a 10                	push   $0x10
c002ce10:	6a 10                	push   $0x10
c002ce12:	68 84 23 03 c0       	push   $0xc0032384
c002ce17:	e8 a1 ea ff ff       	call   c002b8bd <msg>
c002ce1c:	83 c4 10             	add    $0x10,%esp
       THREAD_CNT, ITER_CNT);
  msg ("If the order varies then there is a bug.");
c002ce1f:	83 ec 0c             	sub    $0xc,%esp
c002ce22:	68 c4 23 03 c0       	push   $0xc00323c4
c002ce27:	e8 91 ea ff ff       	call   c002b8bd <msg>
c002ce2c:	83 c4 10             	add    $0x10,%esp

  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
c002ce2f:	83 ec 0c             	sub    $0xc,%esp
c002ce32:	68 00 08 00 00       	push   $0x800
c002ce37:	e8 27 66 ff ff       	call   c0023463 <malloc>
c002ce3c:	83 c4 10             	add    $0x10,%esp
c002ce3f:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
c002ce45:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
c002ce4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (output != NULL);
c002ce4e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002ce52:	75 1e                	jne    c002ce72 <test_priority_fifo+0xc2>
c002ce54:	83 ec 0c             	sub    $0xc,%esp
c002ce57:	68 ed 23 03 c0       	push   $0xc00323ed
c002ce5c:	68 1e 23 03 c0       	push   $0xc003231e
c002ce61:	68 58 24 03 c0       	push   $0xc0032458
c002ce66:	6a 32                	push   $0x32
c002ce68:	68 38 23 03 c0       	push   $0xc0032338
c002ce6d:	e8 ac c6 ff ff       	call   c002951e <debug_panic>
  lock_init (&lock);
c002ce72:	83 ec 0c             	sub    $0xc,%esp
c002ce75:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
c002ce7b:	50                   	push   %eax
c002ce7c:	e8 d4 5b ff ff       	call   c0022a55 <lock_init>
c002ce81:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_DEFAULT + 2);
c002ce84:	83 ec 0c             	sub    $0xc,%esp
c002ce87:	6a 21                	push   $0x21
c002ce89:	e8 f0 3f ff ff       	call   c0020e7e <thread_set_priority>
c002ce8e:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002ce91:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002ce98:	eb 72                	jmp    c002cf0c <test_priority_fifo+0x15c>
    {
      char name[16];
      struct simple_thread_data *d = data + i;
c002ce9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ce9d:	c1 e0 04             	shl    $0x4,%eax
c002cea0:	89 c2                	mov    %eax,%edx
c002cea2:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002cea8:	01 d0                	add    %edx,%eax
c002ceaa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      snprintf (name, sizeof name, "%d", i);
c002cead:	ff 75 f0             	push   -0x10(%ebp)
c002ceb0:	68 fc 23 03 c0       	push   $0xc00323fc
c002ceb5:	6a 10                	push   $0x10
c002ceb7:	8d 85 b8 fe ff ff    	lea    -0x148(%ebp),%eax
c002cebd:	50                   	push   %eax
c002cebe:	e8 90 a2 ff ff       	call   c0027153 <snprintf>
c002cec3:	83 c4 10             	add    $0x10,%esp
      d->id = i;
c002cec6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002cec9:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002cecc:	89 10                	mov    %edx,(%eax)
      d->iterations = 0;
c002cece:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002ced1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      d->lock = &lock;
c002ced8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002cedb:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
c002cee1:	89 50 08             	mov    %edx,0x8(%eax)
      d->op = &op;
c002cee4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002cee7:	8d 95 c8 fe ff ff    	lea    -0x138(%ebp),%edx
c002ceed:	89 50 0c             	mov    %edx,0xc(%eax)
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
c002cef0:	ff 75 e4             	push   -0x1c(%ebp)
c002cef3:	68 09 d0 02 c0       	push   $0xc002d009
c002cef8:	6a 20                	push   $0x20
c002cefa:	8d 85 b8 fe ff ff    	lea    -0x148(%ebp),%eax
c002cf00:	50                   	push   %eax
c002cf01:	e8 5b 3b ff ff       	call   c0020a61 <thread_create>
c002cf06:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002cf09:	ff 45 f0             	incl   -0x10(%ebp)
c002cf0c:	83 7d f0 0f          	cmpl   $0xf,-0x10(%ebp)
c002cf10:	7e 88                	jle    c002ce9a <test_priority_fifo+0xea>
    }

  thread_set_priority (PRI_DEFAULT);
c002cf12:	83 ec 0c             	sub    $0xc,%esp
c002cf15:	6a 1f                	push   $0x1f
c002cf17:	e8 62 3f ff ff       	call   c0020e7e <thread_set_priority>
c002cf1c:	83 c4 10             	add    $0x10,%esp
  /* All the other threads now run to termination here. */
  ASSERT (lock.holder == NULL);
c002cf1f:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
c002cf25:	85 c0                	test   %eax,%eax
c002cf27:	74 1e                	je     c002cf47 <test_priority_fifo+0x197>
c002cf29:	83 ec 0c             	sub    $0xc,%esp
c002cf2c:	68 ff 23 03 c0       	push   $0xc00323ff
c002cf31:	68 1e 23 03 c0       	push   $0xc003231e
c002cf36:	68 58 24 03 c0       	push   $0xc0032458
c002cf3b:	6a 44                	push   $0x44
c002cf3d:	68 38 23 03 c0       	push   $0xc0032338
c002cf42:	e8 d7 c5 ff ff       	call   c002951e <debug_panic>

  cnt = 0;
c002cf47:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  for (; output < op; output++) 
c002cf4e:	e9 a3 00 00 00       	jmp    c002cff6 <test_priority_fifo+0x246>
    {
      struct simple_thread_data *d;

      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002cf53:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cf56:	8b 00                	mov    (%eax),%eax
c002cf58:	85 c0                	test   %eax,%eax
c002cf5a:	78 0a                	js     c002cf66 <test_priority_fifo+0x1b6>
c002cf5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cf5f:	8b 00                	mov    (%eax),%eax
c002cf61:	83 f8 0f             	cmp    $0xf,%eax
c002cf64:	7e 1e                	jle    c002cf84 <test_priority_fifo+0x1d4>
c002cf66:	83 ec 0c             	sub    $0xc,%esp
c002cf69:	68 14 24 03 c0       	push   $0xc0032414
c002cf6e:	68 1e 23 03 c0       	push   $0xc003231e
c002cf73:	68 58 24 03 c0       	push   $0xc0032458
c002cf78:	6a 4b                	push   $0x4b
c002cf7a:	68 38 23 03 c0       	push   $0xc0032338
c002cf7f:	e8 9a c5 ff ff       	call   c002951e <debug_panic>
      d = data + *output;
c002cf84:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cf87:	8b 00                	mov    (%eax),%eax
c002cf89:	c1 e0 04             	shl    $0x4,%eax
c002cf8c:	89 c2                	mov    %eax,%edx
c002cf8e:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002cf94:	01 d0                	add    %edx,%eax
c002cf96:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (cnt % THREAD_CNT == 0)
c002cf99:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002cf9c:	83 e0 0f             	and    $0xf,%eax
c002cf9f:	85 c0                	test   %eax,%eax
c002cfa1:	75 10                	jne    c002cfb3 <test_priority_fifo+0x203>
        printf ("(priority-fifo) iteration:");
c002cfa3:	83 ec 0c             	sub    $0xc,%esp
c002cfa6:	68 39 24 03 c0       	push   $0xc0032439
c002cfab:	e8 cc a1 ff ff       	call   c002717c <printf>
c002cfb0:	83 c4 10             	add    $0x10,%esp
      printf (" %d", d->id);
c002cfb3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002cfb6:	8b 00                	mov    (%eax),%eax
c002cfb8:	83 ec 08             	sub    $0x8,%esp
c002cfbb:	50                   	push   %eax
c002cfbc:	68 54 24 03 c0       	push   $0xc0032454
c002cfc1:	e8 b6 a1 ff ff       	call   c002717c <printf>
c002cfc6:	83 c4 10             	add    $0x10,%esp
      if (++cnt % THREAD_CNT == 0)
c002cfc9:	ff 45 ec             	incl   -0x14(%ebp)
c002cfcc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002cfcf:	83 e0 0f             	and    $0xf,%eax
c002cfd2:	85 c0                	test   %eax,%eax
c002cfd4:	75 0d                	jne    c002cfe3 <test_priority_fifo+0x233>
        printf ("\n");
c002cfd6:	83 ec 0c             	sub    $0xc,%esp
c002cfd9:	6a 0a                	push   $0xa
c002cfdb:	e8 88 e7 ff ff       	call   c002b768 <putchar>
c002cfe0:	83 c4 10             	add    $0x10,%esp
      d->iterations++;
c002cfe3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002cfe6:	8b 40 04             	mov    0x4(%eax),%eax
c002cfe9:	8d 50 01             	lea    0x1(%eax),%edx
c002cfec:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002cfef:	89 50 04             	mov    %edx,0x4(%eax)
  for (; output < op; output++) 
c002cff2:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002cff6:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
c002cffc:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002cfff:	0f 82 4e ff ff ff    	jb     c002cf53 <test_priority_fifo+0x1a3>
    }
}
c002d005:	90                   	nop
c002d006:	90                   	nop
c002d007:	c9                   	leave  
c002d008:	c3                   	ret    

c002d009 <simple_thread_func>:

static void 
simple_thread_func (void *data_) 
{
c002d009:	55                   	push   %ebp
c002d00a:	89 e5                	mov    %esp,%ebp
c002d00c:	83 ec 18             	sub    $0x18,%esp
  struct simple_thread_data *data = data_;
c002d00f:	8b 45 08             	mov    0x8(%ebp),%eax
c002d012:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
c002d015:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d01c:	eb 40                	jmp    c002d05e <simple_thread_func+0x55>
    {
      lock_acquire (data->lock);
c002d01e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d021:	8b 40 08             	mov    0x8(%eax),%eax
c002d024:	83 ec 0c             	sub    $0xc,%esp
c002d027:	50                   	push   %eax
c002d028:	e8 75 5a ff ff       	call   c0022aa2 <lock_acquire>
c002d02d:	83 c4 10             	add    $0x10,%esp
      *(*data->op)++ = data->id;
c002d030:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d033:	8b 50 0c             	mov    0xc(%eax),%edx
c002d036:	8b 02                	mov    (%edx),%eax
c002d038:	8d 48 04             	lea    0x4(%eax),%ecx
c002d03b:	89 0a                	mov    %ecx,(%edx)
c002d03d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002d040:	8b 12                	mov    (%edx),%edx
c002d042:	89 10                	mov    %edx,(%eax)
      lock_release (data->lock);
c002d044:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d047:	8b 40 08             	mov    0x8(%eax),%eax
c002d04a:	83 ec 0c             	sub    $0xc,%esp
c002d04d:	50                   	push   %eax
c002d04e:	e8 8b 5b ff ff       	call   c0022bde <lock_release>
c002d053:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002d056:	e8 13 3d ff ff       	call   c0020d6e <thread_yield>
  for (i = 0; i < ITER_CNT; i++) 
c002d05b:	ff 45 f4             	incl   -0xc(%ebp)
c002d05e:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
c002d062:	7e ba                	jle    c002d01e <simple_thread_func+0x15>
    }
}
c002d064:	90                   	nop
c002d065:	90                   	nop
c002d066:	c9                   	leave  
c002d067:	c3                   	ret    

c002d068 <test_priority_preempt>:

static thread_func simple_thread_func;

void
test_priority_preempt (void) 
{
c002d068:	55                   	push   %ebp
c002d069:	89 e5                	mov    %esp,%ebp
c002d06b:	83 ec 08             	sub    $0x8,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d06e:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002d073:	83 f0 01             	xor    $0x1,%eax
c002d076:	84 c0                	test   %al,%al
c002d078:	75 1e                	jne    c002d098 <test_priority_preempt+0x30>
c002d07a:	83 ec 0c             	sub    $0xc,%esp
c002d07d:	68 6c 24 03 c0       	push   $0xc003246c
c002d082:	68 7a 24 03 c0       	push   $0xc003247a
c002d087:	68 50 25 03 c0       	push   $0xc0032550
c002d08c:	6a 15                	push   $0x15
c002d08e:	68 94 24 03 c0       	push   $0xc0032494
c002d093:	e8 86 c4 ff ff       	call   c002951e <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d098:	e8 f5 3d ff ff       	call   c0020e92 <thread_get_priority>
c002d09d:	83 f8 1f             	cmp    $0x1f,%eax
c002d0a0:	74 1e                	je     c002d0c0 <test_priority_preempt+0x58>
c002d0a2:	83 ec 0c             	sub    $0xc,%esp
c002d0a5:	68 bc 24 03 c0       	push   $0xc00324bc
c002d0aa:	68 7a 24 03 c0       	push   $0xc003247a
c002d0af:	68 50 25 03 c0       	push   $0xc0032550
c002d0b4:	6a 18                	push   $0x18
c002d0b6:	68 94 24 03 c0       	push   $0xc0032494
c002d0bb:	e8 5e c4 ff ff       	call   c002951e <debug_panic>

  thread_create ("high-priority", PRI_DEFAULT + 1, simple_thread_func, NULL);
c002d0c0:	6a 00                	push   $0x0
c002d0c2:	68 e9 d0 02 c0       	push   $0xc002d0e9
c002d0c7:	6a 20                	push   $0x20
c002d0c9:	68 e2 24 03 c0       	push   $0xc00324e2
c002d0ce:	e8 8e 39 ff ff       	call   c0020a61 <thread_create>
c002d0d3:	83 c4 10             	add    $0x10,%esp
  msg ("The high-priority thread should have already completed.");
c002d0d6:	83 ec 0c             	sub    $0xc,%esp
c002d0d9:	68 f0 24 03 c0       	push   $0xc00324f0
c002d0de:	e8 da e7 ff ff       	call   c002b8bd <msg>
c002d0e3:	83 c4 10             	add    $0x10,%esp
}
c002d0e6:	90                   	nop
c002d0e7:	c9                   	leave  
c002d0e8:	c3                   	ret    

c002d0e9 <simple_thread_func>:

static void 
simple_thread_func (void *aux UNUSED) 
{
c002d0e9:	55                   	push   %ebp
c002d0ea:	89 e5                	mov    %esp,%ebp
c002d0ec:	83 ec 18             	sub    $0x18,%esp
  int i;
  
  for (i = 0; i < 5; i++) 
c002d0ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d0f6:	eb 21                	jmp    c002d119 <simple_thread_func+0x30>
    {
      msg ("Thread %s iteration %d", thread_name (), i);
c002d0f8:	e8 6b 3b ff ff       	call   c0020c68 <thread_name>
c002d0fd:	83 ec 04             	sub    $0x4,%esp
c002d100:	ff 75 f4             	push   -0xc(%ebp)
c002d103:	50                   	push   %eax
c002d104:	68 28 25 03 c0       	push   $0xc0032528
c002d109:	e8 af e7 ff ff       	call   c002b8bd <msg>
c002d10e:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002d111:	e8 58 3c ff ff       	call   c0020d6e <thread_yield>
  for (i = 0; i < 5; i++) 
c002d116:	ff 45 f4             	incl   -0xc(%ebp)
c002d119:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
c002d11d:	7e d9                	jle    c002d0f8 <simple_thread_func+0xf>
    }
  msg ("Thread %s done!", thread_name ());
c002d11f:	e8 44 3b ff ff       	call   c0020c68 <thread_name>
c002d124:	83 ec 08             	sub    $0x8,%esp
c002d127:	50                   	push   %eax
c002d128:	68 3f 25 03 c0       	push   $0xc003253f
c002d12d:	e8 8b e7 ff ff       	call   c002b8bd <msg>
c002d132:	83 c4 10             	add    $0x10,%esp
}
c002d135:	90                   	nop
c002d136:	c9                   	leave  
c002d137:	c3                   	ret    

c002d138 <test_priority_sema>:
static thread_func priority_sema_thread;
static struct semaphore sema;

void
test_priority_sema (void) 
{
c002d138:	55                   	push   %ebp
c002d139:	89 e5                	mov    %esp,%ebp
c002d13b:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d13e:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002d143:	83 f0 01             	xor    $0x1,%eax
c002d146:	84 c0                	test   %al,%al
c002d148:	75 1e                	jne    c002d168 <test_priority_sema+0x30>
c002d14a:	83 ec 0c             	sub    $0xc,%esp
c002d14d:	68 68 25 03 c0       	push   $0xc0032568
c002d152:	68 76 25 03 c0       	push   $0xc0032576
c002d157:	68 e8 25 03 c0       	push   $0xc00325e8
c002d15c:	6a 15                	push   $0x15
c002d15e:	68 90 25 03 c0       	push   $0xc0032590
c002d163:	e8 b6 c3 ff ff       	call   c002951e <debug_panic>

  sema_init (&sema, 0);
c002d168:	83 ec 08             	sub    $0x8,%esp
c002d16b:	6a 00                	push   $0x0
c002d16d:	68 14 54 03 c0       	push   $0xc0035414
c002d172:	e8 25 56 ff ff       	call   c002279c <sema_init>
c002d177:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_MIN);
c002d17a:	83 ec 0c             	sub    $0xc,%esp
c002d17d:	6a 00                	push   $0x0
c002d17f:	e8 fa 3c ff ff       	call   c0020e7e <thread_set_priority>
c002d184:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d187:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d18e:	eb 47                	jmp    c002d1d7 <test_priority_sema+0x9f>
    {
      int priority = PRI_DEFAULT - (i + 3) % 10 - 1;
c002d190:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d193:	83 c0 03             	add    $0x3,%eax
c002d196:	b9 0a 00 00 00       	mov    $0xa,%ecx
c002d19b:	99                   	cltd   
c002d19c:	f7 f9                	idiv   %ecx
c002d19e:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002d1a3:	29 d0                	sub    %edx,%eax
c002d1a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002d1a8:	ff 75 f0             	push   -0x10(%ebp)
c002d1ab:	68 b4 25 03 c0       	push   $0xc00325b4
c002d1b0:	6a 10                	push   $0x10
c002d1b2:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d1b5:	50                   	push   %eax
c002d1b6:	e8 98 9f ff ff       	call   c0027153 <snprintf>
c002d1bb:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_sema_thread, NULL);
c002d1be:	6a 00                	push   $0x0
c002d1c0:	68 13 d2 02 c0       	push   $0xc002d213
c002d1c5:	ff 75 f0             	push   -0x10(%ebp)
c002d1c8:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d1cb:	50                   	push   %eax
c002d1cc:	e8 90 38 ff ff       	call   c0020a61 <thread_create>
c002d1d1:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d1d4:	ff 45 f4             	incl   -0xc(%ebp)
c002d1d7:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d1db:	7e b3                	jle    c002d190 <test_priority_sema+0x58>
    }

  for (i = 0; i < 10; i++) 
c002d1dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d1e4:	eb 23                	jmp    c002d209 <test_priority_sema+0xd1>
    {
      sema_up (&sema);
c002d1e6:	83 ec 0c             	sub    $0xc,%esp
c002d1e9:	68 14 54 03 c0       	push   $0xc0035414
c002d1ee:	e8 fa 56 ff ff       	call   c00228ed <sema_up>
c002d1f3:	83 c4 10             	add    $0x10,%esp
      msg ("Back in main thread."); 
c002d1f6:	83 ec 0c             	sub    $0xc,%esp
c002d1f9:	68 c0 25 03 c0       	push   $0xc00325c0
c002d1fe:	e8 ba e6 ff ff       	call   c002b8bd <msg>
c002d203:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d206:	ff 45 f4             	incl   -0xc(%ebp)
c002d209:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d20d:	7e d7                	jle    c002d1e6 <test_priority_sema+0xae>
    }
}
c002d20f:	90                   	nop
c002d210:	90                   	nop
c002d211:	c9                   	leave  
c002d212:	c3                   	ret    

c002d213 <priority_sema_thread>:

static void
priority_sema_thread (void *aux UNUSED) 
{
c002d213:	55                   	push   %ebp
c002d214:	89 e5                	mov    %esp,%ebp
c002d216:	83 ec 08             	sub    $0x8,%esp
  sema_down (&sema);
c002d219:	83 ec 0c             	sub    $0xc,%esp
c002d21c:	68 14 54 03 c0       	push   $0xc0035414
c002d221:	e8 bd 55 ff ff       	call   c00227e3 <sema_down>
c002d226:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c002d229:	e8 3a 3a ff ff       	call   c0020c68 <thread_name>
c002d22e:	83 ec 08             	sub    $0x8,%esp
c002d231:	50                   	push   %eax
c002d232:	68 d5 25 03 c0       	push   $0xc00325d5
c002d237:	e8 81 e6 ff ff       	call   c002b8bd <msg>
c002d23c:	83 c4 10             	add    $0x10,%esp
}
c002d23f:	90                   	nop
c002d240:	c9                   	leave  
c002d241:	c3                   	ret    

c002d242 <test_priority_condvar>:
static struct lock lock;
static struct condition condition;

void
test_priority_condvar (void) 
{
c002d242:	55                   	push   %ebp
c002d243:	89 e5                	mov    %esp,%ebp
c002d245:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d248:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002d24d:	83 f0 01             	xor    $0x1,%eax
c002d250:	84 c0                	test   %al,%al
c002d252:	75 1e                	jne    c002d272 <test_priority_condvar+0x30>
c002d254:	83 ec 0c             	sub    $0xc,%esp
c002d257:	68 fc 25 03 c0       	push   $0xc00325fc
c002d25c:	68 0a 26 03 c0       	push   $0xc003260a
c002d261:	68 8c 26 03 c0       	push   $0xc003268c
c002d266:	6a 16                	push   $0x16
c002d268:	68 24 26 03 c0       	push   $0xc0032624
c002d26d:	e8 ac c2 ff ff       	call   c002951e <debug_panic>

  lock_init (&lock);
c002d272:	83 ec 0c             	sub    $0xc,%esp
c002d275:	68 28 54 03 c0       	push   $0xc0035428
c002d27a:	e8 d6 57 ff ff       	call   c0022a55 <lock_init>
c002d27f:	83 c4 10             	add    $0x10,%esp
  cond_init (&condition);
c002d282:	83 ec 0c             	sub    $0xc,%esp
c002d285:	68 40 54 03 c0       	push   $0xc0035440
c002d28a:	e8 0f 5a ff ff       	call   c0022c9e <cond_init>
c002d28f:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_MIN);
c002d292:	83 ec 0c             	sub    $0xc,%esp
c002d295:	6a 00                	push   $0x0
c002d297:	e8 e2 3b ff ff       	call   c0020e7e <thread_set_priority>
c002d29c:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d29f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d2a6:	eb 47                	jmp    c002d2ef <test_priority_condvar+0xad>
    {
      int priority = PRI_DEFAULT - (i + 7) % 10 - 1;
c002d2a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d2ab:	83 c0 07             	add    $0x7,%eax
c002d2ae:	b9 0a 00 00 00       	mov    $0xa,%ecx
c002d2b3:	99                   	cltd   
c002d2b4:	f7 f9                	idiv   %ecx
c002d2b6:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002d2bb:	29 d0                	sub    %edx,%eax
c002d2bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002d2c0:	ff 75 f0             	push   -0x10(%ebp)
c002d2c3:	68 4b 26 03 c0       	push   $0xc003264b
c002d2c8:	6a 10                	push   $0x10
c002d2ca:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d2cd:	50                   	push   %eax
c002d2ce:	e8 80 9e ff ff       	call   c0027153 <snprintf>
c002d2d3:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_condvar_thread, NULL);
c002d2d6:	6a 00                	push   $0x0
c002d2d8:	68 50 d3 02 c0       	push   $0xc002d350
c002d2dd:	ff 75 f0             	push   -0x10(%ebp)
c002d2e0:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d2e3:	50                   	push   %eax
c002d2e4:	e8 78 37 ff ff       	call   c0020a61 <thread_create>
c002d2e9:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d2ec:	ff 45 f4             	incl   -0xc(%ebp)
c002d2ef:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d2f3:	7e b3                	jle    c002d2a8 <test_priority_condvar+0x66>
    }

  for (i = 0; i < 10; i++) 
c002d2f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d2fc:	eb 48                	jmp    c002d346 <test_priority_condvar+0x104>
    {
      lock_acquire (&lock);
c002d2fe:	83 ec 0c             	sub    $0xc,%esp
c002d301:	68 28 54 03 c0       	push   $0xc0035428
c002d306:	e8 97 57 ff ff       	call   c0022aa2 <lock_acquire>
c002d30b:	83 c4 10             	add    $0x10,%esp
      msg ("Signaling...");
c002d30e:	83 ec 0c             	sub    $0xc,%esp
c002d311:	68 57 26 03 c0       	push   $0xc0032657
c002d316:	e8 a2 e5 ff ff       	call   c002b8bd <msg>
c002d31b:	83 c4 10             	add    $0x10,%esp
      cond_signal (&condition, &lock);
c002d31e:	83 ec 08             	sub    $0x8,%esp
c002d321:	68 28 54 03 c0       	push   $0xc0035428
c002d326:	68 40 54 03 c0       	push   $0xc0035440
c002d32b:	e8 b9 5a ff ff       	call   c0022de9 <cond_signal>
c002d330:	83 c4 10             	add    $0x10,%esp
      lock_release (&lock);
c002d333:	83 ec 0c             	sub    $0xc,%esp
c002d336:	68 28 54 03 c0       	push   $0xc0035428
c002d33b:	e8 9e 58 ff ff       	call   c0022bde <lock_release>
c002d340:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d343:	ff 45 f4             	incl   -0xc(%ebp)
c002d346:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d34a:	7e b2                	jle    c002d2fe <test_priority_condvar+0xbc>
    }
}
c002d34c:	90                   	nop
c002d34d:	90                   	nop
c002d34e:	c9                   	leave  
c002d34f:	c3                   	ret    

c002d350 <priority_condvar_thread>:

static void
priority_condvar_thread (void *aux UNUSED) 
{
c002d350:	55                   	push   %ebp
c002d351:	89 e5                	mov    %esp,%ebp
c002d353:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread %s starting.", thread_name ());
c002d356:	e8 0d 39 ff ff       	call   c0020c68 <thread_name>
c002d35b:	83 ec 08             	sub    $0x8,%esp
c002d35e:	50                   	push   %eax
c002d35f:	68 64 26 03 c0       	push   $0xc0032664
c002d364:	e8 54 e5 ff ff       	call   c002b8bd <msg>
c002d369:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002d36c:	83 ec 0c             	sub    $0xc,%esp
c002d36f:	68 28 54 03 c0       	push   $0xc0035428
c002d374:	e8 29 57 ff ff       	call   c0022aa2 <lock_acquire>
c002d379:	83 c4 10             	add    $0x10,%esp
  cond_wait (&condition, &lock);
c002d37c:	83 ec 08             	sub    $0x8,%esp
c002d37f:	68 28 54 03 c0       	push   $0xc0035428
c002d384:	68 40 54 03 c0       	push   $0xc0035440
c002d389:	e8 4f 59 ff ff       	call   c0022cdd <cond_wait>
c002d38e:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c002d391:	e8 d2 38 ff ff       	call   c0020c68 <thread_name>
c002d396:	83 ec 08             	sub    $0x8,%esp
c002d399:	50                   	push   %eax
c002d39a:	68 78 26 03 c0       	push   $0xc0032678
c002d39f:	e8 19 e5 ff ff       	call   c002b8bd <msg>
c002d3a4:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c002d3a7:	83 ec 0c             	sub    $0xc,%esp
c002d3aa:	68 28 54 03 c0       	push   $0xc0035428
c002d3af:	e8 2a 58 ff ff       	call   c0022bde <lock_release>
c002d3b4:	83 c4 10             	add    $0x10,%esp
}
c002d3b7:	90                   	nop
c002d3b8:	c9                   	leave  
c002d3b9:	c3                   	ret    

c002d3ba <test_priority_donate_chain>:
static thread_func donor_thread_func;
static thread_func interloper_thread_func;

void
test_priority_donate_chain (void) 
{
c002d3ba:	55                   	push   %ebp
c002d3bb:	89 e5                	mov    %esp,%ebp
c002d3bd:	53                   	push   %ebx
c002d3be:	81 ec 04 01 00 00    	sub    $0x104,%esp
  int i;  
  struct lock locks[NESTING_DEPTH - 1];
  struct lock_pair lock_pairs[NESTING_DEPTH];

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d3c4:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002d3c9:	83 f0 01             	xor    $0x1,%eax
c002d3cc:	84 c0                	test   %al,%al
c002d3ce:	75 1e                	jne    c002d3ee <test_priority_donate_chain+0x34>
c002d3d0:	83 ec 0c             	sub    $0xc,%esp
c002d3d3:	68 a4 26 03 c0       	push   $0xc00326a4
c002d3d8:	68 b2 26 03 c0       	push   $0xc00326b2
c002d3dd:	68 bc 27 03 c0       	push   $0xc00327bc
c002d3e2:	6a 34                	push   $0x34
c002d3e4:	68 cc 26 03 c0       	push   $0xc00326cc
c002d3e9:	e8 30 c1 ff ff       	call   c002951e <debug_panic>

  thread_set_priority (PRI_MIN);
c002d3ee:	83 ec 0c             	sub    $0xc,%esp
c002d3f1:	6a 00                	push   $0x0
c002d3f3:	e8 86 3a ff ff       	call   c0020e7e <thread_set_priority>
c002d3f8:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002d3fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d402:	eb 23                	jmp    c002d427 <test_priority_donate_chain+0x6d>
    lock_init (&locks[i]);
c002d404:	8d 8d 48 ff ff ff    	lea    -0xb8(%ebp),%ecx
c002d40a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d40d:	89 d0                	mov    %edx,%eax
c002d40f:	01 c0                	add    %eax,%eax
c002d411:	01 d0                	add    %edx,%eax
c002d413:	c1 e0 03             	shl    $0x3,%eax
c002d416:	01 c8                	add    %ecx,%eax
c002d418:	83 ec 0c             	sub    $0xc,%esp
c002d41b:	50                   	push   %eax
c002d41c:	e8 34 56 ff ff       	call   c0022a55 <lock_init>
c002d421:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002d424:	ff 45 f4             	incl   -0xc(%ebp)
c002d427:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c002d42b:	7e d7                	jle    c002d404 <test_priority_donate_chain+0x4a>

  lock_acquire (&locks[0]);
c002d42d:	83 ec 0c             	sub    $0xc,%esp
c002d430:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d436:	50                   	push   %eax
c002d437:	e8 66 56 ff ff       	call   c0022aa2 <lock_acquire>
c002d43c:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock.", thread_name ());
c002d43f:	e8 24 38 ff ff       	call   c0020c68 <thread_name>
c002d444:	83 ec 08             	sub    $0x8,%esp
c002d447:	50                   	push   %eax
c002d448:	68 f8 26 03 c0       	push   $0xc00326f8
c002d44d:	e8 6b e4 ff ff       	call   c002b8bd <msg>
c002d452:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i < NESTING_DEPTH; i++)
c002d455:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002d45c:	e9 f2 00 00 00       	jmp    c002d553 <test_priority_donate_chain+0x199>
    {
      char name[16];
      int thread_priority;

      snprintf (name, sizeof name, "thread %d", i);
c002d461:	ff 75 f4             	push   -0xc(%ebp)
c002d464:	68 05 27 03 c0       	push   $0xc0032705
c002d469:	6a 10                	push   $0x10
c002d46b:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d471:	50                   	push   %eax
c002d472:	e8 dc 9c ff ff       	call   c0027153 <snprintf>
c002d477:	83 c4 10             	add    $0x10,%esp
      thread_priority = PRI_MIN + i * 3;
c002d47a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d47d:	89 c2                	mov    %eax,%edx
c002d47f:	01 d2                	add    %edx,%edx
c002d481:	01 d0                	add    %edx,%eax
c002d483:	89 45 f0             	mov    %eax,-0x10(%ebp)
      lock_pairs[i].first = i < NESTING_DEPTH - 1 ? locks + i: NULL;
c002d486:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c002d48a:	7f 18                	jg     c002d4a4 <test_priority_donate_chain+0xea>
c002d48c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d48f:	89 d0                	mov    %edx,%eax
c002d491:	01 c0                	add    %eax,%eax
c002d493:	01 d0                	add    %edx,%eax
c002d495:	c1 e0 03             	shl    $0x3,%eax
c002d498:	89 c2                	mov    %eax,%edx
c002d49a:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d4a0:	01 c2                	add    %eax,%edx
c002d4a2:	eb 05                	jmp    c002d4a9 <test_priority_donate_chain+0xef>
c002d4a4:	ba 00 00 00 00       	mov    $0x0,%edx
c002d4a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d4ac:	89 94 c5 0c ff ff ff 	mov    %edx,-0xf4(%ebp,%eax,8)
      lock_pairs[i].second = locks + i - 1;
c002d4b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d4b6:	89 d0                	mov    %edx,%eax
c002d4b8:	01 c0                	add    %eax,%eax
c002d4ba:	01 d0                	add    %edx,%eax
c002d4bc:	c1 e0 03             	shl    $0x3,%eax
c002d4bf:	8d 50 e8             	lea    -0x18(%eax),%edx
c002d4c2:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d4c8:	01 c2                	add    %eax,%edx
c002d4ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d4cd:	89 94 c5 08 ff ff ff 	mov    %edx,-0xf8(%ebp,%eax,8)

      thread_create (name, thread_priority, donor_thread_func, lock_pairs + i);
c002d4d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d4d7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c002d4de:	8d 85 08 ff ff ff    	lea    -0xf8(%ebp),%eax
c002d4e4:	01 d0                	add    %edx,%eax
c002d4e6:	50                   	push   %eax
c002d4e7:	68 93 d5 02 c0       	push   $0xc002d593
c002d4ec:	ff 75 f0             	push   -0x10(%ebp)
c002d4ef:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d4f5:	50                   	push   %eax
c002d4f6:	e8 66 35 ff ff       	call   c0020a61 <thread_create>
c002d4fb:	83 c4 10             	add    $0x10,%esp
      msg ("%s should have priority %d.  Actual priority: %d.",
c002d4fe:	e8 8f 39 ff ff       	call   c0020e92 <thread_get_priority>
c002d503:	89 c3                	mov    %eax,%ebx
c002d505:	e8 5e 37 ff ff       	call   c0020c68 <thread_name>
c002d50a:	53                   	push   %ebx
c002d50b:	ff 75 f0             	push   -0x10(%ebp)
c002d50e:	50                   	push   %eax
c002d50f:	68 10 27 03 c0       	push   $0xc0032710
c002d514:	e8 a4 e3 ff ff       	call   c002b8bd <msg>
c002d519:	83 c4 10             	add    $0x10,%esp
          thread_name (), thread_priority, thread_get_priority ());

      snprintf (name, sizeof name, "interloper %d", i);
c002d51c:	ff 75 f4             	push   -0xc(%ebp)
c002d51f:	68 42 27 03 c0       	push   $0xc0032742
c002d524:	6a 10                	push   $0x10
c002d526:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d52c:	50                   	push   %eax
c002d52d:	e8 21 9c ff ff       	call   c0027153 <snprintf>
c002d532:	83 c4 10             	add    $0x10,%esp
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
c002d535:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d538:	48                   	dec    %eax
c002d539:	6a 00                	push   $0x0
c002d53b:	68 51 d6 02 c0       	push   $0xc002d651
c002d540:	50                   	push   %eax
c002d541:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d547:	50                   	push   %eax
c002d548:	e8 14 35 ff ff       	call   c0020a61 <thread_create>
c002d54d:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < NESTING_DEPTH; i++)
c002d550:	ff 45 f4             	incl   -0xc(%ebp)
c002d553:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
c002d557:	0f 8e 04 ff ff ff    	jle    c002d461 <test_priority_donate_chain+0xa7>
    }

  lock_release (&locks[0]);
c002d55d:	83 ec 0c             	sub    $0xc,%esp
c002d560:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d566:	50                   	push   %eax
c002d567:	e8 72 56 ff ff       	call   c0022bde <lock_release>
c002d56c:	83 c4 10             	add    $0x10,%esp
  msg ("%s finishing with priority %d.", thread_name (),
c002d56f:	e8 1e 39 ff ff       	call   c0020e92 <thread_get_priority>
c002d574:	89 c3                	mov    %eax,%ebx
c002d576:	e8 ed 36 ff ff       	call   c0020c68 <thread_name>
c002d57b:	83 ec 04             	sub    $0x4,%esp
c002d57e:	53                   	push   %ebx
c002d57f:	50                   	push   %eax
c002d580:	68 50 27 03 c0       	push   $0xc0032750
c002d585:	e8 33 e3 ff ff       	call   c002b8bd <msg>
c002d58a:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c002d58d:	90                   	nop
c002d58e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d591:	c9                   	leave  
c002d592:	c3                   	ret    

c002d593 <donor_thread_func>:

static void
donor_thread_func (void *locks_) 
{
c002d593:	55                   	push   %ebp
c002d594:	89 e5                	mov    %esp,%ebp
c002d596:	53                   	push   %ebx
c002d597:	83 ec 14             	sub    $0x14,%esp
  struct lock_pair *locks = locks_;
c002d59a:	8b 45 08             	mov    0x8(%ebp),%eax
c002d59d:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (locks->first)
c002d5a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d5a3:	8b 40 04             	mov    0x4(%eax),%eax
c002d5a6:	85 c0                	test   %eax,%eax
c002d5a8:	74 12                	je     c002d5bc <donor_thread_func+0x29>
    lock_acquire (locks->first);
c002d5aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d5ad:	8b 40 04             	mov    0x4(%eax),%eax
c002d5b0:	83 ec 0c             	sub    $0xc,%esp
c002d5b3:	50                   	push   %eax
c002d5b4:	e8 e9 54 ff ff       	call   c0022aa2 <lock_acquire>
c002d5b9:	83 c4 10             	add    $0x10,%esp

  lock_acquire (locks->second);
c002d5bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d5bf:	8b 00                	mov    (%eax),%eax
c002d5c1:	83 ec 0c             	sub    $0xc,%esp
c002d5c4:	50                   	push   %eax
c002d5c5:	e8 d8 54 ff ff       	call   c0022aa2 <lock_acquire>
c002d5ca:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock", thread_name ());
c002d5cd:	e8 96 36 ff ff       	call   c0020c68 <thread_name>
c002d5d2:	83 ec 08             	sub    $0x8,%esp
c002d5d5:	50                   	push   %eax
c002d5d6:	68 6f 27 03 c0       	push   $0xc003276f
c002d5db:	e8 dd e2 ff ff       	call   c002b8bd <msg>
c002d5e0:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->second);
c002d5e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d5e6:	8b 00                	mov    (%eax),%eax
c002d5e8:	83 ec 0c             	sub    $0xc,%esp
c002d5eb:	50                   	push   %eax
c002d5ec:	e8 ed 55 ff ff       	call   c0022bde <lock_release>
c002d5f1:	83 c4 10             	add    $0x10,%esp
  msg ("%s should have priority %d. Actual priority: %d", 
c002d5f4:	e8 99 38 ff ff       	call   c0020e92 <thread_get_priority>
c002d5f9:	89 c3                	mov    %eax,%ebx
c002d5fb:	e8 68 36 ff ff       	call   c0020c68 <thread_name>
c002d600:	53                   	push   %ebx
c002d601:	6a 15                	push   $0x15
c002d603:	50                   	push   %eax
c002d604:	68 7c 27 03 c0       	push   $0xc003277c
c002d609:	e8 af e2 ff ff       	call   c002b8bd <msg>
c002d60e:	83 c4 10             	add    $0x10,%esp
        thread_name (), (NESTING_DEPTH - 1) * 3,
        thread_get_priority ());

  if (locks->first)
c002d611:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d614:	8b 40 04             	mov    0x4(%eax),%eax
c002d617:	85 c0                	test   %eax,%eax
c002d619:	74 12                	je     c002d62d <donor_thread_func+0x9a>
    lock_release (locks->first);
c002d61b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d61e:	8b 40 04             	mov    0x4(%eax),%eax
c002d621:	83 ec 0c             	sub    $0xc,%esp
c002d624:	50                   	push   %eax
c002d625:	e8 b4 55 ff ff       	call   c0022bde <lock_release>
c002d62a:	83 c4 10             	add    $0x10,%esp

  msg ("%s finishing with priority %d.", thread_name (),
c002d62d:	e8 60 38 ff ff       	call   c0020e92 <thread_get_priority>
c002d632:	89 c3                	mov    %eax,%ebx
c002d634:	e8 2f 36 ff ff       	call   c0020c68 <thread_name>
c002d639:	83 ec 04             	sub    $0x4,%esp
c002d63c:	53                   	push   %ebx
c002d63d:	50                   	push   %eax
c002d63e:	68 50 27 03 c0       	push   $0xc0032750
c002d643:	e8 75 e2 ff ff       	call   c002b8bd <msg>
c002d648:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c002d64b:	90                   	nop
c002d64c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d64f:	c9                   	leave  
c002d650:	c3                   	ret    

c002d651 <interloper_thread_func>:

static void
interloper_thread_func (void *arg_ UNUSED)
{
c002d651:	55                   	push   %ebp
c002d652:	89 e5                	mov    %esp,%ebp
c002d654:	83 ec 08             	sub    $0x8,%esp
  msg ("%s finished.", thread_name ());
c002d657:	e8 0c 36 ff ff       	call   c0020c68 <thread_name>
c002d65c:	83 ec 08             	sub    $0x8,%esp
c002d65f:	50                   	push   %eax
c002d660:	68 ac 27 03 c0       	push   $0xc00327ac
c002d665:	e8 53 e2 ff ff       	call   c002b8bd <msg>
c002d66a:	83 c4 10             	add    $0x10,%esp
}
c002d66d:	90                   	nop
c002d66e:	c9                   	leave  
c002d66f:	c3                   	ret    

c002d670 <test_mlfqs_load_1>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_mlfqs_load_1 (void) 
{
c002d670:	55                   	push   %ebp
c002d671:	89 e5                	mov    %esp,%ebp
c002d673:	53                   	push   %ebx
c002d674:	83 ec 14             	sub    $0x14,%esp
  int64_t start_time;
  int elapsed;
  int load_avg;
  
  ASSERT (thread_mlfqs);
c002d677:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002d67c:	84 c0                	test   %al,%al
c002d67e:	75 1e                	jne    c002d69e <test_mlfqs_load_1+0x2e>
c002d680:	83 ec 0c             	sub    $0xc,%esp
c002d683:	68 d8 27 03 c0       	push   $0xc00327d8
c002d688:	68 e5 27 03 c0       	push   $0xc00327e5
c002d68d:	68 f4 29 03 c0       	push   $0xc00329f4
c002d692:	6a 18                	push   $0x18
c002d694:	68 fc 27 03 c0       	push   $0xc00327fc
c002d699:	e8 80 be ff ff       	call   c002951e <debug_panic>

  msg ("spinning for up to 45 seconds, please wait...");
c002d69e:	83 ec 0c             	sub    $0xc,%esp
c002d6a1:	68 20 28 03 c0       	push   $0xc0032820
c002d6a6:	e8 12 e2 ff ff       	call   c002b8bd <msg>
c002d6ab:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c002d6ae:	e8 f7 65 ff ff       	call   c0023caa <timer_ticks>
c002d6b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002d6b6:	89 55 f4             	mov    %edx,-0xc(%ebp)
  for (;;) 
    {
      load_avg = thread_get_load_avg ();
c002d6b9:	e8 f4 37 ff ff       	call   c0020eb2 <thread_get_load_avg>
c002d6be:	89 45 ec             	mov    %eax,-0x14(%ebp)
      ASSERT (load_avg >= 0);
c002d6c1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002d6c5:	79 1e                	jns    c002d6e5 <test_mlfqs_load_1+0x75>
c002d6c7:	83 ec 0c             	sub    $0xc,%esp
c002d6ca:	68 4e 28 03 c0       	push   $0xc003284e
c002d6cf:	68 e5 27 03 c0       	push   $0xc00327e5
c002d6d4:	68 f4 29 03 c0       	push   $0xc00329f4
c002d6d9:	6a 20                	push   $0x20
c002d6db:	68 fc 27 03 c0       	push   $0xc00327fc
c002d6e0:	e8 39 be ff ff       	call   c002951e <debug_panic>
      elapsed = timer_elapsed (start_time) / TIMER_FREQ;
c002d6e5:	83 ec 08             	sub    $0x8,%esp
c002d6e8:	ff 75 f4             	push   -0xc(%ebp)
c002d6eb:	ff 75 f0             	push   -0x10(%ebp)
c002d6ee:	e8 ec 65 ff ff       	call   c0023cdf <timer_elapsed>
c002d6f3:	83 c4 10             	add    $0x10,%esp
c002d6f6:	6a 00                	push   $0x0
c002d6f8:	6a 64                	push   $0x64
c002d6fa:	52                   	push   %edx
c002d6fb:	50                   	push   %eax
c002d6fc:	e8 27 b8 ff ff       	call   c0028f28 <__divdi3>
c002d701:	83 c4 10             	add    $0x10,%esp
c002d704:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (load_avg > 100)
c002d707:	83 7d ec 64          	cmpl   $0x64,-0x14(%ebp)
c002d70b:	7e 5a                	jle    c002d767 <test_mlfqs_load_1+0xf7>
        fail ("load average is %d.%02d "
c002d70d:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d710:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d715:	f7 eb                	imul   %ebx
c002d717:	c1 fa 05             	sar    $0x5,%edx
c002d71a:	89 d8                	mov    %ebx,%eax
c002d71c:	c1 f8 1f             	sar    $0x1f,%eax
c002d71f:	89 d1                	mov    %edx,%ecx
c002d721:	29 c1                	sub    %eax,%ecx
c002d723:	89 c8                	mov    %ecx,%eax
c002d725:	c1 e0 02             	shl    $0x2,%eax
c002d728:	01 c8                	add    %ecx,%eax
c002d72a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002d731:	01 d0                	add    %edx,%eax
c002d733:	c1 e0 02             	shl    $0x2,%eax
c002d736:	89 d9                	mov    %ebx,%ecx
c002d738:	29 c1                	sub    %eax,%ecx
c002d73a:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d73d:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d742:	f7 eb                	imul   %ebx
c002d744:	89 d0                	mov    %edx,%eax
c002d746:	c1 f8 05             	sar    $0x5,%eax
c002d749:	89 da                	mov    %ebx,%edx
c002d74b:	c1 fa 1f             	sar    $0x1f,%edx
c002d74e:	29 d0                	sub    %edx,%eax
c002d750:	ff 75 e8             	push   -0x18(%ebp)
c002d753:	51                   	push   %ecx
c002d754:	50                   	push   %eax
c002d755:	68 5c 28 03 c0       	push   $0xc003285c
c002d75a:	e8 a2 e1 ff ff       	call   c002b901 <fail>
c002d75f:	83 c4 10             	add    $0x10,%esp
c002d762:	e9 52 ff ff ff       	jmp    c002d6b9 <test_mlfqs_load_1+0x49>
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
c002d767:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c002d76b:	7f 1f                	jg     c002d78c <test_mlfqs_load_1+0x11c>
        break;
      else if (elapsed > 45)
c002d76d:	83 7d e8 2d          	cmpl   $0x2d,-0x18(%ebp)
c002d771:	0f 8e 42 ff ff ff    	jle    c002d6b9 <test_mlfqs_load_1+0x49>
        fail ("load average stayed below 0.5 for more than 45 seconds");
c002d777:	83 ec 0c             	sub    $0xc,%esp
c002d77a:	68 a8 28 03 c0       	push   $0xc00328a8
c002d77f:	e8 7d e1 ff ff       	call   c002b901 <fail>
c002d784:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002d787:	e9 2d ff ff ff       	jmp    c002d6b9 <test_mlfqs_load_1+0x49>
        break;
c002d78c:	90                   	nop
    }

  if (elapsed < 38)
c002d78d:	83 7d e8 25          	cmpl   $0x25,-0x18(%ebp)
c002d791:	7f 13                	jg     c002d7a6 <test_mlfqs_load_1+0x136>
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
c002d793:	83 ec 08             	sub    $0x8,%esp
c002d796:	ff 75 e8             	push   -0x18(%ebp)
c002d799:	68 e0 28 03 c0       	push   $0xc00328e0
c002d79e:	e8 5e e1 ff ff       	call   c002b901 <fail>
c002d7a3:	83 c4 10             	add    $0x10,%esp
  msg ("load average rose to 0.5 after %d seconds", elapsed);
c002d7a6:	83 ec 08             	sub    $0x8,%esp
c002d7a9:	ff 75 e8             	push   -0x18(%ebp)
c002d7ac:	68 14 29 03 c0       	push   $0xc0032914
c002d7b1:	e8 07 e1 ff ff       	call   c002b8bd <msg>
c002d7b6:	83 c4 10             	add    $0x10,%esp

  msg ("sleeping for another 10 seconds, please wait...");
c002d7b9:	83 ec 0c             	sub    $0xc,%esp
c002d7bc:	68 40 29 03 c0       	push   $0xc0032940
c002d7c1:	e8 f7 e0 ff ff       	call   c002b8bd <msg>
c002d7c6:	83 c4 10             	add    $0x10,%esp
  timer_sleep (TIMER_FREQ * 10);
c002d7c9:	83 ec 08             	sub    $0x8,%esp
c002d7cc:	6a 00                	push   $0x0
c002d7ce:	68 e8 03 00 00       	push   $0x3e8
c002d7d3:	e8 26 65 ff ff       	call   c0023cfe <timer_sleep>
c002d7d8:	83 c4 10             	add    $0x10,%esp

  load_avg = thread_get_load_avg ();
c002d7db:	e8 d2 36 ff ff       	call   c0020eb2 <thread_get_load_avg>
c002d7e0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (load_avg < 0)
c002d7e3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002d7e7:	79 10                	jns    c002d7f9 <test_mlfqs_load_1+0x189>
    fail ("load average fell below 0");
c002d7e9:	83 ec 0c             	sub    $0xc,%esp
c002d7ec:	68 70 29 03 c0       	push   $0xc0032970
c002d7f1:	e8 0b e1 ff ff       	call   c002b901 <fail>
c002d7f6:	83 c4 10             	add    $0x10,%esp
  if (load_avg > 50)
c002d7f9:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c002d7fd:	7e 10                	jle    c002d80f <test_mlfqs_load_1+0x19f>
    fail ("load average stayed above 0.5 for more than 10 seconds");
c002d7ff:	83 ec 0c             	sub    $0xc,%esp
c002d802:	68 8c 29 03 c0       	push   $0xc003298c
c002d807:	e8 f5 e0 ff ff       	call   c002b901 <fail>
c002d80c:	83 c4 10             	add    $0x10,%esp
  msg ("load average fell back below 0.5 (to %d.%02d)",
c002d80f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d812:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d817:	f7 eb                	imul   %ebx
c002d819:	c1 fa 05             	sar    $0x5,%edx
c002d81c:	89 d8                	mov    %ebx,%eax
c002d81e:	c1 f8 1f             	sar    $0x1f,%eax
c002d821:	29 c2                	sub    %eax,%edx
c002d823:	89 d1                	mov    %edx,%ecx
c002d825:	89 c8                	mov    %ecx,%eax
c002d827:	c1 e0 02             	shl    $0x2,%eax
c002d82a:	01 c8                	add    %ecx,%eax
c002d82c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002d833:	01 d0                	add    %edx,%eax
c002d835:	c1 e0 02             	shl    $0x2,%eax
c002d838:	29 c3                	sub    %eax,%ebx
c002d83a:	89 d9                	mov    %ebx,%ecx
c002d83c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d83f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d844:	f7 eb                	imul   %ebx
c002d846:	89 d0                	mov    %edx,%eax
c002d848:	c1 f8 05             	sar    $0x5,%eax
c002d84b:	c1 fb 1f             	sar    $0x1f,%ebx
c002d84e:	89 da                	mov    %ebx,%edx
c002d850:	29 d0                	sub    %edx,%eax
c002d852:	83 ec 04             	sub    $0x4,%esp
c002d855:	51                   	push   %ecx
c002d856:	50                   	push   %eax
c002d857:	68 c4 29 03 c0       	push   $0xc00329c4
c002d85c:	e8 5c e0 ff ff       	call   c002b8bd <msg>
c002d861:	83 c4 10             	add    $0x10,%esp
       load_avg / 100, load_avg % 100);

  pass ();
c002d864:	e8 ef e0 ff ff       	call   c002b958 <pass>
}
c002d869:	90                   	nop
c002d86a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d86d:	c9                   	leave  
c002d86e:	c3                   	ret    

c002d86f <test_mlfqs_load_60>:

#define THREAD_CNT 60

void
test_mlfqs_load_60 (void) 
{
c002d86f:	55                   	push   %ebp
c002d870:	89 e5                	mov    %esp,%ebp
c002d872:	53                   	push   %ebx
c002d873:	83 ec 34             	sub    $0x34,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002d876:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002d87b:	84 c0                	test   %al,%al
c002d87d:	75 1e                	jne    c002d89d <test_mlfqs_load_60+0x2e>
c002d87f:	83 ec 0c             	sub    $0xc,%esp
c002d882:	68 08 2a 03 c0       	push   $0xc0032a08
c002d887:	68 15 2a 03 c0       	push   $0xc0032a15
c002d88c:	68 c8 2a 03 c0       	push   $0xc0032ac8
c002d891:	6a 77                	push   $0x77
c002d893:	68 2c 2a 03 c0       	push   $0xc0032a2c
c002d898:	e8 81 bc ff ff       	call   c002951e <debug_panic>

  start_time = timer_ticks ();
c002d89d:	e8 08 64 ff ff       	call   c0023caa <timer_ticks>
c002d8a2:	a3 50 54 03 c0       	mov    %eax,0xc0035450
c002d8a7:	89 15 54 54 03 c0    	mov    %edx,0xc0035454
  msg ("Starting %d niced load threads...", THREAD_CNT);
c002d8ad:	83 ec 08             	sub    $0x8,%esp
c002d8b0:	6a 3c                	push   $0x3c
c002d8b2:	68 50 2a 03 c0       	push   $0xc0032a50
c002d8b7:	e8 01 e0 ff ff       	call   c002b8bd <msg>
c002d8bc:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002d8bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d8c6:	eb 2e                	jmp    c002d8f6 <test_mlfqs_load_60+0x87>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002d8c8:	ff 75 f4             	push   -0xc(%ebp)
c002d8cb:	68 72 2a 03 c0       	push   $0xc0032a72
c002d8d0:	6a 10                	push   $0x10
c002d8d2:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d8d5:	50                   	push   %eax
c002d8d6:	e8 78 98 ff ff       	call   c0027153 <snprintf>
c002d8db:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
c002d8de:	6a 00                	push   $0x0
c002d8e0:	68 07 da 02 c0       	push   $0xc002da07
c002d8e5:	6a 1f                	push   $0x1f
c002d8e7:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d8ea:	50                   	push   %eax
c002d8eb:	e8 71 31 ff ff       	call   c0020a61 <thread_create>
c002d8f0:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002d8f3:	ff 45 f4             	incl   -0xc(%ebp)
c002d8f6:	83 7d f4 3b          	cmpl   $0x3b,-0xc(%ebp)
c002d8fa:	7e cc                	jle    c002d8c8 <test_mlfqs_load_60+0x59>
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002d8fc:	a1 50 54 03 c0       	mov    0xc0035450,%eax
c002d901:	8b 15 54 54 03 c0    	mov    0xc0035454,%edx
c002d907:	83 ec 08             	sub    $0x8,%esp
c002d90a:	52                   	push   %edx
c002d90b:	50                   	push   %eax
c002d90c:	e8 ce 63 ff ff       	call   c0023cdf <timer_elapsed>
c002d911:	83 c4 10             	add    $0x10,%esp
  msg ("Starting threads took %d seconds.",
c002d914:	6a 00                	push   $0x0
c002d916:	6a 64                	push   $0x64
c002d918:	52                   	push   %edx
c002d919:	50                   	push   %eax
c002d91a:	e8 09 b6 ff ff       	call   c0028f28 <__divdi3>
c002d91f:	83 c4 10             	add    $0x10,%esp
c002d922:	83 ec 04             	sub    $0x4,%esp
c002d925:	52                   	push   %edx
c002d926:	50                   	push   %eax
c002d927:	68 7c 2a 03 c0       	push   $0xc0032a7c
c002d92c:	e8 8c df ff ff       	call   c002b8bd <msg>
c002d931:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < 90; i++) 
c002d934:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d93b:	e9 b6 00 00 00       	jmp    c002d9f6 <test_mlfqs_load_60+0x187>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002d940:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d943:	8d 50 05             	lea    0x5(%eax),%edx
c002d946:	89 d0                	mov    %edx,%eax
c002d948:	c1 e0 02             	shl    $0x2,%eax
c002d94b:	01 d0                	add    %edx,%eax
c002d94d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002d954:	01 d0                	add    %edx,%eax
c002d956:	c1 e0 03             	shl    $0x3,%eax
c002d959:	89 c1                	mov    %eax,%ecx
c002d95b:	89 c3                	mov    %eax,%ebx
c002d95d:	c1 fb 1f             	sar    $0x1f,%ebx
c002d960:	a1 50 54 03 c0       	mov    0xc0035450,%eax
c002d965:	8b 15 54 54 03 c0    	mov    0xc0035454,%edx
c002d96b:	01 c8                	add    %ecx,%eax
c002d96d:	11 da                	adc    %ebx,%edx
c002d96f:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002d972:	89 55 ec             	mov    %edx,-0x14(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002d975:	e8 30 63 ff ff       	call   c0023caa <timer_ticks>
c002d97a:	89 c1                	mov    %eax,%ecx
c002d97c:	89 d3                	mov    %edx,%ebx
c002d97e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d981:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002d984:	29 c8                	sub    %ecx,%eax
c002d986:	19 da                	sbb    %ebx,%edx
c002d988:	83 ec 08             	sub    $0x8,%esp
c002d98b:	52                   	push   %edx
c002d98c:	50                   	push   %eax
c002d98d:	e8 6c 63 ff ff       	call   c0023cfe <timer_sleep>
c002d992:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002d995:	e8 18 35 ff ff       	call   c0020eb2 <thread_get_load_avg>
c002d99a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c002d99d:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002d9a0:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d9a5:	f7 eb                	imul   %ebx
c002d9a7:	c1 fa 05             	sar    $0x5,%edx
c002d9aa:	89 d8                	mov    %ebx,%eax
c002d9ac:	c1 f8 1f             	sar    $0x1f,%eax
c002d9af:	89 d1                	mov    %edx,%ecx
c002d9b1:	29 c1                	sub    %eax,%ecx
c002d9b3:	89 c8                	mov    %ecx,%eax
c002d9b5:	c1 e0 02             	shl    $0x2,%eax
c002d9b8:	01 c8                	add    %ecx,%eax
c002d9ba:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002d9c1:	01 d0                	add    %edx,%eax
c002d9c3:	c1 e0 02             	shl    $0x2,%eax
c002d9c6:	29 c3                	sub    %eax,%ebx
c002d9c8:	89 d9                	mov    %ebx,%ecx
c002d9ca:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002d9cd:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d9d2:	f7 eb                	imul   %ebx
c002d9d4:	c1 fa 05             	sar    $0x5,%edx
c002d9d7:	89 d8                	mov    %ebx,%eax
c002d9d9:	c1 f8 1f             	sar    $0x1f,%eax
c002d9dc:	29 c2                	sub    %eax,%edx
c002d9de:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d9e1:	01 c0                	add    %eax,%eax
c002d9e3:	51                   	push   %ecx
c002d9e4:	52                   	push   %edx
c002d9e5:	50                   	push   %eax
c002d9e6:	68 a0 2a 03 c0       	push   $0xc0032aa0
c002d9eb:	e8 cd de ff ff       	call   c002b8bd <msg>
c002d9f0:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 90; i++) 
c002d9f3:	ff 45 f4             	incl   -0xc(%ebp)
c002d9f6:	83 7d f4 59          	cmpl   $0x59,-0xc(%ebp)
c002d9fa:	0f 8e 40 ff ff ff    	jle    c002d940 <test_mlfqs_load_60+0xd1>
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002da00:	90                   	nop
c002da01:	90                   	nop
c002da02:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002da05:	c9                   	leave  
c002da06:	c3                   	ret    

c002da07 <load_thread>:

static void
load_thread (void *aux UNUSED) 
{
c002da07:	55                   	push   %ebp
c002da08:	89 e5                	mov    %esp,%ebp
c002da0a:	53                   	push   %ebx
c002da0b:	83 ec 24             	sub    $0x24,%esp
  int64_t sleep_time = 10 * TIMER_FREQ;
c002da0e:	c7 45 f0 e8 03 00 00 	movl   $0x3e8,-0x10(%ebp)
c002da15:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
c002da1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002da1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002da22:	05 70 17 00 00       	add    $0x1770,%eax
c002da27:	83 d2 00             	adc    $0x0,%edx
c002da2a:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002da2d:	89 55 ec             	mov    %edx,-0x14(%ebp)
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;
c002da30:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002da33:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002da36:	05 70 17 00 00       	add    $0x1770,%eax
c002da3b:	83 d2 00             	adc    $0x0,%edx
c002da3e:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002da41:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  thread_set_nice (20);
c002da44:	83 ec 0c             	sub    $0xc,%esp
c002da47:	6a 14                	push   $0x14
c002da49:	e8 54 34 ff ff       	call   c0020ea2 <thread_set_nice>
c002da4e:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (start_time));
c002da51:	a1 50 54 03 c0       	mov    0xc0035450,%eax
c002da56:	8b 15 54 54 03 c0    	mov    0xc0035454,%edx
c002da5c:	83 ec 08             	sub    $0x8,%esp
c002da5f:	52                   	push   %edx
c002da60:	50                   	push   %eax
c002da61:	e8 79 62 ff ff       	call   c0023cdf <timer_elapsed>
c002da66:	83 c4 10             	add    $0x10,%esp
c002da69:	89 c1                	mov    %eax,%ecx
c002da6b:	89 d3                	mov    %edx,%ebx
c002da6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002da70:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002da73:	29 c8                	sub    %ecx,%eax
c002da75:	19 da                	sbb    %ebx,%edx
c002da77:	83 ec 08             	sub    $0x8,%esp
c002da7a:	52                   	push   %edx
c002da7b:	50                   	push   %eax
c002da7c:	e8 7d 62 ff ff       	call   c0023cfe <timer_sleep>
c002da81:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c002da84:	eb 01                	jmp    c002da87 <load_thread+0x80>
    continue;
c002da86:	90                   	nop
  while (timer_elapsed (start_time) < spin_time)
c002da87:	a1 50 54 03 c0       	mov    0xc0035450,%eax
c002da8c:	8b 15 54 54 03 c0    	mov    0xc0035454,%edx
c002da92:	83 ec 08             	sub    $0x8,%esp
c002da95:	52                   	push   %edx
c002da96:	50                   	push   %eax
c002da97:	e8 43 62 ff ff       	call   c0023cdf <timer_elapsed>
c002da9c:	83 c4 10             	add    $0x10,%esp
c002da9f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002daa2:	89 d0                	mov    %edx,%eax
c002daa4:	1b 45 ec             	sbb    -0x14(%ebp),%eax
c002daa7:	7c dd                	jl     c002da86 <load_thread+0x7f>
  timer_sleep (exit_time - timer_elapsed (start_time));
c002daa9:	a1 50 54 03 c0       	mov    0xc0035450,%eax
c002daae:	8b 15 54 54 03 c0    	mov    0xc0035454,%edx
c002dab4:	83 ec 08             	sub    $0x8,%esp
c002dab7:	52                   	push   %edx
c002dab8:	50                   	push   %eax
c002dab9:	e8 21 62 ff ff       	call   c0023cdf <timer_elapsed>
c002dabe:	83 c4 10             	add    $0x10,%esp
c002dac1:	89 c1                	mov    %eax,%ecx
c002dac3:	89 d3                	mov    %edx,%ebx
c002dac5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002dac8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002dacb:	29 c8                	sub    %ecx,%eax
c002dacd:	19 da                	sbb    %ebx,%edx
c002dacf:	83 ec 08             	sub    $0x8,%esp
c002dad2:	52                   	push   %edx
c002dad3:	50                   	push   %eax
c002dad4:	e8 25 62 ff ff       	call   c0023cfe <timer_sleep>
c002dad9:	83 c4 10             	add    $0x10,%esp
}
c002dadc:	90                   	nop
c002dadd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002dae0:	c9                   	leave  
c002dae1:	c3                   	ret    

c002dae2 <test_mlfqs_load_avg>:

#define THREAD_CNT 60

void
test_mlfqs_load_avg (void) 
{
c002dae2:	55                   	push   %ebp
c002dae3:	89 e5                	mov    %esp,%ebp
c002dae5:	53                   	push   %ebx
c002dae6:	83 ec 34             	sub    $0x34,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002dae9:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002daee:	84 c0                	test   %al,%al
c002daf0:	75 21                	jne    c002db13 <test_mlfqs_load_avg+0x31>
c002daf2:	83 ec 0c             	sub    $0xc,%esp
c002daf5:	68 dc 2a 03 c0       	push   $0xc0032adc
c002dafa:	68 e9 2a 03 c0       	push   $0xc0032ae9
c002daff:	68 98 2b 03 c0       	push   $0xc0032b98
c002db04:	68 82 00 00 00       	push   $0x82
c002db09:	68 00 2b 03 c0       	push   $0xc0032b00
c002db0e:	e8 0b ba ff ff       	call   c002951e <debug_panic>

  start_time = timer_ticks ();
c002db13:	e8 92 61 ff ff       	call   c0023caa <timer_ticks>
c002db18:	a3 58 54 03 c0       	mov    %eax,0xc0035458
c002db1d:	89 15 5c 54 03 c0    	mov    %edx,0xc003545c
  msg ("Starting %d load threads...", THREAD_CNT);
c002db23:	83 ec 08             	sub    $0x8,%esp
c002db26:	6a 3c                	push   $0x3c
c002db28:	68 25 2b 03 c0       	push   $0xc0032b25
c002db2d:	e8 8b dd ff ff       	call   c002b8bd <msg>
c002db32:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002db35:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002db3c:	eb 30                	jmp    c002db6e <test_mlfqs_load_avg+0x8c>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002db3e:	ff 75 f4             	push   -0xc(%ebp)
c002db41:	68 41 2b 03 c0       	push   $0xc0032b41
c002db46:	6a 10                	push   $0x10
c002db48:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002db4b:	50                   	push   %eax
c002db4c:	e8 02 96 ff ff       	call   c0027153 <snprintf>
c002db51:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
c002db54:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002db57:	50                   	push   %eax
c002db58:	68 8c dc 02 c0       	push   $0xc002dc8c
c002db5d:	6a 1f                	push   $0x1f
c002db5f:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002db62:	50                   	push   %eax
c002db63:	e8 f9 2e ff ff       	call   c0020a61 <thread_create>
c002db68:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002db6b:	ff 45 f4             	incl   -0xc(%ebp)
c002db6e:	83 7d f4 3b          	cmpl   $0x3b,-0xc(%ebp)
c002db72:	7e ca                	jle    c002db3e <test_mlfqs_load_avg+0x5c>
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002db74:	a1 58 54 03 c0       	mov    0xc0035458,%eax
c002db79:	8b 15 5c 54 03 c0    	mov    0xc003545c,%edx
c002db7f:	83 ec 08             	sub    $0x8,%esp
c002db82:	52                   	push   %edx
c002db83:	50                   	push   %eax
c002db84:	e8 56 61 ff ff       	call   c0023cdf <timer_elapsed>
c002db89:	83 c4 10             	add    $0x10,%esp
  msg ("Starting threads took %d seconds.",
c002db8c:	6a 00                	push   $0x0
c002db8e:	6a 64                	push   $0x64
c002db90:	52                   	push   %edx
c002db91:	50                   	push   %eax
c002db92:	e8 91 b3 ff ff       	call   c0028f28 <__divdi3>
c002db97:	83 c4 10             	add    $0x10,%esp
c002db9a:	83 ec 04             	sub    $0x4,%esp
c002db9d:	52                   	push   %edx
c002db9e:	50                   	push   %eax
c002db9f:	68 4c 2b 03 c0       	push   $0xc0032b4c
c002dba4:	e8 14 dd ff ff       	call   c002b8bd <msg>
c002dba9:	83 c4 10             	add    $0x10,%esp
  thread_set_nice (-20);
c002dbac:	83 ec 0c             	sub    $0xc,%esp
c002dbaf:	6a ec                	push   $0xffffffec
c002dbb1:	e8 ec 32 ff ff       	call   c0020ea2 <thread_set_nice>
c002dbb6:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 90; i++) 
c002dbb9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002dbc0:	e9 b6 00 00 00       	jmp    c002dc7b <test_mlfqs_load_avg+0x199>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002dbc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dbc8:	8d 50 05             	lea    0x5(%eax),%edx
c002dbcb:	89 d0                	mov    %edx,%eax
c002dbcd:	c1 e0 02             	shl    $0x2,%eax
c002dbd0:	01 d0                	add    %edx,%eax
c002dbd2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002dbd9:	01 d0                	add    %edx,%eax
c002dbdb:	c1 e0 03             	shl    $0x3,%eax
c002dbde:	89 c1                	mov    %eax,%ecx
c002dbe0:	89 c3                	mov    %eax,%ebx
c002dbe2:	c1 fb 1f             	sar    $0x1f,%ebx
c002dbe5:	a1 58 54 03 c0       	mov    0xc0035458,%eax
c002dbea:	8b 15 5c 54 03 c0    	mov    0xc003545c,%edx
c002dbf0:	01 c8                	add    %ecx,%eax
c002dbf2:	11 da                	adc    %ebx,%edx
c002dbf4:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002dbf7:	89 55 ec             	mov    %edx,-0x14(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002dbfa:	e8 ab 60 ff ff       	call   c0023caa <timer_ticks>
c002dbff:	89 c1                	mov    %eax,%ecx
c002dc01:	89 d3                	mov    %edx,%ebx
c002dc03:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002dc06:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002dc09:	29 c8                	sub    %ecx,%eax
c002dc0b:	19 da                	sbb    %ebx,%edx
c002dc0d:	83 ec 08             	sub    $0x8,%esp
c002dc10:	52                   	push   %edx
c002dc11:	50                   	push   %eax
c002dc12:	e8 e7 60 ff ff       	call   c0023cfe <timer_sleep>
c002dc17:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002dc1a:	e8 93 32 ff ff       	call   c0020eb2 <thread_get_load_avg>
c002dc1f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c002dc22:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dc25:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002dc2a:	f7 eb                	imul   %ebx
c002dc2c:	c1 fa 05             	sar    $0x5,%edx
c002dc2f:	89 d8                	mov    %ebx,%eax
c002dc31:	c1 f8 1f             	sar    $0x1f,%eax
c002dc34:	89 d1                	mov    %edx,%ecx
c002dc36:	29 c1                	sub    %eax,%ecx
c002dc38:	89 c8                	mov    %ecx,%eax
c002dc3a:	c1 e0 02             	shl    $0x2,%eax
c002dc3d:	01 c8                	add    %ecx,%eax
c002dc3f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002dc46:	01 d0                	add    %edx,%eax
c002dc48:	c1 e0 02             	shl    $0x2,%eax
c002dc4b:	29 c3                	sub    %eax,%ebx
c002dc4d:	89 d9                	mov    %ebx,%ecx
c002dc4f:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dc52:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002dc57:	f7 eb                	imul   %ebx
c002dc59:	c1 fa 05             	sar    $0x5,%edx
c002dc5c:	89 d8                	mov    %ebx,%eax
c002dc5e:	c1 f8 1f             	sar    $0x1f,%eax
c002dc61:	29 c2                	sub    %eax,%edx
c002dc63:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dc66:	01 c0                	add    %eax,%eax
c002dc68:	51                   	push   %ecx
c002dc69:	52                   	push   %edx
c002dc6a:	50                   	push   %eax
c002dc6b:	68 70 2b 03 c0       	push   $0xc0032b70
c002dc70:	e8 48 dc ff ff       	call   c002b8bd <msg>
c002dc75:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 90; i++) 
c002dc78:	ff 45 f4             	incl   -0xc(%ebp)
c002dc7b:	83 7d f4 59          	cmpl   $0x59,-0xc(%ebp)
c002dc7f:	0f 8e 40 ff ff ff    	jle    c002dbc5 <test_mlfqs_load_avg+0xe3>
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002dc85:	90                   	nop
c002dc86:	90                   	nop
c002dc87:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002dc8a:	c9                   	leave  
c002dc8b:	c3                   	ret    

c002dc8c <load_thread>:

static void
load_thread (void *seq_no_) 
{
c002dc8c:	55                   	push   %ebp
c002dc8d:	89 e5                	mov    %esp,%ebp
c002dc8f:	57                   	push   %edi
c002dc90:	56                   	push   %esi
c002dc91:	53                   	push   %ebx
c002dc92:	83 ec 1c             	sub    $0x1c,%esp
  int seq_no = (int) seq_no_;
c002dc95:	8b 45 08             	mov    0x8(%ebp),%eax
c002dc98:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  int sleep_time = TIMER_FREQ * (10 + seq_no);
c002dc9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002dc9e:	8d 50 0a             	lea    0xa(%eax),%edx
c002dca1:	89 d0                	mov    %edx,%eax
c002dca3:	c1 e0 02             	shl    $0x2,%eax
c002dca6:	01 d0                	add    %edx,%eax
c002dca8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002dcaf:	01 d0                	add    %edx,%eax
c002dcb1:	c1 e0 02             	shl    $0x2,%eax
c002dcb4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
c002dcb7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002dcba:	05 70 17 00 00       	add    $0x1770,%eax
c002dcbf:	89 45 dc             	mov    %eax,-0x24(%ebp)
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);
c002dcc2:	c7 45 d8 e0 2e 00 00 	movl   $0x2ee0,-0x28(%ebp)

  timer_sleep (sleep_time - timer_elapsed (start_time));
c002dcc9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002dccc:	89 c6                	mov    %eax,%esi
c002dcce:	89 c7                	mov    %eax,%edi
c002dcd0:	c1 ff 1f             	sar    $0x1f,%edi
c002dcd3:	a1 58 54 03 c0       	mov    0xc0035458,%eax
c002dcd8:	8b 15 5c 54 03 c0    	mov    0xc003545c,%edx
c002dcde:	83 ec 08             	sub    $0x8,%esp
c002dce1:	52                   	push   %edx
c002dce2:	50                   	push   %eax
c002dce3:	e8 f7 5f ff ff       	call   c0023cdf <timer_elapsed>
c002dce8:	83 c4 10             	add    $0x10,%esp
c002dceb:	89 c1                	mov    %eax,%ecx
c002dced:	89 d3                	mov    %edx,%ebx
c002dcef:	89 f0                	mov    %esi,%eax
c002dcf1:	89 fa                	mov    %edi,%edx
c002dcf3:	29 c8                	sub    %ecx,%eax
c002dcf5:	19 da                	sbb    %ebx,%edx
c002dcf7:	83 ec 08             	sub    $0x8,%esp
c002dcfa:	52                   	push   %edx
c002dcfb:	50                   	push   %eax
c002dcfc:	e8 fd 5f ff ff       	call   c0023cfe <timer_sleep>
c002dd01:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c002dd04:	eb 01                	jmp    c002dd07 <load_thread+0x7b>
    continue;
c002dd06:	90                   	nop
  while (timer_elapsed (start_time) < spin_time)
c002dd07:	a1 58 54 03 c0       	mov    0xc0035458,%eax
c002dd0c:	8b 15 5c 54 03 c0    	mov    0xc003545c,%edx
c002dd12:	83 ec 08             	sub    $0x8,%esp
c002dd15:	52                   	push   %edx
c002dd16:	50                   	push   %eax
c002dd17:	e8 c3 5f ff ff       	call   c0023cdf <timer_elapsed>
c002dd1c:	83 c4 10             	add    $0x10,%esp
c002dd1f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
c002dd22:	89 cb                	mov    %ecx,%ebx
c002dd24:	c1 fb 1f             	sar    $0x1f,%ebx
c002dd27:	39 c8                	cmp    %ecx,%eax
c002dd29:	89 d0                	mov    %edx,%eax
c002dd2b:	19 d8                	sbb    %ebx,%eax
c002dd2d:	7c d7                	jl     c002dd06 <load_thread+0x7a>
  timer_sleep (exit_time - timer_elapsed (start_time));
c002dd2f:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002dd32:	89 c6                	mov    %eax,%esi
c002dd34:	89 c7                	mov    %eax,%edi
c002dd36:	c1 ff 1f             	sar    $0x1f,%edi
c002dd39:	a1 58 54 03 c0       	mov    0xc0035458,%eax
c002dd3e:	8b 15 5c 54 03 c0    	mov    0xc003545c,%edx
c002dd44:	83 ec 08             	sub    $0x8,%esp
c002dd47:	52                   	push   %edx
c002dd48:	50                   	push   %eax
c002dd49:	e8 91 5f ff ff       	call   c0023cdf <timer_elapsed>
c002dd4e:	83 c4 10             	add    $0x10,%esp
c002dd51:	89 c1                	mov    %eax,%ecx
c002dd53:	89 d3                	mov    %edx,%ebx
c002dd55:	89 f0                	mov    %esi,%eax
c002dd57:	89 fa                	mov    %edi,%edx
c002dd59:	29 c8                	sub    %ecx,%eax
c002dd5b:	19 da                	sbb    %ebx,%edx
c002dd5d:	83 ec 08             	sub    $0x8,%esp
c002dd60:	52                   	push   %edx
c002dd61:	50                   	push   %eax
c002dd62:	e8 97 5f ff ff       	call   c0023cfe <timer_sleep>
c002dd67:	83 c4 10             	add    $0x10,%esp
}
c002dd6a:	90                   	nop
c002dd6b:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002dd6e:	5b                   	pop    %ebx
c002dd6f:	5e                   	pop    %esi
c002dd70:	5f                   	pop    %edi
c002dd71:	5d                   	pop    %ebp
c002dd72:	c3                   	ret    

c002dd73 <test_mlfqs_recent_1>:
/* Sensitive to assumption that recent_cpu updates happen exactly
   when timer_ticks() % TIMER_FREQ == 0. */

void
test_mlfqs_recent_1 (void) 
{
c002dd73:	55                   	push   %ebp
c002dd74:	89 e5                	mov    %esp,%ebp
c002dd76:	57                   	push   %edi
c002dd77:	56                   	push   %esi
c002dd78:	53                   	push   %ebx
c002dd79:	83 ec 2c             	sub    $0x2c,%esp
  int64_t start_time;
  int last_elapsed = 0;
c002dd7c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  
  ASSERT (thread_mlfqs);
c002dd83:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002dd88:	84 c0                	test   %al,%al
c002dd8a:	75 1e                	jne    c002ddaa <test_mlfqs_recent_1+0x37>
c002dd8c:	83 ec 0c             	sub    $0xc,%esp
c002dd8f:	68 ac 2b 03 c0       	push   $0xc0032bac
c002dd94:	68 b9 2b 03 c0       	push   $0xc0032bb9
c002dd99:	68 7c 2c 03 c0       	push   $0xc0032c7c
c002dd9e:	6a 73                	push   $0x73
c002dda0:	68 d0 2b 03 c0       	push   $0xc0032bd0
c002dda5:	e8 74 b7 ff ff       	call   c002951e <debug_panic>

  do 
    {
      msg ("Sleeping 10 seconds to allow recent_cpu to decay, please wait...");
c002ddaa:	83 ec 0c             	sub    $0xc,%esp
c002ddad:	68 f8 2b 03 c0       	push   $0xc0032bf8
c002ddb2:	e8 06 db ff ff       	call   c002b8bd <msg>
c002ddb7:	83 c4 10             	add    $0x10,%esp
      start_time = timer_ticks ();
c002ddba:	e8 eb 5e ff ff       	call   c0023caa <timer_ticks>
c002ddbf:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002ddc2:	89 55 dc             	mov    %edx,-0x24(%ebp)
      timer_sleep (DIV_ROUND_UP (start_time, TIMER_FREQ) - start_time
c002ddc5:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002ddc8:	8b 55 dc             	mov    -0x24(%ebp),%edx
c002ddcb:	83 c0 63             	add    $0x63,%eax
c002ddce:	83 d2 00             	adc    $0x0,%edx
c002ddd1:	6a 00                	push   $0x0
c002ddd3:	6a 64                	push   $0x64
c002ddd5:	52                   	push   %edx
c002ddd6:	50                   	push   %eax
c002ddd7:	e8 4c b1 ff ff       	call   c0028f28 <__divdi3>
c002dddc:	83 c4 10             	add    $0x10,%esp
c002dddf:	2b 45 d8             	sub    -0x28(%ebp),%eax
c002dde2:	1b 55 dc             	sbb    -0x24(%ebp),%edx
c002dde5:	05 e8 03 00 00       	add    $0x3e8,%eax
c002ddea:	83 d2 00             	adc    $0x0,%edx
c002dded:	83 ec 08             	sub    $0x8,%esp
c002ddf0:	52                   	push   %edx
c002ddf1:	50                   	push   %eax
c002ddf2:	e8 07 5f ff ff       	call   c0023cfe <timer_sleep>
c002ddf7:	83 c4 10             	add    $0x10,%esp
                   + 10 * TIMER_FREQ);
    }
  while (thread_get_recent_cpu () > 700);
c002ddfa:	e8 bd 30 ff ff       	call   c0020ebc <thread_get_recent_cpu>
c002ddff:	3d bc 02 00 00       	cmp    $0x2bc,%eax
c002de04:	7f a4                	jg     c002ddaa <test_mlfqs_recent_1+0x37>

  start_time = timer_ticks ();
c002de06:	e8 9f 5e ff ff       	call   c0023caa <timer_ticks>
c002de0b:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002de0e:	89 55 dc             	mov    %edx,-0x24(%ebp)
  for (;;) 
    {
      int elapsed = timer_elapsed (start_time);
c002de11:	83 ec 08             	sub    $0x8,%esp
c002de14:	ff 75 dc             	push   -0x24(%ebp)
c002de17:	ff 75 d8             	push   -0x28(%ebp)
c002de1a:	e8 c0 5e ff ff       	call   c0023cdf <timer_elapsed>
c002de1f:	83 c4 10             	add    $0x10,%esp
c002de22:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (elapsed % (TIMER_FREQ * 2) == 0 && elapsed > last_elapsed) 
c002de25:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002de28:	b9 c8 00 00 00       	mov    $0xc8,%ecx
c002de2d:	99                   	cltd   
c002de2e:	f7 f9                	idiv   %ecx
c002de30:	89 d0                	mov    %edx,%eax
c002de32:	85 c0                	test   %eax,%eax
c002de34:	0f 85 db 00 00 00    	jne    c002df15 <test_mlfqs_recent_1+0x1a2>
c002de3a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002de3d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002de40:	0f 8e cf 00 00 00    	jle    c002df15 <test_mlfqs_recent_1+0x1a2>
        {
          int recent_cpu = thread_get_recent_cpu ();
c002de46:	e8 71 30 ff ff       	call   c0020ebc <thread_get_recent_cpu>
c002de4b:	89 45 d0             	mov    %eax,-0x30(%ebp)
          int load_avg = thread_get_load_avg ();
c002de4e:	e8 5f 30 ff ff       	call   c0020eb2 <thread_get_load_avg>
c002de53:	89 45 cc             	mov    %eax,-0x34(%ebp)
          int elapsed_seconds = elapsed / TIMER_FREQ;
c002de56:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c002de59:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002de5e:	f7 e9                	imul   %ecx
c002de60:	89 d0                	mov    %edx,%eax
c002de62:	c1 f8 05             	sar    $0x5,%eax
c002de65:	89 ca                	mov    %ecx,%edx
c002de67:	c1 fa 1f             	sar    $0x1f,%edx
c002de6a:	29 d0                	sub    %edx,%eax
c002de6c:	89 45 c8             	mov    %eax,-0x38(%ebp)
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c002de6f:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c002de72:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002de77:	f7 e9                	imul   %ecx
c002de79:	c1 fa 05             	sar    $0x5,%edx
c002de7c:	89 c8                	mov    %ecx,%eax
c002de7e:	c1 f8 1f             	sar    $0x1f,%eax
c002de81:	89 d3                	mov    %edx,%ebx
c002de83:	29 c3                	sub    %eax,%ebx
c002de85:	89 d8                	mov    %ebx,%eax
c002de87:	c1 e0 02             	shl    $0x2,%eax
c002de8a:	01 d8                	add    %ebx,%eax
c002de8c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002de93:	01 d0                	add    %edx,%eax
c002de95:	c1 e0 02             	shl    $0x2,%eax
c002de98:	89 cb                	mov    %ecx,%ebx
c002de9a:	29 c3                	sub    %eax,%ebx
c002de9c:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c002de9f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002dea4:	f7 e9                	imul   %ecx
c002dea6:	c1 fa 05             	sar    $0x5,%edx
c002dea9:	89 c8                	mov    %ecx,%eax
c002deab:	c1 f8 1f             	sar    $0x1f,%eax
c002deae:	89 d7                	mov    %edx,%edi
c002deb0:	29 c7                	sub    %eax,%edi
c002deb2:	8b 75 d0             	mov    -0x30(%ebp),%esi
c002deb5:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002deba:	f7 ee                	imul   %esi
c002debc:	c1 fa 05             	sar    $0x5,%edx
c002debf:	89 f0                	mov    %esi,%eax
c002dec1:	c1 f8 1f             	sar    $0x1f,%eax
c002dec4:	89 d1                	mov    %edx,%ecx
c002dec6:	29 c1                	sub    %eax,%ecx
c002dec8:	89 c8                	mov    %ecx,%eax
c002deca:	c1 e0 02             	shl    $0x2,%eax
c002decd:	01 c8                	add    %ecx,%eax
c002decf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002ded6:	01 d0                	add    %edx,%eax
c002ded8:	c1 e0 02             	shl    $0x2,%eax
c002dedb:	29 c6                	sub    %eax,%esi
c002dedd:	89 f1                	mov    %esi,%ecx
c002dedf:	8b 75 d0             	mov    -0x30(%ebp),%esi
c002dee2:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002dee7:	f7 ee                	imul   %esi
c002dee9:	89 d0                	mov    %edx,%eax
c002deeb:	c1 f8 05             	sar    $0x5,%eax
c002deee:	c1 fe 1f             	sar    $0x1f,%esi
c002def1:	89 f2                	mov    %esi,%edx
c002def3:	29 d0                	sub    %edx,%eax
c002def5:	83 ec 08             	sub    $0x8,%esp
c002def8:	53                   	push   %ebx
c002def9:	57                   	push   %edi
c002defa:	51                   	push   %ecx
c002defb:	50                   	push   %eax
c002defc:	ff 75 c8             	push   -0x38(%ebp)
c002deff:	68 3c 2c 03 c0       	push   $0xc0032c3c
c002df04:	e8 b4 d9 ff ff       	call   c002b8bd <msg>
c002df09:	83 c4 20             	add    $0x20,%esp
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
c002df0c:	81 7d c8 b3 00 00 00 	cmpl   $0xb3,-0x38(%ebp)
c002df13:	7f 0b                	jg     c002df20 <test_mlfqs_recent_1+0x1ad>
            break;
        } 
      last_elapsed = elapsed;
c002df15:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002df18:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    {
c002df1b:	e9 f1 fe ff ff       	jmp    c002de11 <test_mlfqs_recent_1+0x9e>
            break;
c002df20:	90                   	nop
    }
}
c002df21:	90                   	nop
c002df22:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002df25:	5b                   	pop    %ebx
c002df26:	5e                   	pop    %esi
c002df27:	5f                   	pop    %edi
c002df28:	5d                   	pop    %ebp
c002df29:	c3                   	ret    

c002df2a <test_mlfqs_fair_2>:

static void test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step);

void
test_mlfqs_fair_2 (void) 
{
c002df2a:	55                   	push   %ebp
c002df2b:	89 e5                	mov    %esp,%ebp
c002df2d:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (2, 0, 0);
c002df30:	83 ec 04             	sub    $0x4,%esp
c002df33:	6a 00                	push   $0x0
c002df35:	6a 00                	push   $0x0
c002df37:	6a 02                	push   $0x2
c002df39:	e8 54 00 00 00       	call   c002df92 <test_mlfqs_fair>
c002df3e:	83 c4 10             	add    $0x10,%esp
}
c002df41:	90                   	nop
c002df42:	c9                   	leave  
c002df43:	c3                   	ret    

c002df44 <test_mlfqs_fair_20>:

void
test_mlfqs_fair_20 (void) 
{
c002df44:	55                   	push   %ebp
c002df45:	89 e5                	mov    %esp,%ebp
c002df47:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (20, 0, 0);
c002df4a:	83 ec 04             	sub    $0x4,%esp
c002df4d:	6a 00                	push   $0x0
c002df4f:	6a 00                	push   $0x0
c002df51:	6a 14                	push   $0x14
c002df53:	e8 3a 00 00 00       	call   c002df92 <test_mlfqs_fair>
c002df58:	83 c4 10             	add    $0x10,%esp
}
c002df5b:	90                   	nop
c002df5c:	c9                   	leave  
c002df5d:	c3                   	ret    

c002df5e <test_mlfqs_nice_2>:

void
test_mlfqs_nice_2 (void) 
{
c002df5e:	55                   	push   %ebp
c002df5f:	89 e5                	mov    %esp,%ebp
c002df61:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (2, 0, 5);
c002df64:	83 ec 04             	sub    $0x4,%esp
c002df67:	6a 05                	push   $0x5
c002df69:	6a 00                	push   $0x0
c002df6b:	6a 02                	push   $0x2
c002df6d:	e8 20 00 00 00       	call   c002df92 <test_mlfqs_fair>
c002df72:	83 c4 10             	add    $0x10,%esp
}
c002df75:	90                   	nop
c002df76:	c9                   	leave  
c002df77:	c3                   	ret    

c002df78 <test_mlfqs_nice_10>:

void
test_mlfqs_nice_10 (void) 
{
c002df78:	55                   	push   %ebp
c002df79:	89 e5                	mov    %esp,%ebp
c002df7b:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (10, 0, 1);
c002df7e:	83 ec 04             	sub    $0x4,%esp
c002df81:	6a 01                	push   $0x1
c002df83:	6a 00                	push   $0x0
c002df85:	6a 0a                	push   $0xa
c002df87:	e8 06 00 00 00       	call   c002df92 <test_mlfqs_fair>
c002df8c:	83 c4 10             	add    $0x10,%esp
}
c002df8f:	90                   	nop
c002df90:	c9                   	leave  
c002df91:	c3                   	ret    

c002df92 <test_mlfqs_fair>:

static void load_thread (void *aux);

static void
test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step)
{
c002df92:	55                   	push   %ebp
c002df93:	89 e5                	mov    %esp,%ebp
c002df95:	81 ec 78 01 00 00    	sub    $0x178,%esp
  struct thread_info info[MAX_THREAD_CNT];
  int64_t start_time;
  int nice;
  int i;

  ASSERT (thread_mlfqs);
c002df9b:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002dfa0:	84 c0                	test   %al,%al
c002dfa2:	75 1e                	jne    c002dfc2 <test_mlfqs_fair+0x30>
c002dfa4:	83 ec 0c             	sub    $0xc,%esp
c002dfa7:	68 90 2c 03 c0       	push   $0xc0032c90
c002dfac:	68 9d 2c 03 c0       	push   $0xc0032c9d
c002dfb1:	68 dc 2d 03 c0       	push   $0xc0032ddc
c002dfb6:	6a 49                	push   $0x49
c002dfb8:	68 b4 2c 03 c0       	push   $0xc0032cb4
c002dfbd:	e8 5c b5 ff ff       	call   c002951e <debug_panic>
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c002dfc2:	83 7d 08 14          	cmpl   $0x14,0x8(%ebp)
c002dfc6:	7e 1e                	jle    c002dfe6 <test_mlfqs_fair+0x54>
c002dfc8:	83 ec 0c             	sub    $0xc,%esp
c002dfcb:	68 d5 2c 03 c0       	push   $0xc0032cd5
c002dfd0:	68 9d 2c 03 c0       	push   $0xc0032c9d
c002dfd5:	68 dc 2d 03 c0       	push   $0xc0032ddc
c002dfda:	6a 4a                	push   $0x4a
c002dfdc:	68 b4 2c 03 c0       	push   $0xc0032cb4
c002dfe1:	e8 38 b5 ff ff       	call   c002951e <debug_panic>
  ASSERT (nice_min >= -10);
c002dfe6:	83 7d 0c f6          	cmpl   $0xfffffff6,0xc(%ebp)
c002dfea:	7d 1e                	jge    c002e00a <test_mlfqs_fair+0x78>
c002dfec:	83 ec 0c             	sub    $0xc,%esp
c002dfef:	68 f2 2c 03 c0       	push   $0xc0032cf2
c002dff4:	68 9d 2c 03 c0       	push   $0xc0032c9d
c002dff9:	68 dc 2d 03 c0       	push   $0xc0032ddc
c002dffe:	6a 4b                	push   $0x4b
c002e000:	68 b4 2c 03 c0       	push   $0xc0032cb4
c002e005:	e8 14 b5 ff ff       	call   c002951e <debug_panic>
  ASSERT (nice_step >= 0);
c002e00a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002e00e:	79 1e                	jns    c002e02e <test_mlfqs_fair+0x9c>
c002e010:	83 ec 0c             	sub    $0xc,%esp
c002e013:	68 02 2d 03 c0       	push   $0xc0032d02
c002e018:	68 9d 2c 03 c0       	push   $0xc0032c9d
c002e01d:	68 dc 2d 03 c0       	push   $0xc0032ddc
c002e022:	6a 4c                	push   $0x4c
c002e024:	68 b4 2c 03 c0       	push   $0xc0032cb4
c002e029:	e8 f0 b4 ff ff       	call   c002951e <debug_panic>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c002e02e:	8b 45 08             	mov    0x8(%ebp),%eax
c002e031:	48                   	dec    %eax
c002e032:	0f af 45 10          	imul   0x10(%ebp),%eax
c002e036:	89 c2                	mov    %eax,%edx
c002e038:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e03b:	01 d0                	add    %edx,%eax
c002e03d:	83 f8 14             	cmp    $0x14,%eax
c002e040:	7e 1e                	jle    c002e060 <test_mlfqs_fair+0xce>
c002e042:	83 ec 0c             	sub    $0xc,%esp
c002e045:	68 14 2d 03 c0       	push   $0xc0032d14
c002e04a:	68 9d 2c 03 c0       	push   $0xc0032c9d
c002e04f:	68 dc 2d 03 c0       	push   $0xc0032ddc
c002e054:	6a 4d                	push   $0x4d
c002e056:	68 b4 2c 03 c0       	push   $0xc0032cb4
c002e05b:	e8 be b4 ff ff       	call   c002951e <debug_panic>

  thread_set_nice (-20);
c002e060:	83 ec 0c             	sub    $0xc,%esp
c002e063:	6a ec                	push   $0xffffffec
c002e065:	e8 38 2e ff ff       	call   c0020ea2 <thread_set_nice>
c002e06a:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c002e06d:	e8 38 5c ff ff       	call   c0023caa <timer_ticks>
c002e072:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e075:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg ("Starting %d threads...", thread_cnt);
c002e078:	83 ec 08             	sub    $0x8,%esp
c002e07b:	ff 75 08             	push   0x8(%ebp)
c002e07e:	68 42 2d 03 c0       	push   $0xc0032d42
c002e083:	e8 35 d8 ff ff       	call   c002b8bd <msg>
c002e088:	83 c4 10             	add    $0x10,%esp
  nice = nice_min;
c002e08b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e08e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (i = 0; i < thread_cnt; i++) 
c002e091:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e098:	eb 6d                	jmp    c002e107 <test_mlfqs_fair+0x175>
    {
      struct thread_info *ti = &info[i];
c002e09a:	8d 85 a4 fe ff ff    	lea    -0x15c(%ebp),%eax
c002e0a0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002e0a3:	c1 e2 04             	shl    $0x4,%edx
c002e0a6:	01 d0                	add    %edx,%eax
c002e0a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      char name[16];

      ti->start_time = start_time;
c002e0ab:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c002e0ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002e0b1:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002e0b4:	89 01                	mov    %eax,(%ecx)
c002e0b6:	89 51 04             	mov    %edx,0x4(%ecx)
      ti->tick_count = 0;
c002e0b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e0bc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
      ti->nice = nice;
c002e0c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e0c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002e0c9:	89 50 0c             	mov    %edx,0xc(%eax)

      snprintf(name, sizeof name, "load %d", i);
c002e0cc:	ff 75 f0             	push   -0x10(%ebp)
c002e0cf:	68 59 2d 03 c0       	push   $0xc0032d59
c002e0d4:	6a 10                	push   $0x10
c002e0d6:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c002e0dc:	50                   	push   %eax
c002e0dd:	e8 71 90 ff ff       	call   c0027153 <snprintf>
c002e0e2:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, ti);
c002e0e5:	ff 75 e4             	push   -0x1c(%ebp)
c002e0e8:	68 92 e1 02 c0       	push   $0xc002e192
c002e0ed:	6a 1f                	push   $0x1f
c002e0ef:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c002e0f5:	50                   	push   %eax
c002e0f6:	e8 66 29 ff ff       	call   c0020a61 <thread_create>
c002e0fb:	83 c4 10             	add    $0x10,%esp

      nice += nice_step;
c002e0fe:	8b 45 10             	mov    0x10(%ebp),%eax
c002e101:	01 45 f4             	add    %eax,-0xc(%ebp)
  for (i = 0; i < thread_cnt; i++) 
c002e104:	ff 45 f0             	incl   -0x10(%ebp)
c002e107:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e10a:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e10d:	7c 8b                	jl     c002e09a <test_mlfqs_fair+0x108>
    }
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002e10f:	83 ec 08             	sub    $0x8,%esp
c002e112:	ff 75 ec             	push   -0x14(%ebp)
c002e115:	ff 75 e8             	push   -0x18(%ebp)
c002e118:	e8 c2 5b ff ff       	call   c0023cdf <timer_elapsed>
c002e11d:	83 c4 10             	add    $0x10,%esp
c002e120:	83 ec 04             	sub    $0x4,%esp
c002e123:	52                   	push   %edx
c002e124:	50                   	push   %eax
c002e125:	68 64 2d 03 c0       	push   $0xc0032d64
c002e12a:	e8 8e d7 ff ff       	call   c002b8bd <msg>
c002e12f:	83 c4 10             	add    $0x10,%esp

  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002e132:	83 ec 0c             	sub    $0xc,%esp
c002e135:	68 88 2d 03 c0       	push   $0xc0032d88
c002e13a:	e8 7e d7 ff ff       	call   c002b8bd <msg>
c002e13f:	83 c4 10             	add    $0x10,%esp
  timer_sleep (40 * TIMER_FREQ);
c002e142:	83 ec 08             	sub    $0x8,%esp
c002e145:	6a 00                	push   $0x0
c002e147:	68 a0 0f 00 00       	push   $0xfa0
c002e14c:	e8 ad 5b ff ff       	call   c0023cfe <timer_sleep>
c002e151:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < thread_cnt; i++)
c002e154:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e15b:	eb 29                	jmp    c002e186 <test_mlfqs_fair+0x1f4>
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
c002e15d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e160:	c1 e0 04             	shl    $0x4,%eax
c002e163:	8d 4d f8             	lea    -0x8(%ebp),%ecx
c002e166:	01 c8                	add    %ecx,%eax
c002e168:	2d 4c 01 00 00       	sub    $0x14c,%eax
c002e16d:	8b 00                	mov    (%eax),%eax
c002e16f:	83 ec 04             	sub    $0x4,%esp
c002e172:	50                   	push   %eax
c002e173:	ff 75 f0             	push   -0x10(%ebp)
c002e176:	68 bf 2d 03 c0       	push   $0xc0032dbf
c002e17b:	e8 3d d7 ff ff       	call   c002b8bd <msg>
c002e180:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002e183:	ff 45 f0             	incl   -0x10(%ebp)
c002e186:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e189:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e18c:	7c cf                	jl     c002e15d <test_mlfqs_fair+0x1cb>
}
c002e18e:	90                   	nop
c002e18f:	90                   	nop
c002e190:	c9                   	leave  
c002e191:	c3                   	ret    

c002e192 <load_thread>:

static void
load_thread (void *ti_) 
{
c002e192:	55                   	push   %ebp
c002e193:	89 e5                	mov    %esp,%ebp
c002e195:	57                   	push   %edi
c002e196:	56                   	push   %esi
c002e197:	53                   	push   %ebx
c002e198:	83 ec 3c             	sub    $0x3c,%esp
  struct thread_info *ti = ti_;
c002e19b:	8b 45 08             	mov    0x8(%ebp),%eax
c002e19e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  int64_t sleep_time = 5 * TIMER_FREQ;
c002e1a1:	c7 45 d0 f4 01 00 00 	movl   $0x1f4,-0x30(%ebp)
c002e1a8:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
c002e1af:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002e1b2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002e1b5:	05 b8 0b 00 00       	add    $0xbb8,%eax
c002e1ba:	83 d2 00             	adc    $0x0,%edx
c002e1bd:	89 45 c8             	mov    %eax,-0x38(%ebp)
c002e1c0:	89 55 cc             	mov    %edx,-0x34(%ebp)
  int64_t last_time = 0;
c002e1c3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c002e1ca:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  thread_set_nice (ti->nice);
c002e1d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e1d4:	8b 40 0c             	mov    0xc(%eax),%eax
c002e1d7:	83 ec 0c             	sub    $0xc,%esp
c002e1da:	50                   	push   %eax
c002e1db:	e8 c2 2c ff ff       	call   c0020ea2 <thread_set_nice>
c002e1e0:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
c002e1e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e1e6:	8b 50 04             	mov    0x4(%eax),%edx
c002e1e9:	8b 00                	mov    (%eax),%eax
c002e1eb:	83 ec 08             	sub    $0x8,%esp
c002e1ee:	52                   	push   %edx
c002e1ef:	50                   	push   %eax
c002e1f0:	e8 ea 5a ff ff       	call   c0023cdf <timer_elapsed>
c002e1f5:	83 c4 10             	add    $0x10,%esp
c002e1f8:	89 c1                	mov    %eax,%ecx
c002e1fa:	89 d3                	mov    %edx,%ebx
c002e1fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002e1ff:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002e202:	29 c8                	sub    %ecx,%eax
c002e204:	19 da                	sbb    %ebx,%edx
c002e206:	83 ec 08             	sub    $0x8,%esp
c002e209:	52                   	push   %edx
c002e20a:	50                   	push   %eax
c002e20b:	e8 ee 5a ff ff       	call   c0023cfe <timer_sleep>
c002e210:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (ti->start_time) < spin_time) 
c002e213:	eb 42                	jmp    c002e257 <load_thread+0xc5>
    {
      int64_t cur_time = timer_ticks ();
c002e215:	e8 90 5a ff ff       	call   c0023caa <timer_ticks>
c002e21a:	89 45 c0             	mov    %eax,-0x40(%ebp)
c002e21d:	89 55 c4             	mov    %edx,-0x3c(%ebp)
      if (cur_time != last_time)
c002e220:	8b 45 c0             	mov    -0x40(%ebp),%eax
c002e223:	8b 55 c4             	mov    -0x3c(%ebp),%edx
c002e226:	89 c3                	mov    %eax,%ebx
c002e228:	33 5d e0             	xor    -0x20(%ebp),%ebx
c002e22b:	89 de                	mov    %ebx,%esi
c002e22d:	89 d0                	mov    %edx,%eax
c002e22f:	33 45 e4             	xor    -0x1c(%ebp),%eax
c002e232:	89 c7                	mov    %eax,%edi
c002e234:	89 f8                	mov    %edi,%eax
c002e236:	09 f0                	or     %esi,%eax
c002e238:	85 c0                	test   %eax,%eax
c002e23a:	74 0f                	je     c002e24b <load_thread+0xb9>
        ti->tick_count++;
c002e23c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e23f:	8b 40 08             	mov    0x8(%eax),%eax
c002e242:	8d 50 01             	lea    0x1(%eax),%edx
c002e245:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e248:	89 50 08             	mov    %edx,0x8(%eax)
      last_time = cur_time;
c002e24b:	8b 45 c0             	mov    -0x40(%ebp),%eax
c002e24e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
c002e251:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002e254:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  while (timer_elapsed (ti->start_time) < spin_time) 
c002e257:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e25a:	8b 50 04             	mov    0x4(%eax),%edx
c002e25d:	8b 00                	mov    (%eax),%eax
c002e25f:	83 ec 08             	sub    $0x8,%esp
c002e262:	52                   	push   %edx
c002e263:	50                   	push   %eax
c002e264:	e8 76 5a ff ff       	call   c0023cdf <timer_elapsed>
c002e269:	83 c4 10             	add    $0x10,%esp
c002e26c:	3b 45 c8             	cmp    -0x38(%ebp),%eax
c002e26f:	89 d0                	mov    %edx,%eax
c002e271:	1b 45 cc             	sbb    -0x34(%ebp),%eax
c002e274:	7c 9f                	jl     c002e215 <load_thread+0x83>
    }
}
c002e276:	90                   	nop
c002e277:	90                   	nop
c002e278:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002e27b:	5b                   	pop    %ebx
c002e27c:	5e                   	pop    %esi
c002e27d:	5f                   	pop    %edi
c002e27e:	5d                   	pop    %ebp
c002e27f:	c3                   	ret    

c002e280 <test_mlfqs_block>:

static void block_thread (void *lock_);

void
test_mlfqs_block (void) 
{
c002e280:	55                   	push   %ebp
c002e281:	89 e5                	mov    %esp,%ebp
c002e283:	53                   	push   %ebx
c002e284:	83 ec 24             	sub    $0x24,%esp
  int64_t start_time;
  struct lock lock;
  
  ASSERT (thread_mlfqs);
c002e287:	a0 c8 39 03 c0       	mov    0xc00339c8,%al
c002e28c:	84 c0                	test   %al,%al
c002e28e:	75 1e                	jne    c002e2ae <test_mlfqs_block+0x2e>
c002e290:	83 ec 0c             	sub    $0xc,%esp
c002e293:	68 ec 2d 03 c0       	push   $0xc0032dec
c002e298:	68 f9 2d 03 c0       	push   $0xc0032df9
c002e29d:	68 58 2f 03 c0       	push   $0xc0032f58
c002e2a2:	6a 1c                	push   $0x1c
c002e2a4:	68 10 2e 03 c0       	push   $0xc0032e10
c002e2a9:	e8 70 b2 ff ff       	call   c002951e <debug_panic>

  msg ("Main thread acquiring lock.");
c002e2ae:	83 ec 0c             	sub    $0xc,%esp
c002e2b1:	68 32 2e 03 c0       	push   $0xc0032e32
c002e2b6:	e8 02 d6 ff ff       	call   c002b8bd <msg>
c002e2bb:	83 c4 10             	add    $0x10,%esp
  lock_init (&lock);
c002e2be:	83 ec 0c             	sub    $0xc,%esp
c002e2c1:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e2c4:	50                   	push   %eax
c002e2c5:	e8 8b 47 ff ff       	call   c0022a55 <lock_init>
c002e2ca:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002e2cd:	83 ec 0c             	sub    $0xc,%esp
c002e2d0:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e2d3:	50                   	push   %eax
c002e2d4:	e8 c9 47 ff ff       	call   c0022aa2 <lock_acquire>
c002e2d9:	83 c4 10             	add    $0x10,%esp
  
  msg ("Main thread creating block thread, sleeping 25 seconds...");
c002e2dc:	83 ec 0c             	sub    $0xc,%esp
c002e2df:	68 50 2e 03 c0       	push   $0xc0032e50
c002e2e4:	e8 d4 d5 ff ff       	call   c002b8bd <msg>
c002e2e9:	83 c4 10             	add    $0x10,%esp
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
c002e2ec:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e2ef:	50                   	push   %eax
c002e2f0:	68 8a e3 02 c0       	push   $0xc002e38a
c002e2f5:	6a 1f                	push   $0x1f
c002e2f7:	68 8a 2e 03 c0       	push   $0xc0032e8a
c002e2fc:	e8 60 27 ff ff       	call   c0020a61 <thread_create>
c002e301:	83 c4 10             	add    $0x10,%esp
  timer_sleep (25 * TIMER_FREQ);
c002e304:	83 ec 08             	sub    $0x8,%esp
c002e307:	6a 00                	push   $0x0
c002e309:	68 c4 09 00 00       	push   $0x9c4
c002e30e:	e8 eb 59 ff ff       	call   c0023cfe <timer_sleep>
c002e313:	83 c4 10             	add    $0x10,%esp

  msg ("Main thread spinning for 5 seconds...");
c002e316:	83 ec 0c             	sub    $0xc,%esp
c002e319:	68 90 2e 03 c0       	push   $0xc0032e90
c002e31e:	e8 9a d5 ff ff       	call   c002b8bd <msg>
c002e323:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c002e326:	e8 7f 59 ff ff       	call   c0023caa <timer_ticks>
c002e32b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002e32e:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002e331:	eb 01                	jmp    c002e334 <test_mlfqs_block+0xb4>
    continue;
c002e333:	90                   	nop
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002e334:	83 ec 08             	sub    $0x8,%esp
c002e337:	ff 75 f4             	push   -0xc(%ebp)
c002e33a:	ff 75 f0             	push   -0x10(%ebp)
c002e33d:	e8 9d 59 ff ff       	call   c0023cdf <timer_elapsed>
c002e342:	83 c4 10             	add    $0x10,%esp
c002e345:	bb f3 01 00 00       	mov    $0x1f3,%ebx
c002e34a:	b9 00 00 00 00       	mov    $0x0,%ecx
c002e34f:	39 c3                	cmp    %eax,%ebx
c002e351:	19 d1                	sbb    %edx,%ecx
c002e353:	7d de                	jge    c002e333 <test_mlfqs_block+0xb3>

  msg ("Main thread releasing lock.");
c002e355:	83 ec 0c             	sub    $0xc,%esp
c002e358:	68 b6 2e 03 c0       	push   $0xc0032eb6
c002e35d:	e8 5b d5 ff ff       	call   c002b8bd <msg>
c002e362:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c002e365:	83 ec 0c             	sub    $0xc,%esp
c002e368:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e36b:	50                   	push   %eax
c002e36c:	e8 6d 48 ff ff       	call   c0022bde <lock_release>
c002e371:	83 c4 10             	add    $0x10,%esp

  msg ("Block thread should have already acquired lock.");
c002e374:	83 ec 0c             	sub    $0xc,%esp
c002e377:	68 d4 2e 03 c0       	push   $0xc0032ed4
c002e37c:	e8 3c d5 ff ff       	call   c002b8bd <msg>
c002e381:	83 c4 10             	add    $0x10,%esp
}
c002e384:	90                   	nop
c002e385:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e388:	c9                   	leave  
c002e389:	c3                   	ret    

c002e38a <block_thread>:

static void
block_thread (void *lock_) 
{
c002e38a:	55                   	push   %ebp
c002e38b:	89 e5                	mov    %esp,%ebp
c002e38d:	53                   	push   %ebx
c002e38e:	83 ec 14             	sub    $0x14,%esp
  struct lock *lock = lock_;
c002e391:	8b 45 08             	mov    0x8(%ebp),%eax
c002e394:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
c002e397:	83 ec 0c             	sub    $0xc,%esp
c002e39a:	68 04 2f 03 c0       	push   $0xc0032f04
c002e39f:	e8 19 d5 ff ff       	call   c002b8bd <msg>
c002e3a4:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c002e3a7:	e8 fe 58 ff ff       	call   c0023caa <timer_ticks>
c002e3ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e3af:	89 55 ec             	mov    %edx,-0x14(%ebp)
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002e3b2:	eb 01                	jmp    c002e3b5 <block_thread+0x2b>
    continue;
c002e3b4:	90                   	nop
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002e3b5:	83 ec 08             	sub    $0x8,%esp
c002e3b8:	ff 75 ec             	push   -0x14(%ebp)
c002e3bb:	ff 75 e8             	push   -0x18(%ebp)
c002e3be:	e8 1c 59 ff ff       	call   c0023cdf <timer_elapsed>
c002e3c3:	83 c4 10             	add    $0x10,%esp
c002e3c6:	bb cf 07 00 00       	mov    $0x7cf,%ebx
c002e3cb:	b9 00 00 00 00       	mov    $0x0,%ecx
c002e3d0:	39 c3                	cmp    %eax,%ebx
c002e3d2:	19 d1                	sbb    %edx,%ecx
c002e3d4:	7d de                	jge    c002e3b4 <block_thread+0x2a>

  msg ("Block thread acquiring lock...");
c002e3d6:	83 ec 0c             	sub    $0xc,%esp
c002e3d9:	68 2c 2f 03 c0       	push   $0xc0032f2c
c002e3de:	e8 da d4 ff ff       	call   c002b8bd <msg>
c002e3e3:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c002e3e6:	83 ec 0c             	sub    $0xc,%esp
c002e3e9:	ff 75 f4             	push   -0xc(%ebp)
c002e3ec:	e8 b1 46 ff ff       	call   c0022aa2 <lock_acquire>
c002e3f1:	83 c4 10             	add    $0x10,%esp

  msg ("...got it.");
c002e3f4:	83 ec 0c             	sub    $0xc,%esp
c002e3f7:	68 4b 2f 03 c0       	push   $0xc0032f4b
c002e3fc:	e8 bc d4 ff ff       	call   c002b8bd <msg>
c002e401:	83 c4 10             	add    $0x10,%esp
}
c002e404:	90                   	nop
c002e405:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e408:	c9                   	leave  
c002e409:	c3                   	ret    
